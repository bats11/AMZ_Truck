{
  "version": 3,
  "sources": ["../../../dev/materials/src/shadowOnly/shadowOnly.fragment.ts", "../../../dev/materials/src/shadowOnly/shadowOnly.vertex.ts", "../../../dev/materials/src/shadowOnly/shadowOnlyMaterial.ts"],
  "sourcesContent": ["// Do not edit.\nimport { ShaderStore } from \"core/Engines/shaderStore\";\nimport \"core/Shaders/ShadersInclude/helperFunctions\";\nimport \"core/Shaders/ShadersInclude/lightFragmentDeclaration\";\nimport \"core/Shaders/ShadersInclude/lightUboDeclaration\";\nimport \"core/Shaders/ShadersInclude/lightsFragmentFunctions\";\nimport \"core/Shaders/ShadersInclude/shadowsFragmentFunctions\";\nimport \"core/Shaders/ShadersInclude/clipPlaneFragmentDeclaration\";\nimport \"core/Shaders/ShadersInclude/logDepthDeclaration\";\nimport \"core/Shaders/ShadersInclude/fogFragmentDeclaration\";\nimport \"core/Shaders/ShadersInclude/clipPlaneFragment\";\nimport \"core/Shaders/ShadersInclude/lightFragment\";\nimport \"core/Shaders/ShadersInclude/logDepthFragment\";\nimport \"core/Shaders/ShadersInclude/fogFragment\";\nimport \"core/Shaders/ShadersInclude/imageProcessingCompatibility\";\n\nconst name = \"shadowOnlyPixelShader\";\nconst shader = `precision highp float;uniform vec4 vEyePosition;uniform float alpha;uniform vec3 shadowColor;varying vec3 vPositionW;\n#ifdef NORMAL\nvarying vec3 vNormalW;\n#endif\n#include<helperFunctions>\n#include<__decl__lightFragment>[0..maxSimultaneousLights]\n#include<lightsFragmentFunctions>\n#include<shadowsFragmentFunctions>\n#include<clipPlaneFragmentDeclaration>\n#ifdef LOGARITHMICDEPTH\n#extension GL_EXT_frag_depth : enable\n#endif\n#include<logDepthDeclaration>\n#include<fogFragmentDeclaration>\n#define CUSTOM_FRAGMENT_DEFINITIONS\nvoid main(void) {\n#define CUSTOM_FRAGMENT_MAIN_BEGIN\n#include<clipPlaneFragment>\nvec3 viewDirectionW=normalize(vEyePosition.xyz-vPositionW);\n#ifdef NORMAL\nvec3 normalW=normalize(vNormalW);\n#else\nvec3 normalW=vec3(1.0,1.0,1.0);\n#endif\nvec3 diffuseBase=vec3(0.,0.,0.);lightingInfo info;float shadow=1.;float glossiness=0.;float aggShadow=0.;float numLights=0.;\n#include<lightFragment>[0..1]\nvec4 color=vec4(shadowColor,(1.0-clamp(shadow,0.,1.))*alpha);\n#include<logDepthFragment>\n#include<fogFragment>\ngl_FragColor=color;\n#include<imageProcessingCompatibility>\n#define CUSTOM_FRAGMENT_MAIN_END\n}`;\n// Sideeffect\nShaderStore.ShadersStore[name] = shader;\n/** @internal */\nexport const shadowOnlyPixelShader = { name, shader };\n", "// Do not edit.\nimport { ShaderStore } from \"core/Engines/shaderStore\";\nimport \"core/Shaders/ShadersInclude/bonesDeclaration\";\nimport \"core/Shaders/ShadersInclude/bakedVertexAnimationDeclaration\";\nimport \"core/Shaders/ShadersInclude/instancesDeclaration\";\nimport \"core/Shaders/ShadersInclude/clipPlaneVertexDeclaration\";\nimport \"core/Shaders/ShadersInclude/logDepthDeclaration\";\nimport \"core/Shaders/ShadersInclude/fogVertexDeclaration\";\nimport \"core/Shaders/ShadersInclude/lightFragmentDeclaration\";\nimport \"core/Shaders/ShadersInclude/lightUboDeclaration\";\nimport \"core/Shaders/ShadersInclude/instancesVertex\";\nimport \"core/Shaders/ShadersInclude/bonesVertex\";\nimport \"core/Shaders/ShadersInclude/bakedVertexAnimation\";\nimport \"core/Shaders/ShadersInclude/clipPlaneVertex\";\nimport \"core/Shaders/ShadersInclude/logDepthVertex\";\nimport \"core/Shaders/ShadersInclude/fogVertex\";\nimport \"core/Shaders/ShadersInclude/shadowsVertex\";\n\nconst name = \"shadowOnlyVertexShader\";\nconst shader = `precision highp float;attribute vec3 position;\n#ifdef NORMAL\nattribute vec3 normal;\n#endif\n#include<bonesDeclaration>\n#include<bakedVertexAnimationDeclaration>\n#include<instancesDeclaration>\nuniform mat4 view;uniform mat4 viewProjection;\n#ifdef POINTSIZE\nuniform float pointSize;\n#endif\nvarying vec3 vPositionW;\n#ifdef NORMAL\nvarying vec3 vNormalW;\n#endif\n#ifdef VERTEXCOLOR\nvarying vec4 vColor;\n#endif\n#include<clipPlaneVertexDeclaration>\n#include<logDepthDeclaration>\n#include<fogVertexDeclaration>\n#include<__decl__lightFragment>[0..maxSimultaneousLights]\n#define CUSTOM_VERTEX_DEFINITIONS\nvoid main(void) {\n#define CUSTOM_VERTEX_MAIN_BEGIN\n#include<instancesVertex>\n#include<bonesVertex>\n#include<bakedVertexAnimation>\nvec4 worldPos=finalWorld*vec4(position,1.0);gl_Position=viewProjection*worldPos;vPositionW=vec3(worldPos);\n#ifdef NORMAL\nvNormalW=normalize(vec3(finalWorld*vec4(normal,0.0)));\n#endif\n#include<clipPlaneVertex>\n#include<logDepthVertex>\n#include<fogVertex>\n#include<shadowsVertex>[0..maxSimultaneousLights]\n#if defined(POINTSIZE) && !defined(WEBGPU)\ngl_PointSize=pointSize;\n#endif\n#define CUSTOM_VERTEX_MAIN_END\n}\n`;\n// Sideeffect\nShaderStore.ShadersStore[name] = shader;\n/** @internal */\nexport const shadowOnlyVertexShader = { name, shader };\n", "/* eslint-disable @typescript-eslint/naming-convention */\r\nimport type { Nullable } from \"core/types\";\r\nimport { SerializationHelper } from \"core/Misc/decorators.serialization\";\r\nimport type { Matrix } from \"core/Maths/math.vector\";\r\nimport { Color3 } from \"core/Maths/math.color\";\r\nimport type { BaseTexture } from \"core/Materials/Textures/baseTexture\";\r\nimport type { IShadowLight } from \"core/Lights/shadowLight\";\r\nimport type { IEffectCreationOptions } from \"core/Materials/effect\";\r\nimport { MaterialDefines } from \"core/Materials/materialDefines\";\r\nimport { PushMaterial } from \"core/Materials/pushMaterial\";\r\nimport { VertexBuffer } from \"core/Buffers/buffer\";\r\nimport type { AbstractMesh } from \"core/Meshes/abstractMesh\";\r\nimport type { SubMesh } from \"core/Meshes/subMesh\";\r\nimport type { Mesh } from \"core/Meshes/mesh\";\r\nimport { Scene } from \"core/scene\";\r\nimport { RegisterClass } from \"core/Misc/typeStore\";\r\n\r\nimport \"./shadowOnly.fragment\";\r\nimport \"./shadowOnly.vertex\";\r\nimport { EffectFallbacks } from \"core/Materials/effectFallbacks\";\r\nimport type { CascadedShadowGenerator } from \"core/Lights/Shadows/cascadedShadowGenerator\";\r\nimport { addClipPlaneUniforms, bindClipPlane } from \"core/Materials/clipPlaneMaterialHelper\";\r\nimport {\r\n    BindBonesParameters,\r\n    BindFogParameters,\r\n    BindLights,\r\n    BindLogDepth,\r\n    HandleFallbacksForShadows,\r\n    PrepareAttributesForBones,\r\n    PrepareAttributesForInstances,\r\n    PrepareDefinesForAttributes,\r\n    PrepareDefinesForFrameBoundValues,\r\n    PrepareDefinesForLights,\r\n    PrepareDefinesForMisc,\r\n    PrepareUniformsAndSamplersList,\r\n} from \"core/Materials/materialHelper.functions\";\r\n\r\nclass ShadowOnlyMaterialDefines extends MaterialDefines {\r\n    public CLIPPLANE = false;\r\n    public CLIPPLANE2 = false;\r\n    public CLIPPLANE3 = false;\r\n    public CLIPPLANE4 = false;\r\n    public CLIPPLANE5 = false;\r\n    public CLIPPLANE6 = false;\r\n    public POINTSIZE = false;\r\n    public FOG = false;\r\n    public NORMAL = false;\r\n    public NUM_BONE_INFLUENCERS = 0;\r\n    public BonesPerMesh = 0;\r\n    public INSTANCES = false;\r\n    public IMAGEPROCESSINGPOSTPROCESS = false;\r\n    public SKIPFINALCOLORCLAMP = false;\r\n    public LOGARITHMICDEPTH = false;\r\n\r\n    constructor() {\r\n        super();\r\n        this.rebuild();\r\n    }\r\n}\r\n\r\nexport class ShadowOnlyMaterial extends PushMaterial {\r\n    private _activeLight: IShadowLight;\r\n    private _needAlphaBlending = true;\r\n\r\n    constructor(name: string, scene?: Scene) {\r\n        super(name, scene);\r\n    }\r\n\r\n    public shadowColor = Color3.Black();\r\n\r\n    public needAlphaBlending(): boolean {\r\n        return this._needAlphaBlending;\r\n    }\r\n\r\n    public needAlphaTesting(): boolean {\r\n        return false;\r\n    }\r\n\r\n    public getAlphaTestTexture(): Nullable<BaseTexture> {\r\n        return null;\r\n    }\r\n\r\n    public get activeLight(): IShadowLight {\r\n        return this._activeLight;\r\n    }\r\n\r\n    public set activeLight(light: IShadowLight) {\r\n        this._activeLight = light;\r\n    }\r\n\r\n    private _getFirstShadowLightForMesh(mesh: AbstractMesh): Nullable<IShadowLight> {\r\n        for (const light of mesh.lightSources) {\r\n            if (light.shadowEnabled) {\r\n                return light as IShadowLight;\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n\r\n    // Methods\r\n    public isReadyForSubMesh(mesh: AbstractMesh, subMesh: SubMesh, useInstances?: boolean): boolean {\r\n        const drawWrapper = subMesh._drawWrapper;\r\n\r\n        if (this.isFrozen) {\r\n            if (drawWrapper.effect && drawWrapper._wasPreviouslyReady && drawWrapper._wasPreviouslyUsingInstances === useInstances) {\r\n                return true;\r\n            }\r\n        }\r\n\r\n        if (!subMesh.materialDefines) {\r\n            subMesh.materialDefines = new ShadowOnlyMaterialDefines();\r\n        }\r\n\r\n        const defines = <ShadowOnlyMaterialDefines>subMesh.materialDefines;\r\n        const scene = this.getScene();\r\n\r\n        if (this._isReadyForSubMesh(subMesh)) {\r\n            return true;\r\n        }\r\n\r\n        const engine = scene.getEngine();\r\n\r\n        // Ensure that active light is the first shadow light\r\n        if (this._activeLight) {\r\n            for (const light of mesh.lightSources) {\r\n                if (light.shadowEnabled) {\r\n                    if (this._activeLight === light) {\r\n                        break; // We are good\r\n                    }\r\n\r\n                    const lightPosition = mesh.lightSources.indexOf(this._activeLight);\r\n\r\n                    if (lightPosition !== -1) {\r\n                        mesh.lightSources.splice(lightPosition, 1);\r\n                        mesh.lightSources.splice(0, 0, this._activeLight);\r\n                    }\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n\r\n        PrepareDefinesForFrameBoundValues(scene, engine, this, defines, useInstances ? true : false);\r\n\r\n        PrepareDefinesForMisc(mesh, scene, this._useLogarithmicDepth, this.pointsCloud, this.fogEnabled, this._shouldTurnAlphaTestOn(mesh), defines);\r\n\r\n        defines._needNormals = PrepareDefinesForLights(scene, mesh, defines, false, 1);\r\n\r\n        const shadowGenerator = this._getFirstShadowLightForMesh(mesh)?.getShadowGenerator();\r\n\r\n        this._needAlphaBlending = true;\r\n\r\n        if (shadowGenerator && (shadowGenerator as any).getClassName && (shadowGenerator as any).getClassName() === \"CascadedShadowGenerator\") {\r\n            const csg = shadowGenerator as CascadedShadowGenerator;\r\n\r\n            this._needAlphaBlending = !csg.autoCalcDepthBounds;\r\n        }\r\n\r\n        // Attribs\r\n        PrepareDefinesForAttributes(mesh, defines, false, true);\r\n\r\n        // Get correct effect\r\n        if (defines.isDirty) {\r\n            defines.markAsProcessed();\r\n\r\n            scene.resetCachedMaterial();\r\n\r\n            // Fallbacks\r\n            const fallbacks = new EffectFallbacks();\r\n            if (defines.FOG) {\r\n                fallbacks.addFallback(1, \"FOG\");\r\n            }\r\n\r\n            HandleFallbacksForShadows(defines, fallbacks, 1);\r\n\r\n            if (defines.NUM_BONE_INFLUENCERS > 0) {\r\n                fallbacks.addCPUSkinningFallback(0, mesh);\r\n            }\r\n\r\n            defines.IMAGEPROCESSINGPOSTPROCESS = scene.imageProcessingConfiguration.applyByPostProcess;\r\n\r\n            //Attributes\r\n            const attribs = [VertexBuffer.PositionKind];\r\n\r\n            if (defines.NORMAL) {\r\n                attribs.push(VertexBuffer.NormalKind);\r\n            }\r\n\r\n            PrepareAttributesForBones(attribs, mesh, defines, fallbacks);\r\n            PrepareAttributesForInstances(attribs, defines);\r\n\r\n            const shaderName = \"shadowOnly\";\r\n            const join = defines.toString();\r\n            const uniforms = [\r\n                \"world\",\r\n                \"view\",\r\n                \"viewProjection\",\r\n                \"vEyePosition\",\r\n                \"vLightsType\",\r\n                \"vFogInfos\",\r\n                \"vFogColor\",\r\n                \"pointSize\",\r\n                \"alpha\",\r\n                \"shadowColor\",\r\n                \"mBones\",\r\n                \"logarithmicDepthConstant\",\r\n            ];\r\n            const samplers: string[] = [];\r\n\r\n            const uniformBuffers: string[] = [];\r\n\r\n            addClipPlaneUniforms(uniforms);\r\n            PrepareUniformsAndSamplersList(<IEffectCreationOptions>{\r\n                uniformsNames: uniforms,\r\n                uniformBuffersNames: uniformBuffers,\r\n                samplers: samplers,\r\n                defines: defines,\r\n                maxSimultaneousLights: 1,\r\n            });\r\n\r\n            subMesh.setEffect(\r\n                scene.getEngine().createEffect(\r\n                    shaderName,\r\n                    <IEffectCreationOptions>{\r\n                        attributes: attribs,\r\n                        uniformsNames: uniforms,\r\n                        uniformBuffersNames: uniformBuffers,\r\n                        samplers: samplers,\r\n                        defines: join,\r\n                        fallbacks: fallbacks,\r\n                        onCompiled: this.onCompiled,\r\n                        onError: this.onError,\r\n                        indexParameters: { maxSimultaneousLights: 1 },\r\n                    },\r\n                    engine\r\n                ),\r\n                defines,\r\n                this._materialContext\r\n            );\r\n        }\r\n        if (!subMesh.effect || !subMesh.effect.isReady()) {\r\n            return false;\r\n        }\r\n\r\n        defines._renderId = scene.getRenderId();\r\n        drawWrapper._wasPreviouslyReady = true;\r\n        drawWrapper._wasPreviouslyUsingInstances = !!useInstances;\r\n\r\n        return true;\r\n    }\r\n\r\n    public bindForSubMesh(world: Matrix, mesh: Mesh, subMesh: SubMesh): void {\r\n        const scene = this.getScene();\r\n\r\n        const defines = <ShadowOnlyMaterialDefines>subMesh.materialDefines;\r\n        if (!defines) {\r\n            return;\r\n        }\r\n\r\n        const effect = subMesh.effect;\r\n        if (!effect) {\r\n            return;\r\n        }\r\n        this._activeEffect = effect;\r\n\r\n        // Matrices\r\n        this.bindOnlyWorldMatrix(world);\r\n        this._activeEffect.setMatrix(\"viewProjection\", scene.getTransformMatrix());\r\n\r\n        // Bones\r\n        BindBonesParameters(mesh, this._activeEffect);\r\n\r\n        if (this._mustRebind(scene, effect, subMesh)) {\r\n            // Clip plane\r\n            bindClipPlane(effect, this, scene);\r\n\r\n            // Point size\r\n            if (this.pointsCloud) {\r\n                this._activeEffect.setFloat(\"pointSize\", this.pointSize);\r\n            }\r\n\r\n            this._activeEffect.setFloat(\"alpha\", this.alpha);\r\n            this._activeEffect.setColor3(\"shadowColor\", this.shadowColor);\r\n\r\n            // Log. depth\r\n            if (this._useLogarithmicDepth) {\r\n                BindLogDepth(defines, effect, scene);\r\n            }\r\n\r\n            scene.bindEyePosition(effect);\r\n        }\r\n\r\n        // Lights\r\n        if (scene.lightsEnabled) {\r\n            BindLights(scene, mesh, this._activeEffect, defines, 1);\r\n\r\n            const light = this._getFirstShadowLightForMesh(mesh);\r\n\r\n            if (light) {\r\n                // Make sure the uniforms for this light will be rebound for other materials using this light when rendering the current frame.\r\n                // Indeed, there is an optimization in Light that binds the light uniforms only once per frame for a given light (if using ubo).\r\n                // Doing this way assumes that all uses of this light are the same, meaning all parameters passed to Light._bindLlight\r\n                // are the same, notably useSpecular. However, isReadyForSubMesh (see above) is passing false for this parameter, which may not be\r\n                // the value the other materials may pass.\r\n                light._renderId = -1;\r\n            }\r\n        }\r\n\r\n        // View\r\n        if ((scene.fogEnabled && mesh.applyFog && scene.fogMode !== Scene.FOGMODE_NONE) || defines[\"SHADOWCSM0\"]) {\r\n            this._activeEffect.setMatrix(\"view\", scene.getViewMatrix());\r\n        }\r\n\r\n        // Fog\r\n        BindFogParameters(scene, mesh, this._activeEffect);\r\n\r\n        this._afterBind(mesh, this._activeEffect, subMesh);\r\n    }\r\n\r\n    public clone(name: string): ShadowOnlyMaterial {\r\n        return SerializationHelper.Clone<ShadowOnlyMaterial>(() => new ShadowOnlyMaterial(name, this.getScene()), this);\r\n    }\r\n\r\n    public serialize(): any {\r\n        const serializationObject = super.serialize();\r\n        serializationObject.customType = \"BABYLON.ShadowOnlyMaterial\";\r\n        return serializationObject;\r\n    }\r\n\r\n    public getClassName(): string {\r\n        return \"ShadowOnlyMaterial\";\r\n    }\r\n\r\n    // Statics\r\n    public static Parse(source: any, scene: Scene, rootUrl: string): ShadowOnlyMaterial {\r\n        return SerializationHelper.Parse(() => new ShadowOnlyMaterial(source.name, scene), source, scene, rootUrl);\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.ShadowOnlyMaterial\", ShadowOnlyMaterial);\r\n"],
  "mappings": "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",
  "names": ["name", "shader", "name"]
}
