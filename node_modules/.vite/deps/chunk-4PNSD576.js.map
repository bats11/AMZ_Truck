{
  "version": 3,
  "sources": ["../../../dev/core/src/Misc/dds.ts", "../../../dev/core/src/Materials/Textures/Loaders/ddsTextureLoader.ts", "../../../dev/core/src/Materials/Textures/Loaders/envTextureLoader.ts", "../../../dev/core/src/Misc/khronosTextureContainer.ts", "../../../dev/core/src/Materials/Textures/ktx2decoderTypes.ts", "../../../dev/core/src/Misc/khronosTextureContainer2Worker.ts", "../../../dev/core/src/Misc/khronosTextureContainer2.ts", "../../../dev/core/src/Materials/Textures/Loaders/ktxTextureLoader.ts", "../../../dev/core/src/Misc/tga.ts", "../../../dev/core/src/Materials/Textures/Loaders/tgaTextureLoader.ts", "../../../dev/core/src/Misc/HighDynamicRange/panoramaToCubemap.ts", "../../../dev/core/src/Misc/HighDynamicRange/hdr.ts", "../../../dev/core/src/Materials/Textures/Loaders/hdrTextureLoader.ts", "../../../dev/core/src/Misc/basisWorker.ts", "../../../dev/core/src/Misc/basis.ts", "../../../dev/core/src/Materials/Textures/Loaders/basisTextureLoader.ts"],
  "sourcesContent": ["/* eslint-disable @typescript-eslint/naming-convention */\r\nimport { Scalar } from \"../Maths/math.scalar\";\r\nimport { SphericalPolynomial } from \"../Maths/sphericalPolynomial\";\r\nimport { Constants } from \"../Engines/constants\";\r\nimport { InternalTexture, InternalTextureSource } from \"../Materials/Textures/internalTexture\";\r\nimport type { Nullable } from \"../types\";\r\nimport { Logger } from \"../Misc/logger\";\r\nimport { CubeMapToSphericalPolynomialTools } from \"../Misc/HighDynamicRange/cubemapToSphericalPolynomial\";\r\nimport type { Scene } from \"../scene\";\r\nimport { BaseTexture } from \"../Materials/Textures/baseTexture\";\r\nimport { ThinEngine } from \"../Engines/thinEngine\";\r\nimport { FromHalfFloat, ToHalfFloat } from \"./textureTools\";\r\n\r\nimport \"../Engines/Extensions/engine.cubeTexture\";\r\n\r\n// Based on demo done by Brandon Jones - http://media.tojicode.com/webgl-samples/dds.html\r\n// All values and structures referenced from:\r\n// http://msdn.microsoft.com/en-us/library/bb943991.aspx/\r\nconst DDS_MAGIC = 0x20534444;\r\n\r\nconst //DDSD_CAPS = 0x1,\r\n    //DDSD_HEIGHT = 0x2,\r\n    //DDSD_WIDTH = 0x4,\r\n    //DDSD_PITCH = 0x8,\r\n    //DDSD_PIXELFORMAT = 0x1000,\r\n    DDSD_MIPMAPCOUNT = 0x20000;\r\n//DDSD_LINEARSIZE = 0x80000,\r\n//DDSD_DEPTH = 0x800000;\r\n\r\n// var DDSCAPS_COMPLEX = 0x8,\r\n//     DDSCAPS_MIPMAP = 0x400000,\r\n//     DDSCAPS_TEXTURE = 0x1000;\r\n\r\nconst DDSCAPS2_CUBEMAP = 0x200;\r\n// DDSCAPS2_CUBEMAP_POSITIVEX = 0x400,\r\n// DDSCAPS2_CUBEMAP_NEGATIVEX = 0x800,\r\n// DDSCAPS2_CUBEMAP_POSITIVEY = 0x1000,\r\n// DDSCAPS2_CUBEMAP_NEGATIVEY = 0x2000,\r\n// DDSCAPS2_CUBEMAP_POSITIVEZ = 0x4000,\r\n// DDSCAPS2_CUBEMAP_NEGATIVEZ = 0x8000,\r\n// DDSCAPS2_VOLUME = 0x200000;\r\n\r\nconst //DDPF_ALPHAPIXELS = 0x1,\r\n    //DDPF_ALPHA = 0x2,\r\n    DDPF_FOURCC = 0x4,\r\n    DDPF_RGB = 0x40,\r\n    //DDPF_YUV = 0x200,\r\n    DDPF_LUMINANCE = 0x20000;\r\n\r\nfunction FourCCToInt32(value: string) {\r\n    return value.charCodeAt(0) + (value.charCodeAt(1) << 8) + (value.charCodeAt(2) << 16) + (value.charCodeAt(3) << 24);\r\n}\r\n\r\nfunction Int32ToFourCC(value: number) {\r\n    return String.fromCharCode(value & 0xff, (value >> 8) & 0xff, (value >> 16) & 0xff, (value >> 24) & 0xff);\r\n}\r\n\r\nconst FOURCC_DXT1 = FourCCToInt32(\"DXT1\");\r\nconst FOURCC_DXT3 = FourCCToInt32(\"DXT3\");\r\nconst FOURCC_DXT5 = FourCCToInt32(\"DXT5\");\r\nconst FOURCC_DX10 = FourCCToInt32(\"DX10\");\r\nconst FOURCC_D3DFMT_R16G16B16A16F = 113;\r\nconst FOURCC_D3DFMT_R32G32B32A32F = 116;\r\n\r\nconst DXGI_FORMAT_R32G32B32A32_FLOAT = 2;\r\nconst DXGI_FORMAT_R16G16B16A16_FLOAT = 10;\r\nconst DXGI_FORMAT_B8G8R8X8_UNORM = 88;\r\n\r\nconst headerLengthInt = 31; // The header length in 32 bit ints\r\n\r\n// Offsets into the header array\r\nconst off_magic = 0;\r\n\r\nconst off_size = 1;\r\nconst off_flags = 2;\r\nconst off_height = 3;\r\nconst off_width = 4;\r\n\r\nconst off_mipmapCount = 7;\r\n\r\nconst off_pfFlags = 20;\r\nconst off_pfFourCC = 21;\r\nconst off_RGBbpp = 22;\r\nconst off_RMask = 23;\r\nconst off_GMask = 24;\r\nconst off_BMask = 25;\r\nconst off_AMask = 26;\r\n// var off_caps1 = 27;\r\nconst off_caps2 = 28;\r\n// var off_caps3 = 29;\r\n// var off_caps4 = 30;\r\nconst off_dxgiFormat = 32;\r\n\r\n/**\r\n * Direct draw surface info\r\n * @see https://docs.microsoft.com/en-us/windows/desktop/direct3ddds/dx-graphics-dds-pguide\r\n */\r\nexport interface DDSInfo {\r\n    /**\r\n     * Width of the texture\r\n     */\r\n    width: number;\r\n    /**\r\n     * Width of the texture\r\n     */\r\n    height: number;\r\n    /**\r\n     * Number of Mipmaps for the texture\r\n     * @see https://en.wikipedia.org/wiki/Mipmap\r\n     */\r\n    mipmapCount: number;\r\n    /**\r\n     * If the textures format is a known fourCC format\r\n     * @see https://www.fourcc.org/\r\n     */\r\n    isFourCC: boolean;\r\n    /**\r\n     * If the texture is an RGB format eg. DXGI_FORMAT_B8G8R8X8_UNORM format\r\n     */\r\n    isRGB: boolean;\r\n    /**\r\n     * If the texture is a lumincance format\r\n     */\r\n    isLuminance: boolean;\r\n    /**\r\n     * If this is a cube texture\r\n     * @see https://docs.microsoft.com/en-us/windows/desktop/direct3ddds/dds-file-layout-for-cubic-environment-maps\r\n     */\r\n    isCube: boolean;\r\n    /**\r\n     * If the texture is a compressed format eg. FOURCC_DXT1\r\n     */\r\n    isCompressed: boolean;\r\n    /**\r\n     * The dxgiFormat of the texture\r\n     * @see https://docs.microsoft.com/en-us/windows/desktop/api/dxgiformat/ne-dxgiformat-dxgi_format\r\n     */\r\n    dxgiFormat: number;\r\n    /**\r\n     * Texture type eg. Engine.TEXTURETYPE_UNSIGNED_INT, Engine.TEXTURETYPE_FLOAT\r\n     */\r\n    textureType: number;\r\n    /**\r\n     * Sphericle polynomial created for the dds texture\r\n     */\r\n    sphericalPolynomial?: SphericalPolynomial;\r\n}\r\n\r\n/**\r\n * Class used to provide DDS decompression tools\r\n */\r\nexport class DDSTools {\r\n    /**\r\n     * Gets or sets a boolean indicating that LOD info is stored in alpha channel (false by default)\r\n     */\r\n    public static StoreLODInAlphaChannel = false;\r\n\r\n    /**\r\n     * Gets DDS information from an array buffer\r\n     * @param data defines the array buffer view to read data from\r\n     * @returns the DDS information\r\n     */\r\n    public static GetDDSInfo(data: ArrayBufferView): DDSInfo {\r\n        const header = new Int32Array(data.buffer, data.byteOffset, headerLengthInt);\r\n        const extendedHeader = new Int32Array(data.buffer, data.byteOffset, headerLengthInt + 4);\r\n\r\n        let mipmapCount = 1;\r\n        if (header[off_flags] & DDSD_MIPMAPCOUNT) {\r\n            mipmapCount = Math.max(1, header[off_mipmapCount]);\r\n        }\r\n\r\n        const fourCC = header[off_pfFourCC];\r\n        const dxgiFormat = fourCC === FOURCC_DX10 ? extendedHeader[off_dxgiFormat] : 0;\r\n        let textureType = Constants.TEXTURETYPE_UNSIGNED_INT;\r\n\r\n        switch (fourCC) {\r\n            case FOURCC_D3DFMT_R16G16B16A16F:\r\n                textureType = Constants.TEXTURETYPE_HALF_FLOAT;\r\n                break;\r\n            case FOURCC_D3DFMT_R32G32B32A32F:\r\n                textureType = Constants.TEXTURETYPE_FLOAT;\r\n                break;\r\n            case FOURCC_DX10:\r\n                if (dxgiFormat === DXGI_FORMAT_R16G16B16A16_FLOAT) {\r\n                    textureType = Constants.TEXTURETYPE_HALF_FLOAT;\r\n                    break;\r\n                }\r\n                if (dxgiFormat === DXGI_FORMAT_R32G32B32A32_FLOAT) {\r\n                    textureType = Constants.TEXTURETYPE_FLOAT;\r\n                    break;\r\n                }\r\n        }\r\n\r\n        return {\r\n            width: header[off_width],\r\n            height: header[off_height],\r\n            mipmapCount: mipmapCount,\r\n            isFourCC: (header[off_pfFlags] & DDPF_FOURCC) === DDPF_FOURCC,\r\n            isRGB: (header[off_pfFlags] & DDPF_RGB) === DDPF_RGB,\r\n            isLuminance: (header[off_pfFlags] & DDPF_LUMINANCE) === DDPF_LUMINANCE,\r\n            isCube: (header[off_caps2] & DDSCAPS2_CUBEMAP) === DDSCAPS2_CUBEMAP,\r\n            isCompressed: fourCC === FOURCC_DXT1 || fourCC === FOURCC_DXT3 || fourCC === FOURCC_DXT5,\r\n            dxgiFormat: dxgiFormat,\r\n            textureType: textureType,\r\n        };\r\n    }\r\n\r\n    private static _GetHalfFloatAsFloatRGBAArrayBuffer(width: number, height: number, dataOffset: number, dataLength: number, arrayBuffer: ArrayBuffer, lod: number): Float32Array {\r\n        const destArray = new Float32Array(dataLength);\r\n        const srcData = new Uint16Array(arrayBuffer, dataOffset);\r\n        let index = 0;\r\n        for (let y = 0; y < height; y++) {\r\n            for (let x = 0; x < width; x++) {\r\n                const srcPos = (x + y * width) * 4;\r\n                destArray[index] = FromHalfFloat(srcData[srcPos]);\r\n                destArray[index + 1] = FromHalfFloat(srcData[srcPos + 1]);\r\n                destArray[index + 2] = FromHalfFloat(srcData[srcPos + 2]);\r\n                if (DDSTools.StoreLODInAlphaChannel) {\r\n                    destArray[index + 3] = lod;\r\n                } else {\r\n                    destArray[index + 3] = FromHalfFloat(srcData[srcPos + 3]);\r\n                }\r\n                index += 4;\r\n            }\r\n        }\r\n\r\n        return destArray;\r\n    }\r\n\r\n    private static _GetHalfFloatRGBAArrayBuffer(width: number, height: number, dataOffset: number, dataLength: number, arrayBuffer: ArrayBuffer, lod: number): Uint16Array {\r\n        if (DDSTools.StoreLODInAlphaChannel) {\r\n            const destArray = new Uint16Array(dataLength);\r\n            const srcData = new Uint16Array(arrayBuffer, dataOffset);\r\n            let index = 0;\r\n            for (let y = 0; y < height; y++) {\r\n                for (let x = 0; x < width; x++) {\r\n                    const srcPos = (x + y * width) * 4;\r\n                    destArray[index] = srcData[srcPos];\r\n                    destArray[index + 1] = srcData[srcPos + 1];\r\n                    destArray[index + 2] = srcData[srcPos + 2];\r\n                    destArray[index + 3] = ToHalfFloat(lod);\r\n                    index += 4;\r\n                }\r\n            }\r\n\r\n            return destArray;\r\n        }\r\n\r\n        return new Uint16Array(arrayBuffer, dataOffset, dataLength);\r\n    }\r\n\r\n    private static _GetFloatRGBAArrayBuffer(width: number, height: number, dataOffset: number, dataLength: number, arrayBuffer: ArrayBuffer, lod: number): Float32Array {\r\n        if (DDSTools.StoreLODInAlphaChannel) {\r\n            const destArray = new Float32Array(dataLength);\r\n            const srcData = new Float32Array(arrayBuffer, dataOffset);\r\n            let index = 0;\r\n            for (let y = 0; y < height; y++) {\r\n                for (let x = 0; x < width; x++) {\r\n                    const srcPos = (x + y * width) * 4;\r\n                    destArray[index] = srcData[srcPos];\r\n                    destArray[index + 1] = srcData[srcPos + 1];\r\n                    destArray[index + 2] = srcData[srcPos + 2];\r\n                    destArray[index + 3] = lod;\r\n                    index += 4;\r\n                }\r\n            }\r\n\r\n            return destArray;\r\n        }\r\n        return new Float32Array(arrayBuffer, dataOffset, dataLength);\r\n    }\r\n\r\n    private static _GetFloatAsHalfFloatRGBAArrayBuffer(width: number, height: number, dataOffset: number, dataLength: number, arrayBuffer: ArrayBuffer, lod: number): Uint16Array {\r\n        const destArray = new Uint16Array(dataLength);\r\n        const srcData = new Float32Array(arrayBuffer, dataOffset);\r\n        let index = 0;\r\n        for (let y = 0; y < height; y++) {\r\n            for (let x = 0; x < width; x++) {\r\n                destArray[index] = ToHalfFloat(srcData[index]);\r\n                destArray[index + 1] = ToHalfFloat(srcData[index + 1]);\r\n                destArray[index + 2] = ToHalfFloat(srcData[index + 2]);\r\n                if (DDSTools.StoreLODInAlphaChannel) {\r\n                    destArray[index + 3] = ToHalfFloat(lod);\r\n                } else {\r\n                    destArray[index + 3] = ToHalfFloat(srcData[index + 3]);\r\n                }\r\n                index += 4;\r\n            }\r\n        }\r\n\r\n        return destArray;\r\n    }\r\n\r\n    private static _GetFloatAsUIntRGBAArrayBuffer(width: number, height: number, dataOffset: number, dataLength: number, arrayBuffer: ArrayBuffer, lod: number): Uint8Array {\r\n        const destArray = new Uint8Array(dataLength);\r\n        const srcData = new Float32Array(arrayBuffer, dataOffset);\r\n        let index = 0;\r\n        for (let y = 0; y < height; y++) {\r\n            for (let x = 0; x < width; x++) {\r\n                const srcPos = (x + y * width) * 4;\r\n                destArray[index] = Scalar.Clamp(srcData[srcPos]) * 255;\r\n                destArray[index + 1] = Scalar.Clamp(srcData[srcPos + 1]) * 255;\r\n                destArray[index + 2] = Scalar.Clamp(srcData[srcPos + 2]) * 255;\r\n                if (DDSTools.StoreLODInAlphaChannel) {\r\n                    destArray[index + 3] = lod;\r\n                } else {\r\n                    destArray[index + 3] = Scalar.Clamp(srcData[srcPos + 3]) * 255;\r\n                }\r\n                index += 4;\r\n            }\r\n        }\r\n\r\n        return destArray;\r\n    }\r\n\r\n    private static _GetHalfFloatAsUIntRGBAArrayBuffer(width: number, height: number, dataOffset: number, dataLength: number, arrayBuffer: ArrayBuffer, lod: number): Uint8Array {\r\n        const destArray = new Uint8Array(dataLength);\r\n        const srcData = new Uint16Array(arrayBuffer, dataOffset);\r\n        let index = 0;\r\n        for (let y = 0; y < height; y++) {\r\n            for (let x = 0; x < width; x++) {\r\n                const srcPos = (x + y * width) * 4;\r\n                destArray[index] = Scalar.Clamp(FromHalfFloat(srcData[srcPos])) * 255;\r\n                destArray[index + 1] = Scalar.Clamp(FromHalfFloat(srcData[srcPos + 1])) * 255;\r\n                destArray[index + 2] = Scalar.Clamp(FromHalfFloat(srcData[srcPos + 2])) * 255;\r\n                if (DDSTools.StoreLODInAlphaChannel) {\r\n                    destArray[index + 3] = lod;\r\n                } else {\r\n                    destArray[index + 3] = Scalar.Clamp(FromHalfFloat(srcData[srcPos + 3])) * 255;\r\n                }\r\n                index += 4;\r\n            }\r\n        }\r\n\r\n        return destArray;\r\n    }\r\n\r\n    private static _GetRGBAArrayBuffer(\r\n        width: number,\r\n        height: number,\r\n        dataOffset: number,\r\n        dataLength: number,\r\n        arrayBuffer: ArrayBuffer,\r\n        rOffset: number,\r\n        gOffset: number,\r\n        bOffset: number,\r\n        aOffset: number\r\n    ): Uint8Array {\r\n        const byteArray = new Uint8Array(dataLength);\r\n        const srcData = new Uint8Array(arrayBuffer, dataOffset);\r\n        let index = 0;\r\n        for (let y = 0; y < height; y++) {\r\n            for (let x = 0; x < width; x++) {\r\n                const srcPos = (x + y * width) * 4;\r\n\r\n                byteArray[index] = srcData[srcPos + rOffset];\r\n                byteArray[index + 1] = srcData[srcPos + gOffset];\r\n                byteArray[index + 2] = srcData[srcPos + bOffset];\r\n                byteArray[index + 3] = srcData[srcPos + aOffset];\r\n                index += 4;\r\n            }\r\n        }\r\n\r\n        return byteArray;\r\n    }\r\n\r\n    private static _ExtractLongWordOrder(value: number): number {\r\n        if (value === 0 || value === 255 || value === -16777216) {\r\n            return 0;\r\n        }\r\n\r\n        return 1 + DDSTools._ExtractLongWordOrder(value >> 8);\r\n    }\r\n\r\n    private static _GetRGBArrayBuffer(\r\n        width: number,\r\n        height: number,\r\n        dataOffset: number,\r\n        dataLength: number,\r\n        arrayBuffer: ArrayBuffer,\r\n        rOffset: number,\r\n        gOffset: number,\r\n        bOffset: number\r\n    ): Uint8Array {\r\n        const byteArray = new Uint8Array(dataLength);\r\n        const srcData = new Uint8Array(arrayBuffer, dataOffset);\r\n        let index = 0;\r\n        for (let y = 0; y < height; y++) {\r\n            for (let x = 0; x < width; x++) {\r\n                const srcPos = (x + y * width) * 3;\r\n\r\n                byteArray[index] = srcData[srcPos + rOffset];\r\n                byteArray[index + 1] = srcData[srcPos + gOffset];\r\n                byteArray[index + 2] = srcData[srcPos + bOffset];\r\n                index += 3;\r\n            }\r\n        }\r\n\r\n        return byteArray;\r\n    }\r\n\r\n    private static _GetLuminanceArrayBuffer(width: number, height: number, dataOffset: number, dataLength: number, arrayBuffer: ArrayBuffer): Uint8Array {\r\n        const byteArray = new Uint8Array(dataLength);\r\n        const srcData = new Uint8Array(arrayBuffer, dataOffset);\r\n        let index = 0;\r\n        for (let y = 0; y < height; y++) {\r\n            for (let x = 0; x < width; x++) {\r\n                const srcPos = x + y * width;\r\n                byteArray[index] = srcData[srcPos];\r\n                index++;\r\n            }\r\n        }\r\n\r\n        return byteArray;\r\n    }\r\n\r\n    /**\r\n     * Uploads DDS Levels to a Babylon Texture\r\n     * @internal\r\n     */\r\n    public static UploadDDSLevels(\r\n        engine: ThinEngine,\r\n        texture: InternalTexture,\r\n        data: ArrayBufferView,\r\n        info: DDSInfo,\r\n        loadMipmaps: boolean,\r\n        faces: number,\r\n        lodIndex = -1,\r\n        currentFace?: number,\r\n        destTypeMustBeFilterable = true\r\n    ) {\r\n        let sphericalPolynomialFaces: Nullable<Array<ArrayBufferView>> = null;\r\n        if (info.sphericalPolynomial) {\r\n            sphericalPolynomialFaces = [] as ArrayBufferView[];\r\n        }\r\n        const ext = !!engine.getCaps().s3tc;\r\n\r\n        // TODO WEBGPU Once generateMipMaps is split into generateMipMaps + hasMipMaps in InternalTexture this line can be removed\r\n        texture.generateMipMaps = loadMipmaps;\r\n\r\n        const header = new Int32Array(data.buffer, data.byteOffset, headerLengthInt);\r\n        let fourCC: number,\r\n            width: number,\r\n            height: number,\r\n            dataLength: number = 0,\r\n            dataOffset: number;\r\n        let byteArray: Uint8Array, mipmapCount: number, mip: number;\r\n        let internalCompressedFormat = 0;\r\n        let blockBytes = 1;\r\n\r\n        if (header[off_magic] !== DDS_MAGIC) {\r\n            Logger.Error(\"Invalid magic number in DDS header\");\r\n            return;\r\n        }\r\n\r\n        if (!info.isFourCC && !info.isRGB && !info.isLuminance) {\r\n            Logger.Error(\"Unsupported format, must contain a FourCC, RGB or LUMINANCE code\");\r\n            return;\r\n        }\r\n\r\n        if (info.isCompressed && !ext) {\r\n            Logger.Error(\"Compressed textures are not supported on this platform.\");\r\n            return;\r\n        }\r\n\r\n        let bpp = header[off_RGBbpp];\r\n        dataOffset = header[off_size] + 4;\r\n\r\n        let computeFormats = false;\r\n\r\n        if (info.isFourCC) {\r\n            fourCC = header[off_pfFourCC];\r\n            switch (fourCC) {\r\n                case FOURCC_DXT1:\r\n                    blockBytes = 8;\r\n                    internalCompressedFormat = Constants.TEXTUREFORMAT_COMPRESSED_RGBA_S3TC_DXT1;\r\n                    break;\r\n                case FOURCC_DXT3:\r\n                    blockBytes = 16;\r\n                    internalCompressedFormat = Constants.TEXTUREFORMAT_COMPRESSED_RGBA_S3TC_DXT3;\r\n                    break;\r\n                case FOURCC_DXT5:\r\n                    blockBytes = 16;\r\n                    internalCompressedFormat = Constants.TEXTUREFORMAT_COMPRESSED_RGBA_S3TC_DXT5;\r\n                    break;\r\n                case FOURCC_D3DFMT_R16G16B16A16F:\r\n                    computeFormats = true;\r\n                    bpp = 64;\r\n                    break;\r\n                case FOURCC_D3DFMT_R32G32B32A32F:\r\n                    computeFormats = true;\r\n                    bpp = 128;\r\n                    break;\r\n                case FOURCC_DX10: {\r\n                    // There is an additionnal header so dataOffset need to be changed\r\n                    dataOffset += 5 * 4; // 5 uints\r\n\r\n                    let supported = false;\r\n                    switch (info.dxgiFormat) {\r\n                        case DXGI_FORMAT_R16G16B16A16_FLOAT:\r\n                            computeFormats = true;\r\n                            bpp = 64;\r\n                            supported = true;\r\n                            break;\r\n                        case DXGI_FORMAT_R32G32B32A32_FLOAT:\r\n                            computeFormats = true;\r\n                            bpp = 128;\r\n                            supported = true;\r\n                            break;\r\n                        case DXGI_FORMAT_B8G8R8X8_UNORM:\r\n                            info.isRGB = true;\r\n                            info.isFourCC = false;\r\n                            bpp = 32;\r\n                            supported = true;\r\n                            break;\r\n                    }\r\n\r\n                    if (supported) {\r\n                        break;\r\n                    }\r\n                }\r\n                // eslint-disable-next-line no-fallthrough\r\n                default:\r\n                    Logger.Error([\"Unsupported FourCC code:\", Int32ToFourCC(fourCC)]);\r\n                    return;\r\n            }\r\n        }\r\n\r\n        const rOffset = DDSTools._ExtractLongWordOrder(header[off_RMask]);\r\n        const gOffset = DDSTools._ExtractLongWordOrder(header[off_GMask]);\r\n        const bOffset = DDSTools._ExtractLongWordOrder(header[off_BMask]);\r\n        const aOffset = DDSTools._ExtractLongWordOrder(header[off_AMask]);\r\n\r\n        if (computeFormats) {\r\n            internalCompressedFormat = engine._getRGBABufferInternalSizedFormat(info.textureType);\r\n        }\r\n\r\n        mipmapCount = 1;\r\n        if (header[off_flags] & DDSD_MIPMAPCOUNT && loadMipmaps !== false) {\r\n            mipmapCount = Math.max(1, header[off_mipmapCount]);\r\n        }\r\n\r\n        const startFace = currentFace || 0;\r\n        const caps = engine.getCaps();\r\n        for (let face = startFace; face < faces; face++) {\r\n            width = header[off_width];\r\n            height = header[off_height];\r\n\r\n            for (mip = 0; mip < mipmapCount; ++mip) {\r\n                if (lodIndex === -1 || lodIndex === mip) {\r\n                    // In case of fixed LOD, if the lod has just been uploaded, early exit.\r\n                    const i = lodIndex === -1 ? mip : 0;\r\n\r\n                    if (!info.isCompressed && info.isFourCC) {\r\n                        texture.format = Constants.TEXTUREFORMAT_RGBA;\r\n                        dataLength = width * height * 4;\r\n                        let floatArray: Nullable<ArrayBufferView> = null;\r\n\r\n                        if (engine._badOS || engine._badDesktopOS || (!caps.textureHalfFloat && !caps.textureFloat)) {\r\n                            // Required because iOS has many issues with float and half float generation\r\n                            if (bpp === 128) {\r\n                                floatArray = DDSTools._GetFloatAsUIntRGBAArrayBuffer(width, height, data.byteOffset + dataOffset, dataLength, data.buffer, i);\r\n                                if (sphericalPolynomialFaces && i == 0) {\r\n                                    sphericalPolynomialFaces.push(DDSTools._GetFloatRGBAArrayBuffer(width, height, data.byteOffset + dataOffset, dataLength, data.buffer, i));\r\n                                }\r\n                            } else if (bpp === 64) {\r\n                                floatArray = DDSTools._GetHalfFloatAsUIntRGBAArrayBuffer(width, height, data.byteOffset + dataOffset, dataLength, data.buffer, i);\r\n                                if (sphericalPolynomialFaces && i == 0) {\r\n                                    sphericalPolynomialFaces.push(\r\n                                        DDSTools._GetHalfFloatAsFloatRGBAArrayBuffer(width, height, data.byteOffset + dataOffset, dataLength, data.buffer, i)\r\n                                    );\r\n                                }\r\n                            }\r\n\r\n                            texture.type = Constants.TEXTURETYPE_UNSIGNED_INT;\r\n                        } else {\r\n                            const floatAvailable = caps.textureFloat && ((destTypeMustBeFilterable && caps.textureFloatLinearFiltering) || !destTypeMustBeFilterable);\r\n                            const halfFloatAvailable = caps.textureHalfFloat && ((destTypeMustBeFilterable && caps.textureHalfFloatLinearFiltering) || !destTypeMustBeFilterable);\r\n\r\n                            const destType =\r\n                                (bpp === 128 || (bpp === 64 && !halfFloatAvailable)) && floatAvailable\r\n                                    ? Constants.TEXTURETYPE_FLOAT\r\n                                    : (bpp === 64 || (bpp === 128 && !floatAvailable)) && halfFloatAvailable\r\n                                      ? Constants.TEXTURETYPE_HALF_FLOAT\r\n                                      : Constants.TEXTURETYPE_UNSIGNED_BYTE;\r\n\r\n                            let dataGetter: (width: number, height: number, dataOffset: number, dataLength: number, arrayBuffer: ArrayBuffer, lod: number) => ArrayBufferView;\r\n                            let dataGetterPolynomial: Nullable<\r\n                                (width: number, height: number, dataOffset: number, dataLength: number, arrayBuffer: ArrayBuffer, lod: number) => ArrayBufferView\r\n                            > = null;\r\n\r\n                            switch (bpp) {\r\n                                case 128: {\r\n                                    switch (destType) {\r\n                                        case Constants.TEXTURETYPE_FLOAT:\r\n                                            dataGetter = DDSTools._GetFloatRGBAArrayBuffer;\r\n                                            dataGetterPolynomial = null;\r\n                                            break;\r\n                                        case Constants.TEXTURETYPE_HALF_FLOAT:\r\n                                            dataGetter = DDSTools._GetFloatAsHalfFloatRGBAArrayBuffer;\r\n                                            dataGetterPolynomial = DDSTools._GetFloatRGBAArrayBuffer;\r\n                                            break;\r\n                                        case Constants.TEXTURETYPE_UNSIGNED_BYTE:\r\n                                            dataGetter = DDSTools._GetFloatAsUIntRGBAArrayBuffer;\r\n                                            dataGetterPolynomial = DDSTools._GetFloatRGBAArrayBuffer;\r\n                                            break;\r\n                                    }\r\n                                    break;\r\n                                }\r\n                                default: {\r\n                                    // 64 bpp\r\n                                    switch (destType) {\r\n                                        case Constants.TEXTURETYPE_FLOAT:\r\n                                            dataGetter = DDSTools._GetHalfFloatAsFloatRGBAArrayBuffer;\r\n                                            dataGetterPolynomial = null;\r\n                                            break;\r\n                                        case Constants.TEXTURETYPE_HALF_FLOAT:\r\n                                            dataGetter = DDSTools._GetHalfFloatRGBAArrayBuffer;\r\n                                            dataGetterPolynomial = DDSTools._GetHalfFloatAsFloatRGBAArrayBuffer;\r\n                                            break;\r\n                                        case Constants.TEXTURETYPE_UNSIGNED_BYTE:\r\n                                            dataGetter = DDSTools._GetHalfFloatAsUIntRGBAArrayBuffer;\r\n                                            dataGetterPolynomial = DDSTools._GetHalfFloatAsFloatRGBAArrayBuffer;\r\n                                            break;\r\n                                    }\r\n                                    break;\r\n                                }\r\n                            }\r\n\r\n                            texture.type = destType;\r\n\r\n                            floatArray = dataGetter(width, height, data.byteOffset + dataOffset, dataLength, data.buffer, i);\r\n\r\n                            if (sphericalPolynomialFaces && i == 0) {\r\n                                sphericalPolynomialFaces.push(\r\n                                    dataGetterPolynomial ? dataGetterPolynomial(width, height, data.byteOffset + dataOffset, dataLength, data.buffer, i) : floatArray\r\n                                );\r\n                            }\r\n                        }\r\n\r\n                        if (floatArray) {\r\n                            engine._uploadDataToTextureDirectly(texture, floatArray, face, i);\r\n                        }\r\n                    } else if (info.isRGB) {\r\n                        texture.type = Constants.TEXTURETYPE_UNSIGNED_INT;\r\n                        if (bpp === 24) {\r\n                            texture.format = Constants.TEXTUREFORMAT_RGB;\r\n                            dataLength = width * height * 3;\r\n                            byteArray = DDSTools._GetRGBArrayBuffer(width, height, data.byteOffset + dataOffset, dataLength, data.buffer, rOffset, gOffset, bOffset);\r\n                            engine._uploadDataToTextureDirectly(texture, byteArray, face, i);\r\n                        } else {\r\n                            // 32\r\n                            texture.format = Constants.TEXTUREFORMAT_RGBA;\r\n                            dataLength = width * height * 4;\r\n                            byteArray = DDSTools._GetRGBAArrayBuffer(width, height, data.byteOffset + dataOffset, dataLength, data.buffer, rOffset, gOffset, bOffset, aOffset);\r\n                            engine._uploadDataToTextureDirectly(texture, byteArray, face, i);\r\n                        }\r\n                    } else if (info.isLuminance) {\r\n                        const unpackAlignment = engine._getUnpackAlignement();\r\n                        const unpaddedRowSize = width;\r\n                        const paddedRowSize = Math.floor((width + unpackAlignment - 1) / unpackAlignment) * unpackAlignment;\r\n                        dataLength = paddedRowSize * (height - 1) + unpaddedRowSize;\r\n\r\n                        byteArray = DDSTools._GetLuminanceArrayBuffer(width, height, data.byteOffset + dataOffset, dataLength, data.buffer);\r\n                        texture.format = Constants.TEXTUREFORMAT_LUMINANCE;\r\n                        texture.type = Constants.TEXTURETYPE_UNSIGNED_INT;\r\n\r\n                        engine._uploadDataToTextureDirectly(texture, byteArray, face, i);\r\n                    } else {\r\n                        dataLength = (((Math.max(4, width) / 4) * Math.max(4, height)) / 4) * blockBytes;\r\n                        byteArray = new Uint8Array(data.buffer, data.byteOffset + dataOffset, dataLength);\r\n\r\n                        texture.type = Constants.TEXTURETYPE_UNSIGNED_INT;\r\n                        engine._uploadCompressedDataToTextureDirectly(texture, internalCompressedFormat, width, height, byteArray, face, i);\r\n                    }\r\n                }\r\n                dataOffset += bpp ? width * height * (bpp / 8) : dataLength;\r\n                width *= 0.5;\r\n                height *= 0.5;\r\n\r\n                width = Math.max(1.0, width);\r\n                height = Math.max(1.0, height);\r\n            }\r\n\r\n            if (currentFace !== undefined) {\r\n                // Loading a single face\r\n                break;\r\n            }\r\n        }\r\n        if (sphericalPolynomialFaces && sphericalPolynomialFaces.length > 0) {\r\n            info.sphericalPolynomial = CubeMapToSphericalPolynomialTools.ConvertCubeMapToSphericalPolynomial({\r\n                size: header[off_width],\r\n                right: sphericalPolynomialFaces[0],\r\n                left: sphericalPolynomialFaces[1],\r\n                up: sphericalPolynomialFaces[2],\r\n                down: sphericalPolynomialFaces[3],\r\n                front: sphericalPolynomialFaces[4],\r\n                back: sphericalPolynomialFaces[5],\r\n                format: Constants.TEXTUREFORMAT_RGBA,\r\n                type: Constants.TEXTURETYPE_FLOAT,\r\n                gammaSpace: false,\r\n            });\r\n        } else {\r\n            info.sphericalPolynomial = undefined;\r\n        }\r\n    }\r\n}\r\n\r\ndeclare module \"../Engines/thinEngine\" {\r\n    export interface ThinEngine {\r\n        /**\r\n         * Create a cube texture from prefiltered data (ie. the mipmaps contain ready to use data for PBR reflection)\r\n         * @param rootUrl defines the url where the file to load is located\r\n         * @param scene defines the current scene\r\n         * @param lodScale defines scale to apply to the mip map selection\r\n         * @param lodOffset defines offset to apply to the mip map selection\r\n         * @param onLoad defines an optional callback raised when the texture is loaded\r\n         * @param onError defines an optional callback raised if there is an issue to load the texture\r\n         * @param format defines the format of the data\r\n         * @param forcedExtension defines the extension to use to pick the right loader\r\n         * @param createPolynomials defines wheter or not to create polynomails harmonics for the texture\r\n         * @returns the cube texture as an InternalTexture\r\n         */\r\n        createPrefilteredCubeTexture(\r\n            rootUrl: string,\r\n            scene: Nullable<Scene>,\r\n            lodScale: number,\r\n            lodOffset: number,\r\n            onLoad?: Nullable<(internalTexture: Nullable<InternalTexture>) => void>,\r\n            onError?: Nullable<(message?: string, exception?: any) => void>,\r\n            format?: number,\r\n            forcedExtension?: any,\r\n            createPolynomials?: boolean\r\n        ): InternalTexture;\r\n    }\r\n}\r\n\r\n/**\r\n * Create a cube texture from prefiltered data (ie. the mipmaps contain ready to use data for PBR reflection)\r\n * @param rootUrl defines the url where the file to load is located\r\n * @param scene defines the current scene\r\n * @param lodScale defines scale to apply to the mip map selection\r\n * @param lodOffset defines offset to apply to the mip map selection\r\n * @param onLoad defines an optional callback raised when the texture is loaded\r\n * @param onError defines an optional callback raised if there is an issue to load the texture\r\n * @param format defines the format of the data\r\n * @param forcedExtension defines the extension to use to pick the right loader\r\n * @param createPolynomials defines wheter or not to create polynomails harmonics for the texture\r\n * @returns the cube texture as an InternalTexture\r\n */\r\nThinEngine.prototype.createPrefilteredCubeTexture = function (\r\n    rootUrl: string,\r\n    scene: Nullable<Scene>,\r\n    lodScale: number,\r\n    lodOffset: number,\r\n    onLoad: Nullable<(internalTexture: Nullable<InternalTexture>) => void> = null,\r\n    onError: Nullable<(message?: string, exception?: any) => void> = null,\r\n    format?: number,\r\n    forcedExtension: any = null,\r\n    createPolynomials: boolean = true\r\n): InternalTexture {\r\n    const callback = (loadData: any) => {\r\n        if (!loadData) {\r\n            if (onLoad) {\r\n                onLoad(null);\r\n            }\r\n            return;\r\n        }\r\n\r\n        const texture = loadData.texture as InternalTexture;\r\n        if (!createPolynomials) {\r\n            texture._sphericalPolynomial = new SphericalPolynomial();\r\n        } else if (loadData.info.sphericalPolynomial) {\r\n            texture._sphericalPolynomial = loadData.info.sphericalPolynomial;\r\n        }\r\n        texture._source = InternalTextureSource.CubePrefiltered;\r\n\r\n        if (this.getCaps().textureLOD) {\r\n            // Do not add extra process if texture lod is supported.\r\n            if (onLoad) {\r\n                onLoad(texture);\r\n            }\r\n            return;\r\n        }\r\n\r\n        const mipSlices = 3;\r\n\r\n        const gl = this._gl;\r\n        const width = loadData.width;\r\n        if (!width) {\r\n            return;\r\n        }\r\n\r\n        const textures: BaseTexture[] = [];\r\n        for (let i = 0; i < mipSlices; i++) {\r\n            //compute LOD from even spacing in smoothness (matching shader calculation)\r\n            const smoothness = i / (mipSlices - 1);\r\n            const roughness = 1 - smoothness;\r\n\r\n            const minLODIndex = lodOffset; // roughness = 0\r\n            const maxLODIndex = Scalar.Log2(width) * lodScale + lodOffset; // roughness = 1\r\n\r\n            const lodIndex = minLODIndex + (maxLODIndex - minLODIndex) * roughness;\r\n            const mipmapIndex = Math.round(Math.min(Math.max(lodIndex, 0), maxLODIndex));\r\n\r\n            const glTextureFromLod = new InternalTexture(this, InternalTextureSource.Temp);\r\n            glTextureFromLod.type = texture.type;\r\n            glTextureFromLod.format = texture.format;\r\n            glTextureFromLod.width = Math.pow(2, Math.max(Scalar.Log2(width) - mipmapIndex, 0));\r\n            glTextureFromLod.height = glTextureFromLod.width;\r\n            glTextureFromLod.isCube = true;\r\n            glTextureFromLod._cachedWrapU = Constants.TEXTURE_CLAMP_ADDRESSMODE;\r\n            glTextureFromLod._cachedWrapV = Constants.TEXTURE_CLAMP_ADDRESSMODE;\r\n            this._bindTextureDirectly(gl.TEXTURE_CUBE_MAP, glTextureFromLod, true);\r\n\r\n            glTextureFromLod.samplingMode = Constants.TEXTURE_LINEAR_LINEAR;\r\n            gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MAG_FILTER, gl.LINEAR);\r\n            gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MIN_FILTER, gl.LINEAR);\r\n            gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\r\n            gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\r\n\r\n            if (loadData.isDDS) {\r\n                const info: DDSInfo = loadData.info;\r\n                const data: any = loadData.data;\r\n                this._unpackFlipY(info.isCompressed);\r\n\r\n                DDSTools.UploadDDSLevels(this, glTextureFromLod, data, info, true, 6, mipmapIndex);\r\n            } else {\r\n                Logger.Warn(\"DDS is the only prefiltered cube map supported so far.\");\r\n            }\r\n\r\n            this._bindTextureDirectly(gl.TEXTURE_CUBE_MAP, null);\r\n\r\n            // Wrap in a base texture for easy binding.\r\n            const lodTexture = new BaseTexture(scene);\r\n            lodTexture._isCube = true;\r\n            lodTexture._texture = glTextureFromLod;\r\n\r\n            glTextureFromLod.isReady = true;\r\n            textures.push(lodTexture);\r\n        }\r\n\r\n        texture._lodTextureHigh = textures[2];\r\n        texture._lodTextureMid = textures[1];\r\n        texture._lodTextureLow = textures[0];\r\n\r\n        if (onLoad) {\r\n            onLoad(texture);\r\n        }\r\n    };\r\n\r\n    return this.createCubeTexture(rootUrl, scene, null, false, callback, onError, format, forcedExtension, createPolynomials, lodScale, lodOffset);\r\n};\r\n", "import type { Nullable } from \"../../../types\";\r\nimport { SphericalPolynomial } from \"../../../Maths/sphericalPolynomial\";\r\nimport { Engine } from \"../../../Engines/engine\";\r\nimport type { InternalTexture } from \"../../../Materials/Textures/internalTexture\";\r\nimport type { IInternalTextureLoader } from \"../../../Materials/Textures/internalTextureLoader\";\r\nimport type { DDSInfo } from \"../../../Misc/dds\";\r\nimport { DDSTools } from \"../../../Misc/dds\";\r\n\r\n/**\r\n * Implementation of the DDS Texture Loader.\r\n * @internal\r\n */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nexport class _DDSTextureLoader implements IInternalTextureLoader {\r\n    /**\r\n     * Defines whether the loader supports cascade loading the different faces.\r\n     */\r\n    public readonly supportCascades = true;\r\n\r\n    /**\r\n     * This returns if the loader support the current file information.\r\n     * @param extension defines the file extension of the file being loaded\r\n     * @returns true if the loader can load the specified file\r\n     */\r\n    public canLoad(extension: string): boolean {\r\n        return extension.endsWith(\".dds\");\r\n    }\r\n\r\n    /**\r\n     * Uploads the cube texture data to the WebGL texture. It has already been bound.\r\n     * @param imgs contains the cube maps\r\n     * @param texture defines the BabylonJS internal texture\r\n     * @param createPolynomials will be true if polynomials have been requested\r\n     * @param onLoad defines the callback to trigger once the texture is ready\r\n     */\r\n    public loadCubeData(imgs: ArrayBufferView | ArrayBufferView[], texture: InternalTexture, createPolynomials: boolean, onLoad: Nullable<(data?: any) => void>): void {\r\n        const engine = texture.getEngine() as Engine;\r\n        let info: DDSInfo | undefined;\r\n        let loadMipmap: boolean = false;\r\n        let maxLevel: number = 1000;\r\n        if (Array.isArray(imgs)) {\r\n            for (let index = 0; index < imgs.length; index++) {\r\n                const data = imgs[index];\r\n                info = DDSTools.GetDDSInfo(data);\r\n\r\n                texture.width = info.width;\r\n                texture.height = info.height;\r\n\r\n                loadMipmap = (info.isRGB || info.isLuminance || info.mipmapCount > 1) && texture.generateMipMaps;\r\n\r\n                engine._unpackFlipY(info.isCompressed);\r\n\r\n                DDSTools.UploadDDSLevels(engine, texture, data, info, loadMipmap, 6, -1, index);\r\n\r\n                if (!info.isFourCC && info.mipmapCount === 1) {\r\n                    engine.generateMipMapsForCubemap(texture);\r\n                } else {\r\n                    maxLevel = info.mipmapCount - 1;\r\n                }\r\n            }\r\n        } else {\r\n            const data = imgs;\r\n            info = DDSTools.GetDDSInfo(data);\r\n\r\n            texture.width = info.width;\r\n            texture.height = info.height;\r\n\r\n            if (createPolynomials) {\r\n                info.sphericalPolynomial = new SphericalPolynomial();\r\n            }\r\n\r\n            loadMipmap = (info.isRGB || info.isLuminance || info.mipmapCount > 1) && texture.generateMipMaps;\r\n            engine._unpackFlipY(info.isCompressed);\r\n\r\n            DDSTools.UploadDDSLevels(engine, texture, data, info, loadMipmap, 6);\r\n\r\n            if (!info.isFourCC && info.mipmapCount === 1) {\r\n                // Do not unbind as we still need to set the parameters.\r\n                engine.generateMipMapsForCubemap(texture, false);\r\n            } else {\r\n                maxLevel = info.mipmapCount - 1;\r\n            }\r\n        }\r\n        engine._setCubeMapTextureParams(texture, loadMipmap, maxLevel);\r\n        texture.isReady = true;\r\n        texture.onLoadedObservable.notifyObservers(texture);\r\n        texture.onLoadedObservable.clear();\r\n\r\n        if (onLoad) {\r\n            onLoad({ isDDS: true, width: texture.width, info, data: imgs, texture });\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Uploads the 2D texture data to the WebGL texture. It has already been bound once in the callback.\r\n     * @param data contains the texture data\r\n     * @param texture defines the BabylonJS internal texture\r\n     * @param callback defines the method to call once ready to upload\r\n     */\r\n    public loadData(\r\n        data: ArrayBufferView,\r\n        texture: InternalTexture,\r\n        callback: (width: number, height: number, loadMipmap: boolean, isCompressed: boolean, done: () => void) => void\r\n    ): void {\r\n        const info = DDSTools.GetDDSInfo(data);\r\n\r\n        const loadMipmap = (info.isRGB || info.isLuminance || info.mipmapCount > 1) && texture.generateMipMaps && info.width >> (info.mipmapCount - 1) === 1;\r\n        callback(info.width, info.height, loadMipmap, info.isFourCC, () => {\r\n            DDSTools.UploadDDSLevels(texture.getEngine(), texture, data, info, loadMipmap, 1);\r\n        });\r\n    }\r\n}\r\n\r\n// Register the loader.\r\nEngine._TextureLoaders.push(new _DDSTextureLoader());\r\n", "import { GetEnvInfo, UploadEnvLevelsAsync, UploadEnvSpherical } from \"../../../Misc/environmentTextureTools\";\r\nimport type { Nullable } from \"../../../types\";\r\nimport { Engine } from \"../../../Engines/engine\";\r\nimport type { InternalTexture } from \"../../../Materials/Textures/internalTexture\";\r\nimport type { IInternalTextureLoader } from \"../../../Materials/Textures/internalTextureLoader\";\r\n\r\n/**\r\n * Implementation of the ENV Texture Loader.\r\n * @internal\r\n */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nexport class _ENVTextureLoader implements IInternalTextureLoader {\r\n    /**\r\n     * Defines whether the loader supports cascade loading the different faces.\r\n     */\r\n    public readonly supportCascades = false;\r\n\r\n    /**\r\n     * This returns if the loader support the current file information.\r\n     * @param extension defines the file extension of the file being loaded\r\n     * @returns true if the loader can load the specified file\r\n     */\r\n    public canLoad(extension: string): boolean {\r\n        return extension.endsWith(\".env\");\r\n    }\r\n\r\n    /**\r\n     * Uploads the cube texture data to the WebGL texture. It has already been bound.\r\n     * @param data contains the texture data\r\n     * @param texture defines the BabylonJS internal texture\r\n     * @param createPolynomials will be true if polynomials have been requested\r\n     * @param onLoad defines the callback to trigger once the texture is ready\r\n     * @param onError defines the callback to trigger in case of error\r\n     */\r\n    public loadCubeData(\r\n        data: ArrayBufferView | ArrayBufferView[],\r\n        texture: InternalTexture,\r\n        createPolynomials: boolean,\r\n        onLoad: Nullable<(data?: any) => void>,\r\n        onError: Nullable<(message?: string, exception?: any) => void>\r\n    ): void {\r\n        if (Array.isArray(data)) {\r\n            return;\r\n        }\r\n\r\n        const info = GetEnvInfo(data);\r\n        if (info) {\r\n            texture.width = info.width;\r\n            texture.height = info.width;\r\n\r\n            try {\r\n                UploadEnvSpherical(texture, info);\r\n                UploadEnvLevelsAsync(texture, data, info).then(\r\n                    () => {\r\n                        texture.isReady = true;\r\n                        texture.onLoadedObservable.notifyObservers(texture);\r\n                        texture.onLoadedObservable.clear();\r\n                        if (onLoad) {\r\n                            onLoad();\r\n                        }\r\n                    },\r\n                    (reason) => {\r\n                        onError?.(\"Can not upload environment levels\", reason);\r\n                    }\r\n                );\r\n            } catch (e) {\r\n                onError?.(\"Can not upload environment file\", e);\r\n            }\r\n        } else if (onError) {\r\n            onError(\"Can not parse the environment file\", null);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Uploads the 2D texture data to the WebGL texture. It has already been bound once in the callback.\r\n     */\r\n    public loadData(): void {\r\n        // eslint-disable-next-line no-throw-literal\r\n        throw \".env not supported in 2d.\";\r\n    }\r\n}\r\n\r\n// Register the loader.\r\nEngine._TextureLoaders.push(new _ENVTextureLoader());\r\n", "/* eslint-disable @typescript-eslint/naming-convention */\r\nimport { Logger } from \"../Misc/logger\";\r\nimport type { InternalTexture } from \"../Materials/Textures/internalTexture\";\r\n\r\n/**\r\n * for description see https://www.khronos.org/opengles/sdk/tools/KTX/\r\n * for file layout see https://www.khronos.org/opengles/sdk/tools/KTX/file_format_spec/\r\n */\r\nexport class KhronosTextureContainer {\r\n    private static HEADER_LEN = 12 + 13 * 4; // identifier + header elements (not including key value meta-data pairs)\r\n\r\n    // load types\r\n    private static COMPRESSED_2D = 0; // uses a gl.compressedTexImage2D()\r\n    private static COMPRESSED_3D = 1; // uses a gl.compressedTexImage3D()\r\n    private static TEX_2D = 2; // uses a gl.texImage2D()\r\n    private static TEX_3D = 3; // uses a gl.texImage3D()\r\n\r\n    // elements of the header\r\n    /**\r\n     * Gets the openGL type\r\n     */\r\n    public glType: number;\r\n    /**\r\n     * Gets the openGL type size\r\n     */\r\n    public glTypeSize: number;\r\n    /**\r\n     * Gets the openGL format\r\n     */\r\n    public glFormat: number;\r\n    /**\r\n     * Gets the openGL internal format\r\n     */\r\n    public glInternalFormat: number;\r\n    /**\r\n     * Gets the base internal format\r\n     */\r\n    public glBaseInternalFormat: number;\r\n    /**\r\n     * Gets image width in pixel\r\n     */\r\n    public pixelWidth: number;\r\n    /**\r\n     * Gets image height in pixel\r\n     */\r\n    public pixelHeight: number;\r\n    /**\r\n     * Gets image depth in pixels\r\n     */\r\n    public pixelDepth: number;\r\n    /**\r\n     * Gets the number of array elements\r\n     */\r\n    public numberOfArrayElements: number;\r\n    /**\r\n     * Gets the number of faces\r\n     */\r\n    public numberOfFaces: number;\r\n    /**\r\n     * Gets the number of mipmap levels\r\n     */\r\n    public numberOfMipmapLevels: number;\r\n    /**\r\n     * Gets the bytes of key value data\r\n     */\r\n    public bytesOfKeyValueData: number;\r\n    /**\r\n     * Gets the load type\r\n     */\r\n    public loadType: number;\r\n    /**\r\n     * If the container has been made invalid (eg. constructor failed to correctly load array buffer)\r\n     */\r\n    public isInvalid = false;\r\n\r\n    /**\r\n     * Creates a new KhronosTextureContainer\r\n     * @param data contents of the KTX container file\r\n     * @param facesExpected should be either 1 or 6, based whether a cube texture or or\r\n     */\r\n    public constructor(\r\n        /** contents of the KTX container file */\r\n        public data: ArrayBufferView,\r\n        facesExpected: number\r\n    ) {\r\n        if (!KhronosTextureContainer.IsValid(data)) {\r\n            this.isInvalid = true;\r\n            Logger.Error(\"texture missing KTX identifier\");\r\n            return;\r\n        }\r\n\r\n        // load the reset of the header in native 32 bit uint\r\n        const dataSize = Uint32Array.BYTES_PER_ELEMENT;\r\n        const headerDataView = new DataView(this.data.buffer, this.data.byteOffset + 12, 13 * dataSize);\r\n        const endianness = headerDataView.getUint32(0, true);\r\n        const littleEndian = endianness === 0x04030201;\r\n\r\n        this.glType = headerDataView.getUint32(1 * dataSize, littleEndian); // must be 0 for compressed textures\r\n        this.glTypeSize = headerDataView.getUint32(2 * dataSize, littleEndian); // must be 1 for compressed textures\r\n        this.glFormat = headerDataView.getUint32(3 * dataSize, littleEndian); // must be 0 for compressed textures\r\n        this.glInternalFormat = headerDataView.getUint32(4 * dataSize, littleEndian); // the value of arg passed to gl.compressedTexImage2D(,,x,,,,)\r\n        this.glBaseInternalFormat = headerDataView.getUint32(5 * dataSize, littleEndian); // specify GL_RGB, GL_RGBA, GL_ALPHA, etc (un-compressed only)\r\n        this.pixelWidth = headerDataView.getUint32(6 * dataSize, littleEndian); // level 0 value of arg passed to gl.compressedTexImage2D(,,,x,,,)\r\n        this.pixelHeight = headerDataView.getUint32(7 * dataSize, littleEndian); // level 0 value of arg passed to gl.compressedTexImage2D(,,,,x,,)\r\n        this.pixelDepth = headerDataView.getUint32(8 * dataSize, littleEndian); // level 0 value of arg passed to gl.compressedTexImage3D(,,,,,x,,)\r\n        this.numberOfArrayElements = headerDataView.getUint32(9 * dataSize, littleEndian); // used for texture arrays\r\n        this.numberOfFaces = headerDataView.getUint32(10 * dataSize, littleEndian); // used for cubemap textures, should either be 1 or 6\r\n        this.numberOfMipmapLevels = headerDataView.getUint32(11 * dataSize, littleEndian); // number of levels; disregard possibility of 0 for compressed textures\r\n        this.bytesOfKeyValueData = headerDataView.getUint32(12 * dataSize, littleEndian); // the amount of space after the header for meta-data\r\n\r\n        // Make sure we have a compressed type.  Not only reduces work, but probably better to let dev know they are not compressing.\r\n        if (this.glType !== 0) {\r\n            Logger.Error(\"only compressed formats currently supported\");\r\n            this.isInvalid = true;\r\n            return;\r\n        } else {\r\n            // value of zero is an indication to generate mipmaps @ runtime.  Not usually allowed for compressed, so disregard.\r\n            this.numberOfMipmapLevels = Math.max(1, this.numberOfMipmapLevels);\r\n        }\r\n\r\n        if (this.pixelHeight === 0 || this.pixelDepth !== 0) {\r\n            Logger.Error(\"only 2D textures currently supported\");\r\n            this.isInvalid = true;\r\n            return;\r\n        }\r\n\r\n        if (this.numberOfArrayElements !== 0) {\r\n            Logger.Error(\"texture arrays not currently supported\");\r\n            this.isInvalid = true;\r\n            return;\r\n        }\r\n\r\n        if (this.numberOfFaces !== facesExpected) {\r\n            Logger.Error(\"number of faces expected\" + facesExpected + \", but found \" + this.numberOfFaces);\r\n            this.isInvalid = true;\r\n            return;\r\n        }\r\n\r\n        // we now have a completely validated file, so could use existence of loadType as success\r\n        // would need to make this more elaborate & adjust checks above to support more than one load type\r\n        this.loadType = KhronosTextureContainer.COMPRESSED_2D;\r\n    }\r\n\r\n    /**\r\n     * Uploads KTX content to a Babylon Texture.\r\n     * It is assumed that the texture has already been created & is currently bound\r\n     * @internal\r\n     */\r\n    public uploadLevels(texture: InternalTexture, loadMipmaps: boolean): void {\r\n        switch (this.loadType) {\r\n            case KhronosTextureContainer.COMPRESSED_2D:\r\n                this._upload2DCompressedLevels(texture, loadMipmaps);\r\n                break;\r\n\r\n            case KhronosTextureContainer.TEX_2D:\r\n            case KhronosTextureContainer.COMPRESSED_3D:\r\n            case KhronosTextureContainer.TEX_3D:\r\n        }\r\n    }\r\n\r\n    private _upload2DCompressedLevels(texture: InternalTexture, loadMipmaps: boolean): void {\r\n        // initialize width & height for level 1\r\n        let dataOffset = KhronosTextureContainer.HEADER_LEN + this.bytesOfKeyValueData;\r\n        let width = this.pixelWidth;\r\n        let height = this.pixelHeight;\r\n\r\n        const mipmapCount = loadMipmaps ? this.numberOfMipmapLevels : 1;\r\n        for (let level = 0; level < mipmapCount; level++) {\r\n            const imageSize = new Int32Array(this.data.buffer, this.data.byteOffset + dataOffset, 1)[0]; // size per face, since not supporting array cubemaps\r\n            dataOffset += 4; //image data starts from next multiple of 4 offset. Each face refers to same imagesize field above.\r\n            for (let face = 0; face < this.numberOfFaces; face++) {\r\n                const byteArray = new Uint8Array(this.data.buffer, this.data.byteOffset + dataOffset, imageSize);\r\n\r\n                const engine = texture.getEngine();\r\n                engine._uploadCompressedDataToTextureDirectly(texture, texture.format, width, height, byteArray, face, level);\r\n\r\n                dataOffset += imageSize; // add size of the image for the next face/mipmap\r\n                dataOffset += 3 - ((imageSize + 3) % 4); // add padding for odd sized image\r\n            }\r\n            width = Math.max(1.0, width * 0.5);\r\n            height = Math.max(1.0, height * 0.5);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Checks if the given data starts with a KTX file identifier.\r\n     * @param data the data to check\r\n     * @returns true if the data is a KTX file or false otherwise\r\n     */\r\n    public static IsValid(data: ArrayBufferView): boolean {\r\n        if (data.byteLength >= 12) {\r\n            // '', 'K', 'T', 'X', ' ', '1', '1', '', '\\r', '\\n', '\\x1A', '\\n'\r\n            const identifier = new Uint8Array(data.buffer, data.byteOffset, 12);\r\n            if (\r\n                identifier[0] === 0xab &&\r\n                identifier[1] === 0x4b &&\r\n                identifier[2] === 0x54 &&\r\n                identifier[3] === 0x58 &&\r\n                identifier[4] === 0x20 &&\r\n                identifier[5] === 0x31 &&\r\n                identifier[6] === 0x31 &&\r\n                identifier[7] === 0xbb &&\r\n                identifier[8] === 0x0d &&\r\n                identifier[9] === 0x0a &&\r\n                identifier[10] === 0x1a &&\r\n                identifier[11] === 0x0a\r\n            ) {\r\n                return true;\r\n            }\r\n        }\r\n\r\n        return false;\r\n    }\r\n}\r\n", "export enum SourceTextureFormat {\r\n    ETC1S,\r\n    UASTC4x4,\r\n}\r\n\r\nexport enum TranscodeTarget {\r\n    ASTC_4X4_RGBA,\r\n    BC7_RGBA,\r\n    BC3_RGBA,\r\n    BC1_RGB,\r\n    PVRTC1_4_RGBA,\r\n    PVRTC1_4_RGB,\r\n    ETC2_RGBA,\r\n    ETC1_RGB,\r\n    RGBA32,\r\n    R8,\r\n    RG8,\r\n}\r\n\r\nexport enum EngineFormat {\r\n    COMPRESSED_RGBA_BPTC_UNORM_EXT = 0x8e8c,\r\n    COMPRESSED_RGBA_ASTC_4X4_KHR = 0x93b0,\r\n    COMPRESSED_RGB_S3TC_DXT1_EXT = 0x83f0,\r\n    COMPRESSED_RGBA_S3TC_DXT5_EXT = 0x83f3,\r\n    COMPRESSED_RGBA_PVRTC_4BPPV1_IMG = 0x8c02,\r\n    COMPRESSED_RGB_PVRTC_4BPPV1_IMG = 0x8c00,\r\n    COMPRESSED_RGBA8_ETC2_EAC = 0x9278,\r\n    COMPRESSED_RGB8_ETC2 = 0x9274,\r\n    COMPRESSED_RGB_ETC1_WEBGL = 0x8d64,\r\n    RGBA8Format = 0x8058,\r\n    R8Format = 0x8229,\r\n    RG8Format = 0x822b,\r\n}\r\n\r\n/**\r\n * Leaf node of a decision tree\r\n * It defines the transcoding format to use to transcode the texture as well as the corresponding format to use at the engine level when creating the texture\r\n */\r\nexport interface ILeaf {\r\n    /**\r\n     * The format to transcode to\r\n     */\r\n    transcodeFormat: TranscodeTarget;\r\n\r\n    /**\r\n     * The format to use when creating the texture at the engine level after it has been transcoded to transcodeFormat\r\n     */\r\n    engineFormat: EngineFormat;\r\n\r\n    /**\r\n     * Whether the texture must be rounded to a multiple of 4 (should normally be the case for all compressed formats). Default: true\r\n     */\r\n    roundToMultiple4?: boolean;\r\n}\r\n\r\n/**\r\n * Regular node of a decision tree\r\n *\r\n * Each property (except for \"yes\" and \"no\"), if not empty, will be checked in order to determine the next node to select.\r\n * If all checks are successful, the \"yes\" node will be selected, else the \"no\" node will be selected.\r\n */\r\nexport interface INode {\r\n    /**\r\n     * The name of the capability to check. Can be one of the following:\r\n     *      astc\r\n     *      bptc\r\n     *      s3tc\r\n     *      pvrtc\r\n     *      etc2\r\n     *      etc1\r\n     */\r\n    cap?: string;\r\n\r\n    /**\r\n     * The name of the option to check from the options object passed to the KTX2 decode function. {@link IKTX2DecoderOptions}\r\n     */\r\n    option?: string;\r\n\r\n    /**\r\n     * Checks if alpha is present in the texture\r\n     */\r\n    alpha?: boolean;\r\n\r\n    /**\r\n     * Checks the currently selected transcoding format.\r\n     */\r\n    transcodeFormat?: TranscodeTarget | TranscodeTarget[];\r\n\r\n    /**\r\n     * Checks that the texture is a power of two\r\n     */\r\n    needsPowerOfTwo?: boolean;\r\n\r\n    /**\r\n     * The node to select if all checks are successful\r\n     */\r\n    yes?: INode | ILeaf;\r\n\r\n    /**\r\n     * The node to select if at least one check is not successful\r\n     */\r\n    no?: INode | ILeaf;\r\n}\r\n\r\n/**\r\n * Decision tree used to determine the transcoding format to use for a given source texture format\r\n */\r\nexport interface IDecisionTree {\r\n    /**\r\n     * textureFormat can be either UASTC or ETC1S\r\n     */\r\n    [textureFormat: string]: INode;\r\n}\r\n\r\n/**\r\n * Result of the KTX2 decode function\r\n */\r\nexport interface IDecodedData {\r\n    /**\r\n     * Width of the texture\r\n     */\r\n    width: number;\r\n\r\n    /**\r\n     * Height of the texture\r\n     */\r\n    height: number;\r\n\r\n    /**\r\n     * The format to use when creating the texture at the engine level\r\n     * This corresponds to the engineFormat property of the leaf node of the decision tree\r\n     */\r\n    transcodedFormat: number;\r\n\r\n    /**\r\n     * List of mipmap levels.\r\n     * The first element is the base level, the last element is the smallest mipmap level (if more than one mipmap level is present)\r\n     */\r\n    mipmaps: Array<IMipmap>;\r\n\r\n    /**\r\n     * Whether the texture data is in gamma space or not\r\n     */\r\n    isInGammaSpace: boolean;\r\n\r\n    /**\r\n     * Whether the texture has an alpha channel or not\r\n     */\r\n    hasAlpha: boolean;\r\n\r\n    /**\r\n     * The name of the transcoder used to transcode the texture\r\n     */\r\n    transcoderName: string;\r\n\r\n    /**\r\n     * The errors (if any) encountered during the decoding process\r\n     */\r\n    errors?: string;\r\n}\r\n\r\n/**\r\n * Defines a mipmap level\r\n */\r\nexport interface IMipmap {\r\n    /**\r\n     * The data of the mipmap level\r\n     */\r\n    data: Uint8Array | null;\r\n\r\n    /**\r\n     * The width of the mipmap level\r\n     */\r\n    width: number;\r\n\r\n    /**\r\n     * The height of the mipmap level\r\n     */\r\n    height: number;\r\n}\r\n\r\n/**\r\n * The compressed texture formats supported by the browser\r\n */\r\nexport interface ICompressedFormatCapabilities {\r\n    /**\r\n     * Whether the browser supports ASTC\r\n     */\r\n    astc?: boolean;\r\n\r\n    /**\r\n     * Whether the browser supports BPTC\r\n     */\r\n    bptc?: boolean;\r\n\r\n    /**\r\n     * Whether the browser supports S3TC\r\n     */\r\n    s3tc?: boolean;\r\n\r\n    /**\r\n     * Whether the browser supports PVRTC\r\n     */\r\n    pvrtc?: boolean;\r\n\r\n    /**\r\n     * Whether the browser supports ETC2\r\n     */\r\n    etc2?: boolean;\r\n\r\n    /**\r\n     * Whether the browser supports ETC1\r\n     */\r\n    etc1?: boolean;\r\n}\r\n\r\n/**\r\n * Options passed to the KTX2 decode function\r\n */\r\nexport interface IKTX2DecoderOptions {\r\n    /** use RGBA format if ASTC and BC7 are not available as transcoded format */\r\n    useRGBAIfASTCBC7NotAvailableWhenUASTC?: boolean;\r\n\r\n    /** force to always use (uncompressed) RGBA for transcoded format */\r\n    forceRGBA?: boolean;\r\n\r\n    /** force to always use (uncompressed) R8 for transcoded format */\r\n    forceR8?: boolean;\r\n\r\n    /** force to always use (uncompressed) RG8 for transcoded format */\r\n    forceRG8?: boolean;\r\n\r\n    /**\r\n     * list of transcoders to bypass when looking for a suitable transcoder. The available transcoders are:\r\n     *      UniversalTranscoder_UASTC_ASTC\r\n     *      UniversalTranscoder_UASTC_BC7\r\n     *      UniversalTranscoder_UASTC_RGBA_UNORM\r\n     *      UniversalTranscoder_UASTC_RGBA_SRGB\r\n     *      UniversalTranscoder_UASTC_R8_UNORM\r\n     *      UniversalTranscoder_UASTC_RG8_UNORM\r\n     *      MSCTranscoder\r\n     */\r\n    bypassTranscoders?: string[];\r\n\r\n    /**\r\n     * Custom decision tree to apply after the default decision tree has selected a transcoding format.\r\n     * Allows the user to override the default decision tree selection.\r\n     * The decision tree can use the INode.transcodeFormat property to base its decision on the transcoding format selected by the default decision tree.\r\n     */\r\n    transcodeFormatDecisionTree?: IDecisionTree;\r\n}\r\n", "import type { IDecodedData } from \"core/Materials/Textures/ktx2decoderTypes\";\r\n\r\n/* eslint-disable @typescript-eslint/naming-convention */\r\nexport type AllowedKeys =\r\n    | \"wasmUASTCToASTC\"\r\n    | \"wasmUASTCToBC7\"\r\n    | \"wasmUASTCToRGBA_UNORM\"\r\n    | \"wasmUASTCToRGBA_SRGB\"\r\n    | \"wasmUASTCToR8_UNORM\"\r\n    | \"wasmUASTCToRG8_UNORM\"\r\n    | \"wasmMSCTranscoder\"\r\n    | \"wasmZSTDDecoder\"\r\n    | \"jsDecoderModule\"\r\n    | \"jsMSCTranscoder\";\r\n\r\ndeclare function importScripts(...urls: string[]): void;\r\ndeclare function postMessage(message: any, transfer?: any[]): void;\r\ndeclare let KTX2DECODER: any;\r\n\r\nexport function applyConfig(urls?: { [key in AllowedKeys]: string }, binariesAndModulesContainer?: { [key in AllowedKeys]: ArrayBuffer | any }): void {\r\n    const KTX2DecoderModule = binariesAndModulesContainer?.jsDecoderModule || KTX2DECODER;\r\n    if (urls) {\r\n        if (urls.wasmUASTCToASTC) {\r\n            KTX2DecoderModule.LiteTranscoder_UASTC_ASTC.WasmModuleURL = urls.wasmUASTCToASTC;\r\n        }\r\n\r\n        if (urls.wasmUASTCToBC7) {\r\n            KTX2DecoderModule.LiteTranscoder_UASTC_BC7.WasmModuleURL = urls.wasmUASTCToBC7;\r\n        }\r\n\r\n        if (urls.wasmUASTCToRGBA_UNORM) {\r\n            KTX2DecoderModule.LiteTranscoder_UASTC_RGBA_UNORM.WasmModuleURL = urls.wasmUASTCToRGBA_UNORM;\r\n        }\r\n\r\n        if (urls.wasmUASTCToRGBA_SRGB) {\r\n            KTX2DecoderModule.LiteTranscoder_UASTC_RGBA_SRGB.WasmModuleURL = urls.wasmUASTCToRGBA_SRGB;\r\n        }\r\n\r\n        if (urls.wasmUASTCToR8_UNORM) {\r\n            KTX2DecoderModule.LiteTranscoder_UASTC_R8_UNORM.WasmModuleURL = urls.wasmUASTCToR8_UNORM;\r\n        }\r\n\r\n        if (urls.wasmUASTCToRG8_UNORM) {\r\n            KTX2DecoderModule.LiteTranscoder_UASTC_RG8_UNORM.WasmModuleURL = urls.wasmUASTCToRG8_UNORM;\r\n        }\r\n\r\n        if (urls.jsMSCTranscoder) {\r\n            KTX2DecoderModule.MSCTranscoder.JSModuleURL = urls.jsMSCTranscoder;\r\n        }\r\n\r\n        if (urls.wasmMSCTranscoder) {\r\n            KTX2DecoderModule.MSCTranscoder.WasmModuleURL = urls.wasmMSCTranscoder;\r\n        }\r\n\r\n        if (urls.wasmZSTDDecoder) {\r\n            KTX2DecoderModule.ZSTDDecoder.WasmModuleURL = urls.wasmZSTDDecoder;\r\n        }\r\n    }\r\n    if (binariesAndModulesContainer) {\r\n        if (binariesAndModulesContainer.wasmUASTCToASTC) {\r\n            KTX2DecoderModule.LiteTranscoder_UASTC_ASTC.WasmBinary = binariesAndModulesContainer.wasmUASTCToASTC;\r\n        }\r\n        if (binariesAndModulesContainer.wasmUASTCToBC7) {\r\n            KTX2DecoderModule.LiteTranscoder_UASTC_BC7.WasmBinary = binariesAndModulesContainer.wasmUASTCToBC7;\r\n        }\r\n        if (binariesAndModulesContainer.wasmUASTCToRGBA_UNORM) {\r\n            KTX2DecoderModule.LiteTranscoder_UASTC_RGBA_UNORM.WasmBinary = binariesAndModulesContainer.wasmUASTCToRGBA_UNORM;\r\n        }\r\n        if (binariesAndModulesContainer.wasmUASTCToRGBA_SRGB) {\r\n            KTX2DecoderModule.LiteTranscoder_UASTC_RGBA_SRGB.WasmBinary = binariesAndModulesContainer.wasmUASTCToRGBA_SRGB;\r\n        }\r\n        if (binariesAndModulesContainer.wasmUASTCToR8_UNORM) {\r\n            KTX2DecoderModule.LiteTranscoder_UASTC_R8_UNORM.WasmBinary = binariesAndModulesContainer.wasmUASTCToR8_UNORM;\r\n        }\r\n        if (binariesAndModulesContainer.wasmUASTCToRG8_UNORM) {\r\n            KTX2DecoderModule.LiteTranscoder_UASTC_RG8_UNORM.WasmBinary = binariesAndModulesContainer.wasmUASTCToRG8_UNORM;\r\n        }\r\n        if (binariesAndModulesContainer.jsMSCTranscoder) {\r\n            KTX2DecoderModule.MSCTranscoder.JSModule = binariesAndModulesContainer.jsMSCTranscoder;\r\n        }\r\n        if (binariesAndModulesContainer.wasmMSCTranscoder) {\r\n            KTX2DecoderModule.MSCTranscoder.WasmBinary = binariesAndModulesContainer.wasmMSCTranscoder;\r\n        }\r\n        if (binariesAndModulesContainer.wasmZSTDDecoder) {\r\n            KTX2DecoderModule.ZSTDDecoder.WasmBinary = binariesAndModulesContainer.wasmZSTDDecoder;\r\n        }\r\n    }\r\n}\r\n\r\nexport function workerFunction(KTX2DecoderModule: any): void {\r\n    if (typeof KTX2DecoderModule === \"undefined\" && typeof KTX2DECODER !== \"undefined\") {\r\n        KTX2DecoderModule = KTX2DECODER;\r\n    }\r\n    let ktx2Decoder: any;\r\n\r\n    onmessage = (event) => {\r\n        if (!event.data) {\r\n            return;\r\n        }\r\n        switch (event.data.action) {\r\n            case \"init\": {\r\n                const urls = event.data.urls;\r\n                if (urls) {\r\n                    if (urls.jsDecoderModule && typeof KTX2DecoderModule === \"undefined\") {\r\n                        importScripts(urls.jsDecoderModule);\r\n                        // assuming global namespace populated by the script (UMD pattern)\r\n                        KTX2DecoderModule = KTX2DECODER;\r\n                    }\r\n                    applyConfig(urls);\r\n                }\r\n                if (event.data.wasmBinaries) {\r\n                    applyConfig(undefined, { ...event.data.wasmBinaries, jsDecoderModule: KTX2DecoderModule });\r\n                }\r\n                ktx2Decoder = new KTX2DecoderModule.KTX2Decoder();\r\n                postMessage({ action: \"init\" });\r\n                break;\r\n            }\r\n            case \"setDefaultDecoderOptions\": {\r\n                KTX2DecoderModule.KTX2Decoder.DefaultDecoderOptions = event.data.options;\r\n                break;\r\n            }\r\n            case \"decode\":\r\n                ktx2Decoder\r\n                    .decode(event.data.data, event.data.caps, event.data.options)\r\n                    .then((data: IDecodedData) => {\r\n                        const buffers = [];\r\n                        for (let mip = 0; mip < data.mipmaps.length; ++mip) {\r\n                            const mipmap = data.mipmaps[mip];\r\n                            if (mipmap && mipmap.data) {\r\n                                buffers.push(mipmap.data.buffer);\r\n                            }\r\n                        }\r\n                        postMessage({ action: \"decoded\", success: true, decodedData: data }, buffers);\r\n                    })\r\n                    .catch((reason: any) => {\r\n                        postMessage({ action: \"decoded\", success: false, msg: reason });\r\n                    });\r\n                break;\r\n        }\r\n    };\r\n}\r\n\r\nexport function initializeWebWorker(worker: Worker, wasmBinaries?: { [key in AllowedKeys]?: ArrayBuffer }, urls?: { [key in AllowedKeys]: string }): Promise<Worker> {\r\n    return new Promise((resolve, reject) => {\r\n        const onError = (error: ErrorEvent) => {\r\n            worker.removeEventListener(\"error\", onError);\r\n            worker.removeEventListener(\"message\", onMessage);\r\n            reject(error);\r\n        };\r\n\r\n        const onMessage = (message: MessageEvent) => {\r\n            if (message.data.action === \"init\") {\r\n                worker.removeEventListener(\"error\", onError);\r\n                worker.removeEventListener(\"message\", onMessage);\r\n                resolve(worker);\r\n            }\r\n        };\r\n\r\n        worker.addEventListener(\"error\", onError);\r\n        worker.addEventListener(\"message\", onMessage);\r\n\r\n        worker.postMessage({\r\n            action: \"init\",\r\n            urls,\r\n            wasmBinaries,\r\n        });\r\n    });\r\n}\r\n", "/* eslint-disable @typescript-eslint/naming-convention */\r\nimport type { InternalTexture } from \"../Materials/Textures/internalTexture\";\r\nimport type { ThinEngine } from \"../Engines/thinEngine\";\r\nimport { Constants } from \"../Engines/constants\";\r\nimport { AutoReleaseWorkerPool } from \"./workerPool\";\r\nimport { Tools } from \"./tools\";\r\nimport type { Nullable } from \"../types\";\r\nimport type { ICompressedFormatCapabilities, IDecodedData, IKTX2DecoderOptions } from \"core/Materials/Textures/ktx2decoderTypes\";\r\nimport { EngineFormat, TranscodeTarget } from \"core/Materials/Textures/ktx2decoderTypes\";\r\nimport type { AllowedKeys } from \"./khronosTextureContainer2Worker\";\r\nimport { applyConfig, initializeWebWorker, workerFunction } from \"./khronosTextureContainer2Worker\";\r\n\r\ndeclare let KTX2DECODER: any;\r\n\r\n/**\r\n * Class that defines the default KTX2 decoder options.\r\n *\r\n * This class is useful for providing options to the KTX2 decoder to control how the source data is transcoded.\r\n */\r\nexport class DefaultKTX2DecoderOptions {\r\n    private _isDirty = true;\r\n\r\n    /**\r\n     * Gets the dirty flag\r\n     */\r\n    public get isDirty() {\r\n        return this._isDirty;\r\n    }\r\n\r\n    private _useRGBAIfASTCBC7NotAvailableWhenUASTC?: boolean;\r\n    /**\r\n     * force a (uncompressed) RGBA transcoded format if transcoding a UASTC source format and ASTC + BC7 are not available as a compressed transcoded format\r\n     */\r\n    public get useRGBAIfASTCBC7NotAvailableWhenUASTC() {\r\n        return this._useRGBAIfASTCBC7NotAvailableWhenUASTC;\r\n    }\r\n\r\n    public set useRGBAIfASTCBC7NotAvailableWhenUASTC(value: boolean | undefined) {\r\n        if (this._useRGBAIfASTCBC7NotAvailableWhenUASTC === value) {\r\n            return;\r\n        }\r\n        this._useRGBAIfASTCBC7NotAvailableWhenUASTC = value;\r\n        this._isDirty = true;\r\n    }\r\n\r\n    private _useRGBAIfOnlyBC1BC3AvailableWhenUASTC?: boolean = true;\r\n    /**\r\n     * force a (uncompressed) RGBA transcoded format if transcoding a UASTC source format and only BC1 or BC3 are available as a compressed transcoded format.\r\n     * This property is true by default to favor speed over memory, because currently transcoding from UASTC to BC1/3 is slow because the transcoder transcodes\r\n     * to uncompressed and then recompresses the texture\r\n     */\r\n    public get useRGBAIfOnlyBC1BC3AvailableWhenUASTC() {\r\n        return this._useRGBAIfOnlyBC1BC3AvailableWhenUASTC;\r\n    }\r\n\r\n    public set useRGBAIfOnlyBC1BC3AvailableWhenUASTC(value: boolean | undefined) {\r\n        if (this._useRGBAIfOnlyBC1BC3AvailableWhenUASTC === value) {\r\n            return;\r\n        }\r\n        this._useRGBAIfOnlyBC1BC3AvailableWhenUASTC = value;\r\n        this._isDirty = true;\r\n    }\r\n\r\n    private _forceRGBA?: boolean;\r\n    /**\r\n     * force to always use (uncompressed) RGBA for transcoded format\r\n     */\r\n    public get forceRGBA() {\r\n        return this._forceRGBA;\r\n    }\r\n\r\n    public set forceRGBA(value: boolean | undefined) {\r\n        if (this._forceRGBA === value) {\r\n            return;\r\n        }\r\n        this._forceRGBA = value;\r\n        this._isDirty = true;\r\n    }\r\n\r\n    private _forceR8?: boolean;\r\n    /**\r\n     * force to always use (uncompressed) R8 for transcoded format\r\n     */\r\n    public get forceR8() {\r\n        return this._forceR8;\r\n    }\r\n\r\n    public set forceR8(value: boolean | undefined) {\r\n        if (this._forceR8 === value) {\r\n            return;\r\n        }\r\n        this._forceR8 = value;\r\n        this._isDirty = true;\r\n    }\r\n\r\n    private _forceRG8?: boolean;\r\n    /**\r\n     * force to always use (uncompressed) RG8 for transcoded format\r\n     */\r\n    public get forceRG8() {\r\n        return this._forceRG8;\r\n    }\r\n\r\n    public set forceRG8(value: boolean | undefined) {\r\n        if (this._forceRG8 === value) {\r\n            return;\r\n        }\r\n        this._forceRG8 = value;\r\n        this._isDirty = true;\r\n    }\r\n\r\n    private _bypassTranscoders?: string[];\r\n    /**\r\n     * list of transcoders to bypass when looking for a suitable transcoder. The available transcoders are:\r\n     *      UniversalTranscoder_UASTC_ASTC\r\n     *      UniversalTranscoder_UASTC_BC7\r\n     *      UniversalTranscoder_UASTC_RGBA_UNORM\r\n     *      UniversalTranscoder_UASTC_RGBA_SRGB\r\n     *      UniversalTranscoder_UASTC_R8_UNORM\r\n     *      UniversalTranscoder_UASTC_RG8_UNORM\r\n     *      MSCTranscoder\r\n     */\r\n    public get bypassTranscoders() {\r\n        return this._bypassTranscoders;\r\n    }\r\n\r\n    public set bypassTranscoders(value: string[] | undefined) {\r\n        if (this._bypassTranscoders === value) {\r\n            return;\r\n        }\r\n        this._bypassTranscoders = value;\r\n        this._isDirty = true;\r\n    }\r\n\r\n    private _ktx2DecoderOptions: IKTX2DecoderOptions = {};\r\n\r\n    /** @internal */\r\n    public _getKTX2DecoderOptions(): IKTX2DecoderOptions {\r\n        if (!this._isDirty) {\r\n            return this._ktx2DecoderOptions;\r\n        }\r\n\r\n        this._isDirty = false;\r\n\r\n        const options: IKTX2DecoderOptions = {\r\n            useRGBAIfASTCBC7NotAvailableWhenUASTC: this._useRGBAIfASTCBC7NotAvailableWhenUASTC,\r\n            forceRGBA: this._forceRGBA,\r\n            forceR8: this._forceR8,\r\n            forceRG8: this._forceRG8,\r\n            bypassTranscoders: this._bypassTranscoders,\r\n        };\r\n\r\n        if (this.useRGBAIfOnlyBC1BC3AvailableWhenUASTC) {\r\n            options.transcodeFormatDecisionTree = {\r\n                UASTC: {\r\n                    transcodeFormat: [TranscodeTarget.BC1_RGB, TranscodeTarget.BC3_RGBA],\r\n                    yes: {\r\n                        transcodeFormat: TranscodeTarget.RGBA32,\r\n                        engineFormat: EngineFormat.RGBA8Format,\r\n                        roundToMultiple4: false,\r\n                    },\r\n                },\r\n            };\r\n        }\r\n\r\n        this._ktx2DecoderOptions = options;\r\n\r\n        return options;\r\n    }\r\n}\r\n\r\n/**\r\n * Options for the KTX2 decoder\r\n */\r\nexport interface IKhronosTextureContainer2Options {\r\n    /**\r\n     * Number of workers to use for async operations. Specify `0` to disable web workers and run synchronously in the current context.\r\n     */\r\n    numWorkers?: number;\r\n    /**\r\n     * Worker pool to use for async operations. If set, `numWorkers` will be ignored.\r\n     */\r\n    workerPool?: AutoReleaseWorkerPool;\r\n    /**\r\n     * Optional container for the KTX2 decoder module and its dependencies. If set, the module will be used from this container and the URLs will be ignored.\r\n     */\r\n    binariesAndModulesContainer?: { [key in AllowedKeys]?: ArrayBuffer | any };\r\n}\r\n\r\n/**\r\n * Class for loading KTX2 files\r\n */\r\nexport class KhronosTextureContainer2 {\r\n    private static _WorkerPoolPromise?: Promise<AutoReleaseWorkerPool>;\r\n    private static _DecoderModulePromise?: Promise<any>;\r\n    private static _KTX2DecoderModule?: any;\r\n\r\n    /**\r\n     * URLs to use when loading the KTX2 decoder module as well as its dependencies\r\n     * If a url is null, the default url is used (pointing to https://preview.babylonjs.com)\r\n     * Note that jsDecoderModule can't be null and that the other dependencies will only be loaded if necessary\r\n     * Urls you can change:\r\n     *     URLConfig.jsDecoderModule\r\n     *     URLConfig.wasmUASTCToASTC\r\n     *     URLConfig.wasmUASTCToBC7\r\n     *     URLConfig.wasmUASTCToRGBA_UNORM\r\n     *     URLConfig.wasmUASTCToRGBA_SRGB\r\n     *     URLConfig.wasmUASTCToR8_UNORM\r\n     *     URLConfig.wasmUASTCToRG8_UNORM\r\n     *     URLConfig.jsMSCTranscoder\r\n     *     URLConfig.wasmMSCTranscoder\r\n     *     URLConfig.wasmZSTDDecoder\r\n     * You can see their default values in this PG: https://playground.babylonjs.com/#EIJH8L#29\r\n     */\r\n    public static URLConfig: {\r\n        jsDecoderModule: string;\r\n        wasmUASTCToASTC: Nullable<string>;\r\n        wasmUASTCToBC7: Nullable<string>;\r\n        wasmUASTCToRGBA_UNORM: Nullable<string>;\r\n        wasmUASTCToRGBA_SRGB: Nullable<string>;\r\n        wasmUASTCToR8_UNORM: Nullable<string>;\r\n        wasmUASTCToRG8_UNORM: Nullable<string>;\r\n        jsMSCTranscoder: Nullable<string>;\r\n        wasmMSCTranscoder: Nullable<string>;\r\n        wasmZSTDDecoder: Nullable<string>;\r\n    } = {\r\n        jsDecoderModule: \"https://cdn.babylonjs.com/babylon.ktx2Decoder.js\",\r\n        wasmUASTCToASTC: null,\r\n        wasmUASTCToBC7: null,\r\n        wasmUASTCToRGBA_UNORM: null,\r\n        wasmUASTCToRGBA_SRGB: null,\r\n        wasmUASTCToR8_UNORM: null,\r\n        wasmUASTCToRG8_UNORM: null,\r\n        jsMSCTranscoder: null,\r\n        wasmMSCTranscoder: null,\r\n        wasmZSTDDecoder: null,\r\n    };\r\n\r\n    /**\r\n     * Default number of workers used to handle data decoding\r\n     */\r\n    public static DefaultNumWorkers = KhronosTextureContainer2.GetDefaultNumWorkers();\r\n\r\n    /**\r\n     * Default configuration for the KTX2 decoder.\r\n     * The options defined in this way have priority over those passed when creating a KTX2 texture with new Texture(...).\r\n     */\r\n    public static DefaultDecoderOptions = new DefaultKTX2DecoderOptions();\r\n\r\n    private static GetDefaultNumWorkers(): number {\r\n        if (typeof navigator !== \"object\" || !navigator.hardwareConcurrency) {\r\n            return 1;\r\n        }\r\n\r\n        // Use 50% of the available logical processors but capped at 4.\r\n        return Math.min(Math.floor(navigator.hardwareConcurrency * 0.5), 4);\r\n    }\r\n\r\n    private _engine: ThinEngine;\r\n\r\n    private static _Initialize(numWorkers: number): void {\r\n        if (KhronosTextureContainer2._WorkerPoolPromise || KhronosTextureContainer2._DecoderModulePromise) {\r\n            return;\r\n        }\r\n\r\n        const urls = {\r\n            jsDecoderModule: Tools.GetBabylonScriptURL(this.URLConfig.jsDecoderModule, true),\r\n            wasmUASTCToASTC: Tools.GetBabylonScriptURL(this.URLConfig.wasmUASTCToASTC, true),\r\n            wasmUASTCToBC7: Tools.GetBabylonScriptURL(this.URLConfig.wasmUASTCToBC7, true),\r\n            wasmUASTCToRGBA_UNORM: Tools.GetBabylonScriptURL(this.URLConfig.wasmUASTCToRGBA_UNORM, true),\r\n            wasmUASTCToRGBA_SRGB: Tools.GetBabylonScriptURL(this.URLConfig.wasmUASTCToRGBA_SRGB, true),\r\n            wasmUASTCToR8_UNORM: Tools.GetBabylonScriptURL(this.URLConfig.wasmUASTCToR8_UNORM, true),\r\n            wasmUASTCToRG8_UNORM: Tools.GetBabylonScriptURL(this.URLConfig.wasmUASTCToRG8_UNORM, true),\r\n            jsMSCTranscoder: Tools.GetBabylonScriptURL(this.URLConfig.jsMSCTranscoder, true),\r\n            wasmMSCTranscoder: Tools.GetBabylonScriptURL(this.URLConfig.wasmMSCTranscoder, true),\r\n            wasmZSTDDecoder: Tools.GetBabylonScriptURL(this.URLConfig.wasmZSTDDecoder, true),\r\n        };\r\n\r\n        if (numWorkers && typeof Worker === \"function\" && typeof URL !== \"undefined\") {\r\n            KhronosTextureContainer2._WorkerPoolPromise = new Promise((resolve) => {\r\n                const workerContent = `${applyConfig}(${workerFunction})()`;\r\n                const workerBlobUrl = URL.createObjectURL(new Blob([workerContent], { type: \"application/javascript\" }));\r\n                resolve(new AutoReleaseWorkerPool(numWorkers, () => initializeWebWorker(new Worker(workerBlobUrl), undefined, urls)));\r\n            });\r\n        } else {\r\n            if (typeof KhronosTextureContainer2._KTX2DecoderModule === \"undefined\") {\r\n                KhronosTextureContainer2._DecoderModulePromise = Tools.LoadBabylonScriptAsync(urls.jsDecoderModule).then(() => {\r\n                    KhronosTextureContainer2._KTX2DecoderModule = KTX2DECODER;\r\n                    KhronosTextureContainer2._KTX2DecoderModule.MSCTranscoder.UseFromWorkerThread = false;\r\n                    KhronosTextureContainer2._KTX2DecoderModule.WASMMemoryManager.LoadBinariesFromCurrentThread = true;\r\n                    applyConfig(urls, KhronosTextureContainer2._KTX2DecoderModule);\r\n                    return new KhronosTextureContainer2._KTX2DecoderModule.KTX2Decoder();\r\n                });\r\n            } else {\r\n                KhronosTextureContainer2._KTX2DecoderModule.MSCTranscoder.UseFromWorkerThread = false;\r\n                KhronosTextureContainer2._KTX2DecoderModule.WASMMemoryManager.LoadBinariesFromCurrentThread = true;\r\n                KhronosTextureContainer2._DecoderModulePromise = Promise.resolve(new KhronosTextureContainer2._KTX2DecoderModule.KTX2Decoder());\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Constructor\r\n     * @param engine The engine to use\r\n     * @param numWorkersOrOptions The number of workers for async operations. Specify `0` to disable web workers and run synchronously in the current context.\r\n     */\r\n    public constructor(engine: ThinEngine, numWorkersOrOptions: number | IKhronosTextureContainer2Options = KhronosTextureContainer2.DefaultNumWorkers) {\r\n        this._engine = engine;\r\n        if (typeof numWorkersOrOptions === \"object\" && numWorkersOrOptions.workerPool) {\r\n            KhronosTextureContainer2._WorkerPoolPromise = Promise.resolve(numWorkersOrOptions.workerPool);\r\n        } else {\r\n            // set the KTX2 decoder module\r\n            if (typeof numWorkersOrOptions === \"object\") {\r\n                KhronosTextureContainer2._KTX2DecoderModule = numWorkersOrOptions?.binariesAndModulesContainer?.jsDecoderModule;\r\n            } else if (typeof KTX2DECODER !== \"undefined\") {\r\n                KhronosTextureContainer2._KTX2DecoderModule = KTX2DECODER;\r\n            }\r\n            const numberOfWorkers = typeof numWorkersOrOptions === \"number\" ? numWorkersOrOptions : numWorkersOrOptions.numWorkers ?? KhronosTextureContainer2.DefaultNumWorkers;\r\n            KhronosTextureContainer2._Initialize(numberOfWorkers);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _uploadAsync(data: ArrayBufferView, internalTexture: InternalTexture, options?: IKTX2DecoderOptions & IDecodedData): Promise<void> {\r\n        const caps = this._engine.getCaps();\r\n\r\n        const compressedTexturesCaps: ICompressedFormatCapabilities = {\r\n            astc: !!caps.astc,\r\n            bptc: !!caps.bptc,\r\n            s3tc: !!caps.s3tc,\r\n            pvrtc: !!caps.pvrtc,\r\n            etc2: !!caps.etc2,\r\n            etc1: !!caps.etc1,\r\n        };\r\n\r\n        if (KhronosTextureContainer2._WorkerPoolPromise) {\r\n            return KhronosTextureContainer2._WorkerPoolPromise.then((workerPool) => {\r\n                return new Promise((resolve, reject) => {\r\n                    workerPool.push((worker, onComplete) => {\r\n                        const onError = (error: ErrorEvent) => {\r\n                            worker.removeEventListener(\"error\", onError);\r\n                            worker.removeEventListener(\"message\", onMessage);\r\n                            reject(error);\r\n                            onComplete();\r\n                        };\r\n\r\n                        const onMessage = (message: MessageEvent) => {\r\n                            if (message.data.action === \"decoded\") {\r\n                                worker.removeEventListener(\"error\", onError);\r\n                                worker.removeEventListener(\"message\", onMessage);\r\n                                if (!message.data.success) {\r\n                                    reject({ message: message.data.msg });\r\n                                } else {\r\n                                    try {\r\n                                        this._createTexture(message.data.decodedData, internalTexture, options);\r\n                                        resolve();\r\n                                    } catch (err) {\r\n                                        reject({ message: err });\r\n                                    }\r\n                                }\r\n                                onComplete();\r\n                            }\r\n                        };\r\n\r\n                        worker.addEventListener(\"error\", onError);\r\n                        worker.addEventListener(\"message\", onMessage);\r\n                        worker.postMessage({ action: \"setDefaultDecoderOptions\", options: KhronosTextureContainer2.DefaultDecoderOptions._getKTX2DecoderOptions() });\r\n\r\n                        const dataCopy = new Uint8Array(data.byteLength);\r\n                        dataCopy.set(new Uint8Array(data.buffer, data.byteOffset, data.byteLength));\r\n\r\n                        worker.postMessage({ action: \"decode\", data: dataCopy, caps: compressedTexturesCaps, options }, [dataCopy.buffer]);\r\n                    });\r\n                });\r\n            });\r\n        } else if (KhronosTextureContainer2._DecoderModulePromise) {\r\n            return KhronosTextureContainer2._DecoderModulePromise.then((decoder) => {\r\n                if (KhronosTextureContainer2.DefaultDecoderOptions.isDirty) {\r\n                    KhronosTextureContainer2._KTX2DecoderModule.KTX2Decoder.DefaultDecoderOptions = KhronosTextureContainer2.DefaultDecoderOptions._getKTX2DecoderOptions();\r\n                }\r\n                return new Promise((resolve, reject) => {\r\n                    decoder\r\n                        .decode(data, caps)\r\n                        .then((data: IDecodedData) => {\r\n                            this._createTexture(data, internalTexture);\r\n                            resolve();\r\n                        })\r\n                        .catch((reason: any) => {\r\n                            reject({ message: reason });\r\n                        });\r\n                });\r\n            });\r\n        }\r\n\r\n        throw new Error(\"KTX2 decoder module is not available\");\r\n    }\r\n\r\n    protected _createTexture(data: IDecodedData, internalTexture: InternalTexture, options?: IKTX2DecoderOptions & IDecodedData): void {\r\n        const oglTexture2D = 3553; // gl.TEXTURE_2D\r\n\r\n        this._engine._bindTextureDirectly(oglTexture2D, internalTexture);\r\n\r\n        if (options) {\r\n            // return back some information about the decoded data\r\n            options.transcodedFormat = data.transcodedFormat;\r\n            options.isInGammaSpace = data.isInGammaSpace;\r\n            options.hasAlpha = data.hasAlpha;\r\n            options.transcoderName = data.transcoderName;\r\n        }\r\n\r\n        let isUncompressedFormat = true;\r\n\r\n        switch (data.transcodedFormat) {\r\n            case 0x8058 /* RGBA8 */:\r\n                internalTexture.type = Constants.TEXTURETYPE_UNSIGNED_BYTE;\r\n                internalTexture.format = Constants.TEXTUREFORMAT_RGBA;\r\n                break;\r\n            case 0x8229 /* R8 */:\r\n                internalTexture.type = Constants.TEXTURETYPE_UNSIGNED_BYTE;\r\n                internalTexture.format = Constants.TEXTUREFORMAT_R;\r\n                break;\r\n            case 0x822b /* RG8 */:\r\n                internalTexture.type = Constants.TEXTURETYPE_UNSIGNED_BYTE;\r\n                internalTexture.format = Constants.TEXTUREFORMAT_RG;\r\n                break;\r\n            default:\r\n                internalTexture.format = data.transcodedFormat;\r\n                isUncompressedFormat = false;\r\n                break;\r\n        }\r\n\r\n        internalTexture._gammaSpace = data.isInGammaSpace;\r\n        internalTexture.generateMipMaps = data.mipmaps.length > 1;\r\n\r\n        if (data.errors) {\r\n            throw new Error(\"KTX2 container - could not transcode the data. \" + data.errors);\r\n        }\r\n\r\n        for (let t = 0; t < data.mipmaps.length; ++t) {\r\n            const mipmap = data.mipmaps[t];\r\n\r\n            if (!mipmap || !mipmap.data) {\r\n                throw new Error(\"KTX2 container - could not transcode one of the image\");\r\n            }\r\n\r\n            if (isUncompressedFormat) {\r\n                // uncompressed RGBA / R8 / RG8\r\n                internalTexture.width = mipmap.width; // need to set width/height so that the call to _uploadDataToTextureDirectly uses the right dimensions\r\n                internalTexture.height = mipmap.height;\r\n\r\n                this._engine._uploadDataToTextureDirectly(internalTexture, mipmap.data, 0, t, undefined, true);\r\n            } else {\r\n                this._engine._uploadCompressedDataToTextureDirectly(internalTexture, data.transcodedFormat, mipmap.width, mipmap.height, mipmap.data, 0, t);\r\n            }\r\n        }\r\n\r\n        internalTexture._extension = \".ktx2\";\r\n        internalTexture.width = data.mipmaps[0].width;\r\n        internalTexture.height = data.mipmaps[0].height;\r\n        internalTexture.isReady = true;\r\n\r\n        this._engine._bindTextureDirectly(oglTexture2D, null);\r\n    }\r\n\r\n    /**\r\n     * Checks if the given data starts with a KTX2 file identifier.\r\n     * @param data the data to check\r\n     * @returns true if the data is a KTX2 file or false otherwise\r\n     */\r\n    public static IsValid(data: ArrayBufferView): boolean {\r\n        if (data.byteLength >= 12) {\r\n            // '', 'K', 'T', 'X', ' ', '2', '0', '', '\\r', '\\n', '\\x1A', '\\n'\r\n            const identifier = new Uint8Array(data.buffer, data.byteOffset, 12);\r\n            if (\r\n                identifier[0] === 0xab &&\r\n                identifier[1] === 0x4b &&\r\n                identifier[2] === 0x54 &&\r\n                identifier[3] === 0x58 &&\r\n                identifier[4] === 0x20 &&\r\n                identifier[5] === 0x32 &&\r\n                identifier[6] === 0x30 &&\r\n                identifier[7] === 0xbb &&\r\n                identifier[8] === 0x0d &&\r\n                identifier[9] === 0x0a &&\r\n                identifier[10] === 0x1a &&\r\n                identifier[11] === 0x0a\r\n            ) {\r\n                return true;\r\n            }\r\n        }\r\n\r\n        return false;\r\n    }\r\n}\r\n", "import { KhronosTextureContainer } from \"../../../Misc/khronosTextureContainer\";\r\nimport { KhronosTextureContainer2 } from \"../../../Misc/khronosTextureContainer2\";\r\nimport type { Nullable } from \"../../../types\";\r\nimport { Engine } from \"../../../Engines/engine\";\r\nimport type { InternalTexture } from \"../../../Materials/Textures/internalTexture\";\r\nimport type { IInternalTextureLoader } from \"../../../Materials/Textures/internalTextureLoader\";\r\nimport { Logger } from \"../../../Misc/logger\";\r\nimport { Constants } from \"../../../Engines/constants\";\r\n\r\nfunction mapSRGBToLinear(format: number): Nullable<number> {\r\n    switch (format) {\r\n        case Constants.TEXTUREFORMAT_COMPRESSED_SRGB_S3TC_DXT1_EXT:\r\n            return Constants.TEXTUREFORMAT_COMPRESSED_RGB_S3TC_DXT1;\r\n        case Constants.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT:\r\n            return Constants.TEXTUREFORMAT_COMPRESSED_RGBA_S3TC_DXT3;\r\n        case Constants.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT:\r\n            return Constants.TEXTUREFORMAT_COMPRESSED_RGBA_S3TC_DXT5;\r\n        case Constants.TEXTUREFORMAT_COMPRESSED_SRGB8_ETC2:\r\n            return Constants.TEXTUREFORMAT_COMPRESSED_RGB8_ETC2;\r\n        case Constants.TEXTUREFORMAT_COMPRESSED_SRGB8_ALPHA8_ETC2_EAC:\r\n            return Constants.TEXTUREFORMAT_COMPRESSED_RGBA8_ETC2_EAC;\r\n        case Constants.TEXTUREFORMAT_COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2:\r\n            return Constants.TEXTUREFORMAT_COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2;\r\n        case Constants.TEXTUREFORMAT_COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR:\r\n            return Constants.TEXTUREFORMAT_COMPRESSED_RGBA_ASTC_4x4;\r\n        case Constants.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_BPTC_UNORM:\r\n            return Constants.TEXTUREFORMAT_COMPRESSED_RGBA_BPTC_UNORM;\r\n    }\r\n\r\n    return null;\r\n}\r\n\r\n/**\r\n * Implementation of the KTX Texture Loader.\r\n * @internal\r\n */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nexport class _KTXTextureLoader implements IInternalTextureLoader {\r\n    /**\r\n     * Defines whether the loader supports cascade loading the different faces.\r\n     */\r\n    public readonly supportCascades = false;\r\n\r\n    /**\r\n     * This returns if the loader support the current file information.\r\n     * @param extension defines the file extension of the file being loaded\r\n     * @param mimeType defines the optional mime type of the file being loaded\r\n     * @returns true if the loader can load the specified file\r\n     */\r\n    public canLoad(extension: string, mimeType?: string): boolean {\r\n        // The \".ktx2\" file extension is still up for debate: https://github.com/KhronosGroup/KTX-Specification/issues/18\r\n        return extension.endsWith(\".ktx\") || extension.endsWith(\".ktx2\") || mimeType === \"image/ktx\" || mimeType === \"image/ktx2\";\r\n    }\r\n\r\n    /**\r\n     * Uploads the cube texture data to the WebGL texture. It has already been bound.\r\n     * @param data contains the texture data\r\n     * @param texture defines the BabylonJS internal texture\r\n     * @param createPolynomials will be true if polynomials have been requested\r\n     * @param onLoad defines the callback to trigger once the texture is ready\r\n     */\r\n    public loadCubeData(data: ArrayBufferView | ArrayBufferView[], texture: InternalTexture, createPolynomials: boolean, onLoad: Nullable<(data?: any) => void>): void {\r\n        if (Array.isArray(data)) {\r\n            return;\r\n        }\r\n\r\n        // Need to invert vScale as invertY via UNPACK_FLIP_Y_WEBGL is not supported by compressed texture\r\n        texture._invertVScale = !texture.invertY;\r\n        const engine = texture.getEngine() as Engine;\r\n        const ktx = new KhronosTextureContainer(data, 6);\r\n\r\n        const loadMipmap = ktx.numberOfMipmapLevels > 1 && texture.generateMipMaps;\r\n\r\n        engine._unpackFlipY(true);\r\n\r\n        ktx.uploadLevels(texture, texture.generateMipMaps);\r\n\r\n        texture.width = ktx.pixelWidth;\r\n        texture.height = ktx.pixelHeight;\r\n\r\n        engine._setCubeMapTextureParams(texture, loadMipmap, ktx.numberOfMipmapLevels - 1);\r\n        texture.isReady = true;\r\n        texture.onLoadedObservable.notifyObservers(texture);\r\n        texture.onLoadedObservable.clear();\r\n\r\n        if (onLoad) {\r\n            onLoad();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Uploads the 2D texture data to the WebGL texture. It has already been bound once in the callback.\r\n     * @param data contains the texture data\r\n     * @param texture defines the BabylonJS internal texture\r\n     * @param callback defines the method to call once ready to upload\r\n     * @param options\r\n     */\r\n    public loadData(\r\n        data: ArrayBufferView,\r\n        texture: InternalTexture,\r\n        callback: (width: number, height: number, loadMipmap: boolean, isCompressed: boolean, done: () => void, loadFailed: boolean) => void,\r\n        options?: any\r\n    ): void {\r\n        if (KhronosTextureContainer.IsValid(data)) {\r\n            // Need to invert vScale as invertY via UNPACK_FLIP_Y_WEBGL is not supported by compressed texture\r\n            texture._invertVScale = !texture.invertY;\r\n            const ktx = new KhronosTextureContainer(data, 1);\r\n\r\n            const mappedFormat = mapSRGBToLinear(ktx.glInternalFormat);\r\n            if (mappedFormat) {\r\n                texture.format = mappedFormat;\r\n                texture._useSRGBBuffer = texture.getEngine()._getUseSRGBBuffer(true, texture.generateMipMaps);\r\n                texture._gammaSpace = true;\r\n            } else {\r\n                texture.format = ktx.glInternalFormat;\r\n            }\r\n\r\n            callback(\r\n                ktx.pixelWidth,\r\n                ktx.pixelHeight,\r\n                texture.generateMipMaps,\r\n                true,\r\n                () => {\r\n                    ktx.uploadLevels(texture, texture.generateMipMaps);\r\n                },\r\n                ktx.isInvalid\r\n            );\r\n        } else if (KhronosTextureContainer2.IsValid(data)) {\r\n            const ktx2 = new KhronosTextureContainer2(texture.getEngine());\r\n            ktx2._uploadAsync(data, texture, options).then(\r\n                () => {\r\n                    callback(texture.width, texture.height, texture.generateMipMaps, true, () => {}, false);\r\n                },\r\n                (error) => {\r\n                    Logger.Warn(`Failed to load KTX2 texture data: ${error.message}`);\r\n                    callback(0, 0, false, false, () => {}, true);\r\n                }\r\n            );\r\n        } else {\r\n            Logger.Error(\"texture missing KTX identifier\");\r\n            callback(0, 0, false, false, () => {}, true);\r\n        }\r\n    }\r\n}\r\n\r\n// Register the loader.\r\nEngine._TextureLoaders.unshift(new _KTXTextureLoader());\r\n", "/* eslint-disable @typescript-eslint/naming-convention */\r\nimport type { InternalTexture } from \"../Materials/Textures/internalTexture\";\r\nimport { Logger } from \"../Misc/logger\";\r\n\r\n//private static _TYPE_NO_DATA = 0;\r\nconst _TYPE_INDEXED = 1;\r\nconst _TYPE_RGB = 2;\r\nconst _TYPE_GREY = 3;\r\nconst _TYPE_RLE_INDEXED = 9;\r\nconst _TYPE_RLE_RGB = 10;\r\nconst _TYPE_RLE_GREY = 11;\r\nconst _ORIGIN_MASK = 0x30;\r\nconst _ORIGIN_SHIFT = 0x04;\r\nconst _ORIGIN_BL = 0x00;\r\nconst _ORIGIN_BR = 0x01;\r\nconst _ORIGIN_UL = 0x02;\r\nconst _ORIGIN_UR = 0x03;\r\n\r\n/**\r\n * Gets the header of a TGA file\r\n * @param data defines the TGA data\r\n * @returns the header\r\n */\r\nexport function GetTGAHeader(data: Uint8Array): any {\r\n    let offset = 0;\r\n\r\n    const header = {\r\n        id_length: data[offset++],\r\n        colormap_type: data[offset++],\r\n        image_type: data[offset++],\r\n        colormap_index: data[offset++] | (data[offset++] << 8),\r\n        colormap_length: data[offset++] | (data[offset++] << 8),\r\n        colormap_size: data[offset++],\r\n        origin: [data[offset++] | (data[offset++] << 8), data[offset++] | (data[offset++] << 8)],\r\n        width: data[offset++] | (data[offset++] << 8),\r\n        height: data[offset++] | (data[offset++] << 8),\r\n        pixel_size: data[offset++],\r\n        flags: data[offset++],\r\n    };\r\n\r\n    return header;\r\n}\r\n\r\n/**\r\n * Uploads TGA content to a Babylon Texture\r\n * @internal\r\n */\r\nexport function UploadContent(texture: InternalTexture, data: Uint8Array): void {\r\n    // Not enough data to contain header ?\r\n    if (data.length < 19) {\r\n        Logger.Error(\"Unable to load TGA file - Not enough data to contain header\");\r\n        return;\r\n    }\r\n\r\n    // Read Header\r\n    let offset = 18;\r\n    const header = GetTGAHeader(data);\r\n\r\n    // Assume it's a valid Targa file.\r\n    if (header.id_length + offset > data.length) {\r\n        Logger.Error(\"Unable to load TGA file - Not enough data\");\r\n        return;\r\n    }\r\n\r\n    // Skip not needed data\r\n    offset += header.id_length;\r\n\r\n    let use_rle = false;\r\n    let use_pal = false;\r\n    let use_grey = false;\r\n\r\n    // Get some informations.\r\n    switch (header.image_type) {\r\n        case _TYPE_RLE_INDEXED:\r\n            use_rle = true;\r\n        // eslint-disable-next-line no-fallthrough\r\n        case _TYPE_INDEXED:\r\n            use_pal = true;\r\n            break;\r\n\r\n        case _TYPE_RLE_RGB:\r\n            use_rle = true;\r\n        // eslint-disable-next-line no-fallthrough\r\n        case _TYPE_RGB:\r\n            // use_rgb = true;\r\n            break;\r\n\r\n        case _TYPE_RLE_GREY:\r\n            use_rle = true;\r\n        // eslint-disable-next-line no-fallthrough\r\n        case _TYPE_GREY:\r\n            use_grey = true;\r\n            break;\r\n    }\r\n\r\n    let pixel_data;\r\n\r\n    // var numAlphaBits = header.flags & 0xf;\r\n    const pixel_size = header.pixel_size >> 3;\r\n    const pixel_total = header.width * header.height * pixel_size;\r\n\r\n    // Read palettes\r\n    let palettes;\r\n\r\n    if (use_pal) {\r\n        palettes = data.subarray(offset, (offset += header.colormap_length * (header.colormap_size >> 3)));\r\n    }\r\n\r\n    // Read LRE\r\n    if (use_rle) {\r\n        pixel_data = new Uint8Array(pixel_total);\r\n\r\n        let c, count, i;\r\n        let localOffset = 0;\r\n        const pixels = new Uint8Array(pixel_size);\r\n\r\n        while (offset < pixel_total && localOffset < pixel_total) {\r\n            c = data[offset++];\r\n            count = (c & 0x7f) + 1;\r\n\r\n            // RLE pixels\r\n            if (c & 0x80) {\r\n                // Bind pixel tmp array\r\n                for (i = 0; i < pixel_size; ++i) {\r\n                    pixels[i] = data[offset++];\r\n                }\r\n\r\n                // Copy pixel array\r\n                for (i = 0; i < count; ++i) {\r\n                    pixel_data.set(pixels, localOffset + i * pixel_size);\r\n                }\r\n\r\n                localOffset += pixel_size * count;\r\n            }\r\n            // Raw pixels\r\n            else {\r\n                count *= pixel_size;\r\n                for (i = 0; i < count; ++i) {\r\n                    pixel_data[localOffset + i] = data[offset++];\r\n                }\r\n                localOffset += count;\r\n            }\r\n        }\r\n    }\r\n    // RAW Pixels\r\n    else {\r\n        pixel_data = data.subarray(offset, (offset += use_pal ? header.width * header.height : pixel_total));\r\n    }\r\n\r\n    // Load to texture\r\n    let x_start, y_start, x_step, y_step, y_end, x_end;\r\n\r\n    switch ((header.flags & _ORIGIN_MASK) >> _ORIGIN_SHIFT) {\r\n        default:\r\n        case _ORIGIN_UL:\r\n            x_start = 0;\r\n            x_step = 1;\r\n            x_end = header.width;\r\n            y_start = 0;\r\n            y_step = 1;\r\n            y_end = header.height;\r\n            break;\r\n\r\n        case _ORIGIN_BL:\r\n            x_start = 0;\r\n            x_step = 1;\r\n            x_end = header.width;\r\n            y_start = header.height - 1;\r\n            y_step = -1;\r\n            y_end = -1;\r\n            break;\r\n\r\n        case _ORIGIN_UR:\r\n            x_start = header.width - 1;\r\n            x_step = -1;\r\n            x_end = -1;\r\n            y_start = 0;\r\n            y_step = 1;\r\n            y_end = header.height;\r\n            break;\r\n\r\n        case _ORIGIN_BR:\r\n            x_start = header.width - 1;\r\n            x_step = -1;\r\n            x_end = -1;\r\n            y_start = header.height - 1;\r\n            y_step = -1;\r\n            y_end = -1;\r\n            break;\r\n    }\r\n\r\n    // Load the specify method\r\n    const func = \"_getImageData\" + (use_grey ? \"Grey\" : \"\") + header.pixel_size + \"bits\";\r\n    const imageData = (<any>TGATools)[func](header, palettes, pixel_data, y_start, y_step, y_end, x_start, x_step, x_end);\r\n\r\n    const engine = texture.getEngine();\r\n    engine._uploadDataToTextureDirectly(texture, imageData);\r\n}\r\n\r\n/**\r\n * @internal\r\n */\r\nfunction _getImageData8bits(\r\n    header: any,\r\n    palettes: Uint8Array,\r\n    pixel_data: Uint8Array,\r\n    y_start: number,\r\n    y_step: number,\r\n    y_end: number,\r\n    x_start: number,\r\n    x_step: number,\r\n    x_end: number\r\n): Uint8Array {\r\n    const image = pixel_data,\r\n        colormap = palettes;\r\n    const width = header.width,\r\n        height = header.height;\r\n    let color,\r\n        i = 0,\r\n        x,\r\n        y;\r\n\r\n    const imageData = new Uint8Array(width * height * 4);\r\n\r\n    for (y = y_start; y !== y_end; y += y_step) {\r\n        for (x = x_start; x !== x_end; x += x_step, i++) {\r\n            color = image[i];\r\n            imageData[(x + width * y) * 4 + 3] = 255;\r\n            imageData[(x + width * y) * 4 + 2] = colormap[color * 3 + 0];\r\n            imageData[(x + width * y) * 4 + 1] = colormap[color * 3 + 1];\r\n            imageData[(x + width * y) * 4 + 0] = colormap[color * 3 + 2];\r\n        }\r\n    }\r\n\r\n    return imageData;\r\n}\r\n\r\n/**\r\n * @internal\r\n */\r\nfunction _getImageData16bits(\r\n    header: any,\r\n    palettes: Uint8Array,\r\n    pixel_data: Uint8Array,\r\n    y_start: number,\r\n    y_step: number,\r\n    y_end: number,\r\n    x_start: number,\r\n    x_step: number,\r\n    x_end: number\r\n): Uint8Array {\r\n    const image = pixel_data;\r\n    const width = header.width,\r\n        height = header.height;\r\n    let color,\r\n        i = 0,\r\n        x,\r\n        y;\r\n\r\n    const imageData = new Uint8Array(width * height * 4);\r\n\r\n    for (y = y_start; y !== y_end; y += y_step) {\r\n        for (x = x_start; x !== x_end; x += x_step, i += 2) {\r\n            color = image[i + 0] + (image[i + 1] << 8); // Inversed ?\r\n            const r = ((((color & 0x7c00) >> 10) * 255) / 0x1f) | 0;\r\n            const g = ((((color & 0x03e0) >> 5) * 255) / 0x1f) | 0;\r\n            const b = (((color & 0x001f) * 255) / 0x1f) | 0;\r\n\r\n            imageData[(x + width * y) * 4 + 0] = r;\r\n            imageData[(x + width * y) * 4 + 1] = g;\r\n            imageData[(x + width * y) * 4 + 2] = b;\r\n            imageData[(x + width * y) * 4 + 3] = color & 0x8000 ? 0 : 255;\r\n        }\r\n    }\r\n\r\n    return imageData;\r\n}\r\n\r\n/**\r\n * @internal\r\n */\r\nfunction _getImageData24bits(\r\n    header: any,\r\n    palettes: Uint8Array,\r\n    pixel_data: Uint8Array,\r\n    y_start: number,\r\n    y_step: number,\r\n    y_end: number,\r\n    x_start: number,\r\n    x_step: number,\r\n    x_end: number\r\n): Uint8Array {\r\n    const image = pixel_data;\r\n    const width = header.width,\r\n        height = header.height;\r\n    let i = 0,\r\n        x,\r\n        y;\r\n\r\n    const imageData = new Uint8Array(width * height * 4);\r\n\r\n    for (y = y_start; y !== y_end; y += y_step) {\r\n        for (x = x_start; x !== x_end; x += x_step, i += 3) {\r\n            imageData[(x + width * y) * 4 + 3] = 255;\r\n            imageData[(x + width * y) * 4 + 2] = image[i + 0];\r\n            imageData[(x + width * y) * 4 + 1] = image[i + 1];\r\n            imageData[(x + width * y) * 4 + 0] = image[i + 2];\r\n        }\r\n    }\r\n\r\n    return imageData;\r\n}\r\n\r\n/**\r\n * @internal\r\n */\r\nfunction _getImageData32bits(\r\n    header: any,\r\n    palettes: Uint8Array,\r\n    pixel_data: Uint8Array,\r\n    y_start: number,\r\n    y_step: number,\r\n    y_end: number,\r\n    x_start: number,\r\n    x_step: number,\r\n    x_end: number\r\n): Uint8Array {\r\n    const image = pixel_data;\r\n    const width = header.width,\r\n        height = header.height;\r\n    let i = 0,\r\n        x,\r\n        y;\r\n\r\n    const imageData = new Uint8Array(width * height * 4);\r\n\r\n    for (y = y_start; y !== y_end; y += y_step) {\r\n        for (x = x_start; x !== x_end; x += x_step, i += 4) {\r\n            imageData[(x + width * y) * 4 + 2] = image[i + 0];\r\n            imageData[(x + width * y) * 4 + 1] = image[i + 1];\r\n            imageData[(x + width * y) * 4 + 0] = image[i + 2];\r\n            imageData[(x + width * y) * 4 + 3] = image[i + 3];\r\n        }\r\n    }\r\n\r\n    return imageData;\r\n}\r\n\r\n/**\r\n * @internal\r\n */\r\nfunction _getImageDataGrey8bits(\r\n    header: any,\r\n    palettes: Uint8Array,\r\n    pixel_data: Uint8Array,\r\n    y_start: number,\r\n    y_step: number,\r\n    y_end: number,\r\n    x_start: number,\r\n    x_step: number,\r\n    x_end: number\r\n): Uint8Array {\r\n    const image = pixel_data;\r\n    const width = header.width,\r\n        height = header.height;\r\n    let color,\r\n        i = 0,\r\n        x,\r\n        y;\r\n\r\n    const imageData = new Uint8Array(width * height * 4);\r\n\r\n    for (y = y_start; y !== y_end; y += y_step) {\r\n        for (x = x_start; x !== x_end; x += x_step, i++) {\r\n            color = image[i];\r\n            imageData[(x + width * y) * 4 + 0] = color;\r\n            imageData[(x + width * y) * 4 + 1] = color;\r\n            imageData[(x + width * y) * 4 + 2] = color;\r\n            imageData[(x + width * y) * 4 + 3] = 255;\r\n        }\r\n    }\r\n\r\n    return imageData;\r\n}\r\n\r\n/**\r\n * @internal\r\n */\r\nfunction _getImageDataGrey16bits(\r\n    header: any,\r\n    palettes: Uint8Array,\r\n    pixel_data: Uint8Array,\r\n    y_start: number,\r\n    y_step: number,\r\n    y_end: number,\r\n    x_start: number,\r\n    x_step: number,\r\n    x_end: number\r\n): Uint8Array {\r\n    const image = pixel_data;\r\n    const width = header.width,\r\n        height = header.height;\r\n    let i = 0,\r\n        x,\r\n        y;\r\n\r\n    const imageData = new Uint8Array(width * height * 4);\r\n\r\n    for (y = y_start; y !== y_end; y += y_step) {\r\n        for (x = x_start; x !== x_end; x += x_step, i += 2) {\r\n            imageData[(x + width * y) * 4 + 0] = image[i + 0];\r\n            imageData[(x + width * y) * 4 + 1] = image[i + 0];\r\n            imageData[(x + width * y) * 4 + 2] = image[i + 0];\r\n            imageData[(x + width * y) * 4 + 3] = image[i + 1];\r\n        }\r\n    }\r\n\r\n    return imageData;\r\n}\r\n\r\n/**\r\n * Based on jsTGALoader - Javascript loader for TGA file\r\n * By Vincent Thibault\r\n * @see http://blog.robrowser.com/javascript-tga-loader.html\r\n */\r\nexport const TGATools = {\r\n    /**\r\n     * Gets the header of a TGA file\r\n     * @param data defines the TGA data\r\n     * @returns the header\r\n     */\r\n    GetTGAHeader,\r\n\r\n    /**\r\n     * Uploads TGA content to a Babylon Texture\r\n     * @internal\r\n     */\r\n    UploadContent,\r\n\r\n    /** @internal */\r\n    _getImageData8bits,\r\n\r\n    /** @internal */\r\n    _getImageData16bits,\r\n    /** @internal */\r\n    _getImageData24bits,\r\n\r\n    /** @internal */\r\n    _getImageData32bits,\r\n\r\n    /** @internal */\r\n    _getImageDataGrey8bits,\r\n    /** @internal */\r\n    _getImageDataGrey16bits,\r\n};\r\n", "import { GetTGAHeader, UploadContent } from \"../../../Misc/tga\";\r\nimport { Engine } from \"../../../Engines/engine\";\r\nimport type { InternalTexture } from \"../../../Materials/Textures/internalTexture\";\r\nimport type { IInternalTextureLoader } from \"../../../Materials/Textures/internalTextureLoader\";\r\n\r\n/**\r\n * Implementation of the TGA Texture Loader.\r\n * @internal\r\n */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nexport class _TGATextureLoader implements IInternalTextureLoader {\r\n    /**\r\n     * Defines whether the loader supports cascade loading the different faces.\r\n     */\r\n    public readonly supportCascades = false;\r\n\r\n    /**\r\n     * This returns if the loader support the current file information.\r\n     * @param extension defines the file extension of the file being loaded\r\n     * @returns true if the loader can load the specified file\r\n     */\r\n    public canLoad(extension: string): boolean {\r\n        return extension.endsWith(\".tga\");\r\n    }\r\n\r\n    /**\r\n     * Uploads the cube texture data to the WebGL texture. It has already been bound.\r\n     */\r\n    public loadCubeData(): void {\r\n        // eslint-disable-next-line no-throw-literal\r\n        throw \".env not supported in Cube.\";\r\n    }\r\n\r\n    /**\r\n     * Uploads the 2D texture data to the WebGL texture. It has already been bound once in the callback.\r\n     * @param data contains the texture data\r\n     * @param texture defines the BabylonJS internal texture\r\n     * @param callback defines the method to call once ready to upload\r\n     */\r\n    public loadData(\r\n        data: ArrayBufferView,\r\n        texture: InternalTexture,\r\n        callback: (width: number, height: number, loadMipmap: boolean, isCompressed: boolean, done: () => void) => void\r\n    ): void {\r\n        const bytes = new Uint8Array(data.buffer, data.byteOffset, data.byteLength);\r\n\r\n        const header = GetTGAHeader(bytes);\r\n        callback(header.width, header.height, texture.generateMipMaps, false, () => {\r\n            UploadContent(texture, bytes);\r\n        });\r\n    }\r\n}\r\n\r\n// Register the loader.\r\nEngine._TextureLoaders.push(new _TGATextureLoader());\r\n", "/* eslint-disable @typescript-eslint/naming-convention */\r\nimport type { Nullable } from \"../../types\";\r\nimport { Vector3 } from \"../../Maths/math.vector\";\r\nimport { Constants } from \"../../Engines/constants\";\r\n\r\n/**\r\n * CubeMap information grouping all the data for each faces as well as the cubemap size.\r\n */\r\nexport interface CubeMapInfo {\r\n    /**\r\n     * The pixel array for the front face.\r\n     * This is stored in format, left to right, up to down format.\r\n     */\r\n    front: Nullable<ArrayBufferView>;\r\n\r\n    /**\r\n     * The pixel array for the back face.\r\n     * This is stored in format, left to right, up to down format.\r\n     */\r\n    back: Nullable<ArrayBufferView>;\r\n\r\n    /**\r\n     * The pixel array for the left face.\r\n     * This is stored in format, left to right, up to down format.\r\n     */\r\n    left: Nullable<ArrayBufferView>;\r\n\r\n    /**\r\n     * The pixel array for the right face.\r\n     * This is stored in format, left to right, up to down format.\r\n     */\r\n    right: Nullable<ArrayBufferView>;\r\n\r\n    /**\r\n     * The pixel array for the up face.\r\n     * This is stored in format, left to right, up to down format.\r\n     */\r\n    up: Nullable<ArrayBufferView>;\r\n\r\n    /**\r\n     * The pixel array for the down face.\r\n     * This is stored in format, left to right, up to down format.\r\n     */\r\n    down: Nullable<ArrayBufferView>;\r\n\r\n    /**\r\n     * The size of the cubemap stored.\r\n     *\r\n     * Each faces will be size * size pixels.\r\n     */\r\n    size: number;\r\n\r\n    /**\r\n     * The format of the texture.\r\n     *\r\n     * RGBA, RGB.\r\n     */\r\n    format: number;\r\n\r\n    /**\r\n     * The type of the texture data.\r\n     *\r\n     * UNSIGNED_INT, FLOAT.\r\n     */\r\n    type: number;\r\n\r\n    /**\r\n     * Specifies whether the texture is in gamma space.\r\n     */\r\n    gammaSpace: boolean;\r\n}\r\n\r\n/**\r\n * Helper class useful to convert panorama picture to their cubemap representation in 6 faces.\r\n */\r\nexport class PanoramaToCubeMapTools {\r\n    private static FACE_LEFT = [new Vector3(-1.0, -1.0, -1.0), new Vector3(1.0, -1.0, -1.0), new Vector3(-1.0, 1.0, -1.0), new Vector3(1.0, 1.0, -1.0)];\r\n    private static FACE_RIGHT = [new Vector3(1.0, -1.0, 1.0), new Vector3(-1.0, -1.0, 1.0), new Vector3(1.0, 1.0, 1.0), new Vector3(-1.0, 1.0, 1.0)];\r\n    private static FACE_FRONT = [new Vector3(1.0, -1.0, -1.0), new Vector3(1.0, -1.0, 1.0), new Vector3(1.0, 1.0, -1.0), new Vector3(1.0, 1.0, 1.0)];\r\n    private static FACE_BACK = [new Vector3(-1.0, -1.0, 1.0), new Vector3(-1.0, -1.0, -1.0), new Vector3(-1.0, 1.0, 1.0), new Vector3(-1.0, 1.0, -1.0)];\r\n    private static FACE_DOWN = [new Vector3(1.0, 1.0, -1.0), new Vector3(1.0, 1.0, 1.0), new Vector3(-1.0, 1.0, -1.0), new Vector3(-1.0, 1.0, 1.0)];\r\n    private static FACE_UP = [new Vector3(-1.0, -1.0, -1.0), new Vector3(-1.0, -1.0, 1.0), new Vector3(1.0, -1.0, -1.0), new Vector3(1.0, -1.0, 1.0)];\r\n\r\n    /**\r\n     * Converts a panorama stored in RGB right to left up to down format into a cubemap (6 faces).\r\n     *\r\n     * @param float32Array The source data.\r\n     * @param inputWidth The width of the input panorama.\r\n     * @param inputHeight The height of the input panorama.\r\n     * @param size The willing size of the generated cubemap (each faces will be size * size pixels)\r\n     * @param supersample enable supersampling the cubemap\r\n     * @returns The cubemap data\r\n     */\r\n    public static ConvertPanoramaToCubemap(float32Array: Float32Array, inputWidth: number, inputHeight: number, size: number, supersample = false): CubeMapInfo {\r\n        if (!float32Array) {\r\n            // eslint-disable-next-line no-throw-literal\r\n            throw \"ConvertPanoramaToCubemap: input cannot be null\";\r\n        }\r\n\r\n        if (float32Array.length != inputWidth * inputHeight * 3) {\r\n            // eslint-disable-next-line no-throw-literal\r\n            throw \"ConvertPanoramaToCubemap: input size is wrong\";\r\n        }\r\n\r\n        const textureFront = this.CreateCubemapTexture(size, this.FACE_FRONT, float32Array, inputWidth, inputHeight, supersample);\r\n        const textureBack = this.CreateCubemapTexture(size, this.FACE_BACK, float32Array, inputWidth, inputHeight, supersample);\r\n        const textureLeft = this.CreateCubemapTexture(size, this.FACE_LEFT, float32Array, inputWidth, inputHeight, supersample);\r\n        const textureRight = this.CreateCubemapTexture(size, this.FACE_RIGHT, float32Array, inputWidth, inputHeight, supersample);\r\n        const textureUp = this.CreateCubemapTexture(size, this.FACE_UP, float32Array, inputWidth, inputHeight, supersample);\r\n        const textureDown = this.CreateCubemapTexture(size, this.FACE_DOWN, float32Array, inputWidth, inputHeight, supersample);\r\n\r\n        return {\r\n            front: textureFront,\r\n            back: textureBack,\r\n            left: textureLeft,\r\n            right: textureRight,\r\n            up: textureUp,\r\n            down: textureDown,\r\n            size: size,\r\n            type: Constants.TEXTURETYPE_FLOAT,\r\n            format: Constants.TEXTUREFORMAT_RGB,\r\n            gammaSpace: false,\r\n        };\r\n    }\r\n\r\n    private static CreateCubemapTexture(texSize: number, faceData: Vector3[], float32Array: Float32Array, inputWidth: number, inputHeight: number, supersample = false) {\r\n        const buffer = new ArrayBuffer(texSize * texSize * 4 * 3);\r\n        const textureArray = new Float32Array(buffer);\r\n\r\n        // If supersampling, determine number of samples needed when source texture width is divided for 4 cube faces\r\n        const samples = supersample ? Math.max(1, Math.round(inputWidth / 4 / texSize)) : 1;\r\n        const sampleFactor = 1 / samples;\r\n        const sampleFactorSqr = sampleFactor * sampleFactor;\r\n\r\n        const rotDX1 = faceData[1].subtract(faceData[0]).scale(sampleFactor / texSize);\r\n        const rotDX2 = faceData[3].subtract(faceData[2]).scale(sampleFactor / texSize);\r\n\r\n        const dy = 1 / texSize;\r\n        let fy = 0;\r\n\r\n        for (let y = 0; y < texSize; y++) {\r\n            for (let sy = 0; sy < samples; sy++) {\r\n                let xv1 = faceData[0];\r\n                let xv2 = faceData[2];\r\n\r\n                for (let x = 0; x < texSize; x++) {\r\n                    for (let sx = 0; sx < samples; sx++) {\r\n                        const v = xv2.subtract(xv1).scale(fy).add(xv1);\r\n                        v.normalize();\r\n\r\n                        const color = this.CalcProjectionSpherical(v, float32Array, inputWidth, inputHeight);\r\n\r\n                        // 3 channels per pixels\r\n                        textureArray[y * texSize * 3 + x * 3 + 0] += color.r * sampleFactorSqr;\r\n                        textureArray[y * texSize * 3 + x * 3 + 1] += color.g * sampleFactorSqr;\r\n                        textureArray[y * texSize * 3 + x * 3 + 2] += color.b * sampleFactorSqr;\r\n\r\n                        xv1 = xv1.add(rotDX1);\r\n                        xv2 = xv2.add(rotDX2);\r\n                    }\r\n                }\r\n\r\n                fy += dy * sampleFactor;\r\n            }\r\n        }\r\n\r\n        return textureArray;\r\n    }\r\n\r\n    private static CalcProjectionSpherical(vDir: Vector3, float32Array: Float32Array, inputWidth: number, inputHeight: number): any {\r\n        let theta = Math.atan2(vDir.z, vDir.x);\r\n        const phi = Math.acos(vDir.y);\r\n\r\n        while (theta < -Math.PI) {\r\n            theta += 2 * Math.PI;\r\n        }\r\n        while (theta > Math.PI) {\r\n            theta -= 2 * Math.PI;\r\n        }\r\n\r\n        let dx = theta / Math.PI;\r\n        const dy = phi / Math.PI;\r\n\r\n        // recenter.\r\n        dx = dx * 0.5 + 0.5;\r\n\r\n        let px = Math.round(dx * inputWidth);\r\n        if (px < 0) {\r\n            px = 0;\r\n        } else if (px >= inputWidth) {\r\n            px = inputWidth - 1;\r\n        }\r\n\r\n        let py = Math.round(dy * inputHeight);\r\n        if (py < 0) {\r\n            py = 0;\r\n        } else if (py >= inputHeight) {\r\n            py = inputHeight - 1;\r\n        }\r\n\r\n        const inputY = inputHeight - py - 1;\r\n        const r = float32Array[inputY * inputWidth * 3 + px * 3 + 0];\r\n        const g = float32Array[inputY * inputWidth * 3 + px * 3 + 1];\r\n        const b = float32Array[inputY * inputWidth * 3 + px * 3 + 2];\r\n\r\n        return {\r\n            r: r,\r\n            g: g,\r\n            b: b,\r\n        };\r\n    }\r\n}\r\n", "import type { CubeMapInfo } from \"./panoramaToCubemap\";\r\nimport { PanoramaToCubeMapTools } from \"./panoramaToCubemap\";\r\n\r\n/**\r\n * Header information of HDR texture files.\r\n */\r\nexport interface HDRInfo {\r\n    /**\r\n     * The height of the texture in pixels.\r\n     */\r\n    height: number;\r\n\r\n    /**\r\n     * The width of the texture in pixels.\r\n     */\r\n    width: number;\r\n\r\n    /**\r\n     * The index of the beginning of the data in the binary file.\r\n     */\r\n    dataPosition: number;\r\n}\r\n\r\n/**\r\n * This groups tools to convert HDR texture to native colors array.\r\n */\r\nexport class HDRTools {\r\n    private static _Ldexp(mantissa: number, exponent: number): number {\r\n        if (exponent > 1023) {\r\n            return mantissa * Math.pow(2, 1023) * Math.pow(2, exponent - 1023);\r\n        }\r\n\r\n        if (exponent < -1074) {\r\n            return mantissa * Math.pow(2, -1074) * Math.pow(2, exponent + 1074);\r\n        }\r\n\r\n        return mantissa * Math.pow(2, exponent);\r\n    }\r\n\r\n    private static _Rgbe2float(float32array: Float32Array, red: number, green: number, blue: number, exponent: number, index: number) {\r\n        if (exponent > 0) {\r\n            /*nonzero pixel*/\r\n            exponent = this._Ldexp(1.0, exponent - (128 + 8));\r\n\r\n            float32array[index + 0] = red * exponent;\r\n            float32array[index + 1] = green * exponent;\r\n            float32array[index + 2] = blue * exponent;\r\n        } else {\r\n            float32array[index + 0] = 0;\r\n            float32array[index + 1] = 0;\r\n            float32array[index + 2] = 0;\r\n        }\r\n    }\r\n\r\n    private static _ReadStringLine(uint8array: Uint8Array, startIndex: number): string {\r\n        let line = \"\";\r\n        let character = \"\";\r\n\r\n        for (let i = startIndex; i < uint8array.length - startIndex; i++) {\r\n            character = String.fromCharCode(uint8array[i]);\r\n\r\n            if (character == \"\\n\") {\r\n                break;\r\n            }\r\n\r\n            line += character;\r\n        }\r\n\r\n        return line;\r\n    }\r\n\r\n    /**\r\n     * Reads header information from an RGBE texture stored in a native array.\r\n     * More information on this format are available here:\r\n     * https://en.wikipedia.org/wiki/RGBE_image_format\r\n     *\r\n     * @param uint8array The binary file stored in  native array.\r\n     * @returns The header information.\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    public static RGBE_ReadHeader(uint8array: Uint8Array): HDRInfo {\r\n        let height: number = 0;\r\n        let width: number = 0;\r\n\r\n        let line = this._ReadStringLine(uint8array, 0);\r\n        if (line[0] != \"#\" || line[1] != \"?\") {\r\n            // eslint-disable-next-line no-throw-literal\r\n            throw \"Bad HDR Format.\";\r\n        }\r\n\r\n        let endOfHeader = false;\r\n        let findFormat = false;\r\n        let lineIndex: number = 0;\r\n\r\n        do {\r\n            lineIndex += line.length + 1;\r\n            line = this._ReadStringLine(uint8array, lineIndex);\r\n\r\n            if (line == \"FORMAT=32-bit_rle_rgbe\") {\r\n                findFormat = true;\r\n            } else if (line.length == 0) {\r\n                endOfHeader = true;\r\n            }\r\n        } while (!endOfHeader);\r\n\r\n        if (!findFormat) {\r\n            // eslint-disable-next-line no-throw-literal\r\n            throw \"HDR Bad header format, unsupported FORMAT\";\r\n        }\r\n\r\n        lineIndex += line.length + 1;\r\n        line = this._ReadStringLine(uint8array, lineIndex);\r\n\r\n        const sizeRegexp = /^-Y (.*) \\+X (.*)$/g;\r\n        const match = sizeRegexp.exec(line);\r\n\r\n        // TODO. Support +Y and -X if needed.\r\n        if (!match || match.length < 3) {\r\n            // eslint-disable-next-line no-throw-literal\r\n            throw \"HDR Bad header format, no size\";\r\n        }\r\n        width = parseInt(match[2]);\r\n        height = parseInt(match[1]);\r\n\r\n        if (width < 8 || width > 0x7fff) {\r\n            // eslint-disable-next-line no-throw-literal\r\n            throw \"HDR Bad header format, unsupported size\";\r\n        }\r\n\r\n        lineIndex += line.length + 1;\r\n\r\n        return {\r\n            height: height,\r\n            width: width,\r\n            dataPosition: lineIndex,\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Returns the cubemap information (each faces texture data) extracted from an RGBE texture.\r\n     * This RGBE texture needs to store the information as a panorama.\r\n     *\r\n     * More information on this format are available here:\r\n     * https://en.wikipedia.org/wiki/RGBE_image_format\r\n     *\r\n     * @param buffer The binary file stored in an array buffer.\r\n     * @param size The expected size of the extracted cubemap.\r\n     * @param supersample enable supersampling the cubemap (default: false)\r\n     * @returns The Cube Map information.\r\n     */\r\n    public static GetCubeMapTextureData(buffer: ArrayBuffer, size: number, supersample = false): CubeMapInfo {\r\n        const uint8array = new Uint8Array(buffer);\r\n        const hdrInfo = this.RGBE_ReadHeader(uint8array);\r\n        const data = this.RGBE_ReadPixels(uint8array, hdrInfo);\r\n\r\n        const cubeMapData = PanoramaToCubeMapTools.ConvertPanoramaToCubemap(data, hdrInfo.width, hdrInfo.height, size, supersample);\r\n\r\n        return cubeMapData;\r\n    }\r\n\r\n    /**\r\n     * Returns the pixels data extracted from an RGBE texture.\r\n     * This pixels will be stored left to right up to down in the R G B order in one array.\r\n     *\r\n     * More information on this format are available here:\r\n     * https://en.wikipedia.org/wiki/RGBE_image_format\r\n     *\r\n     * @param uint8array The binary file stored in an array buffer.\r\n     * @param hdrInfo The header information of the file.\r\n     * @returns The pixels data in RGB right to left up to down order.\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    public static RGBE_ReadPixels(uint8array: Uint8Array, hdrInfo: HDRInfo): Float32Array {\r\n        return this._RGBEReadPixelsRLE(uint8array, hdrInfo);\r\n    }\r\n\r\n    private static _RGBEReadPixelsRLE(uint8array: Uint8Array, hdrInfo: HDRInfo): Float32Array {\r\n        let num_scanlines = hdrInfo.height;\r\n        const scanline_width = hdrInfo.width;\r\n\r\n        let a: number, b: number, c: number, d: number, count: number;\r\n        let dataIndex = hdrInfo.dataPosition;\r\n        let index = 0,\r\n            endIndex = 0,\r\n            i = 0;\r\n\r\n        const scanLineArrayBuffer = new ArrayBuffer(scanline_width * 4); // four channel R G B E\r\n        const scanLineArray = new Uint8Array(scanLineArrayBuffer);\r\n\r\n        // 3 channels of 4 bytes per pixel in float.\r\n        const resultBuffer = new ArrayBuffer(hdrInfo.width * hdrInfo.height * 4 * 3);\r\n        const resultArray = new Float32Array(resultBuffer);\r\n\r\n        // read in each successive scanline\r\n        while (num_scanlines > 0) {\r\n            a = uint8array[dataIndex++];\r\n            b = uint8array[dataIndex++];\r\n            c = uint8array[dataIndex++];\r\n            d = uint8array[dataIndex++];\r\n\r\n            if (a != 2 || b != 2 || c & 0x80 || hdrInfo.width < 8 || hdrInfo.width > 32767) {\r\n                return this._RGBEReadPixelsNOTRLE(uint8array, hdrInfo);\r\n            }\r\n\r\n            if (((c << 8) | d) != scanline_width) {\r\n                // eslint-disable-next-line no-throw-literal\r\n                throw \"HDR Bad header format, wrong scan line width\";\r\n            }\r\n\r\n            index = 0;\r\n\r\n            // read each of the four channels for the scanline into the buffer\r\n            for (i = 0; i < 4; i++) {\r\n                endIndex = (i + 1) * scanline_width;\r\n\r\n                while (index < endIndex) {\r\n                    a = uint8array[dataIndex++];\r\n                    b = uint8array[dataIndex++];\r\n\r\n                    if (a > 128) {\r\n                        // a run of the same value\r\n                        count = a - 128;\r\n                        if (count == 0 || count > endIndex - index) {\r\n                            // eslint-disable-next-line no-throw-literal\r\n                            throw \"HDR Bad Format, bad scanline data (run)\";\r\n                        }\r\n\r\n                        while (count-- > 0) {\r\n                            scanLineArray[index++] = b;\r\n                        }\r\n                    } else {\r\n                        // a non-run\r\n                        count = a;\r\n                        if (count == 0 || count > endIndex - index) {\r\n                            // eslint-disable-next-line no-throw-literal\r\n                            throw \"HDR Bad Format, bad scanline data (non-run)\";\r\n                        }\r\n\r\n                        scanLineArray[index++] = b;\r\n                        if (--count > 0) {\r\n                            for (let j = 0; j < count; j++) {\r\n                                scanLineArray[index++] = uint8array[dataIndex++];\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n\r\n            // now convert data from buffer into floats\r\n            for (i = 0; i < scanline_width; i++) {\r\n                a = scanLineArray[i];\r\n                b = scanLineArray[i + scanline_width];\r\n                c = scanLineArray[i + 2 * scanline_width];\r\n                d = scanLineArray[i + 3 * scanline_width];\r\n\r\n                this._Rgbe2float(resultArray, a, b, c, d, (hdrInfo.height - num_scanlines) * scanline_width * 3 + i * 3);\r\n            }\r\n\r\n            num_scanlines--;\r\n        }\r\n\r\n        return resultArray;\r\n    }\r\n\r\n    private static _RGBEReadPixelsNOTRLE(uint8array: Uint8Array, hdrInfo: HDRInfo): Float32Array {\r\n        // this file is not run length encoded\r\n        // read values sequentially\r\n\r\n        let num_scanlines = hdrInfo.height;\r\n        const scanline_width = hdrInfo.width;\r\n\r\n        let a: number, b: number, c: number, d: number, i: number;\r\n        let dataIndex = hdrInfo.dataPosition;\r\n\r\n        // 3 channels of 4 bytes per pixel in float.\r\n        const resultBuffer = new ArrayBuffer(hdrInfo.width * hdrInfo.height * 4 * 3);\r\n        const resultArray = new Float32Array(resultBuffer);\r\n\r\n        // read in each successive scanline\r\n        while (num_scanlines > 0) {\r\n            for (i = 0; i < hdrInfo.width; i++) {\r\n                a = uint8array[dataIndex++];\r\n                b = uint8array[dataIndex++];\r\n                c = uint8array[dataIndex++];\r\n                d = uint8array[dataIndex++];\r\n\r\n                this._Rgbe2float(resultArray, a, b, c, d, (hdrInfo.height - num_scanlines) * scanline_width * 3 + i * 3);\r\n            }\r\n\r\n            num_scanlines--;\r\n        }\r\n\r\n        return resultArray;\r\n    }\r\n}\r\n", "import { HDRTools } from \"../../../Misc/HighDynamicRange/hdr\";\r\nimport { Engine } from \"../../../Engines/engine\";\r\nimport type { InternalTexture } from \"../../../Materials/Textures/internalTexture\";\r\nimport type { IInternalTextureLoader } from \"../../../Materials/Textures/internalTextureLoader\";\r\nimport { Constants } from \"../../../Engines/constants\";\r\n\r\n/**\r\n * Implementation of the HDR Texture Loader.\r\n * @internal\r\n */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nexport class _HDRTextureLoader implements IInternalTextureLoader {\r\n    /**\r\n     * Defines whether the loader supports cascade loading the different faces.\r\n     */\r\n    public readonly supportCascades = false;\r\n\r\n    /**\r\n     * This returns if the loader support the current file information.\r\n     * @param extension defines the file extension of the file being loaded\r\n     * @returns true if the loader can load the specified file\r\n     */\r\n    public canLoad(extension: string): boolean {\r\n        return extension.endsWith(\".hdr\");\r\n    }\r\n\r\n    /**\r\n     * Uploads the cube texture data to the WebGL texture. It has already been bound.\r\n     */\r\n    public loadCubeData(): void {\r\n        // eslint-disable-next-line no-throw-literal\r\n        throw \".env not supported in Cube.\";\r\n    }\r\n\r\n    /**\r\n     * Uploads the 2D texture data to the WebGL texture. It has already been bound once in the callback.\r\n     * @param data contains the texture data\r\n     * @param texture defines the BabylonJS internal texture\r\n     * @param callback defines the method to call once ready to upload\r\n     */\r\n    public loadData(\r\n        data: ArrayBufferView,\r\n        texture: InternalTexture,\r\n        callback: (width: number, height: number, loadMipmap: boolean, isCompressed: boolean, done: () => void) => void\r\n    ): void {\r\n        const uint8array = new Uint8Array(data.buffer, data.byteOffset, data.byteLength);\r\n        const hdrInfo = HDRTools.RGBE_ReadHeader(uint8array);\r\n        const pixelsDataRGB32 = HDRTools.RGBE_ReadPixels(uint8array, hdrInfo);\r\n\r\n        const pixels = hdrInfo.width * hdrInfo.height;\r\n        const pixelsDataRGBA32 = new Float32Array(pixels * 4);\r\n        for (let i = 0; i < pixels; i += 1) {\r\n            pixelsDataRGBA32[i * 4] = pixelsDataRGB32[i * 3];\r\n            pixelsDataRGBA32[i * 4 + 1] = pixelsDataRGB32[i * 3 + 1];\r\n            pixelsDataRGBA32[i * 4 + 2] = pixelsDataRGB32[i * 3 + 2];\r\n            pixelsDataRGBA32[i * 4 + 3] = 1;\r\n        }\r\n\r\n        callback(hdrInfo.width, hdrInfo.height, texture.generateMipMaps, false, () => {\r\n            const engine = texture.getEngine();\r\n            texture.type = Constants.TEXTURETYPE_FLOAT;\r\n            texture.format = Constants.TEXTUREFORMAT_RGBA;\r\n            texture._gammaSpace = false;\r\n            engine._uploadDataToTextureDirectly(texture, pixelsDataRGBA32);\r\n        });\r\n    }\r\n}\r\n\r\n// Register the loader.\r\nEngine._TextureLoaders.push(new _HDRTextureLoader());\r\n", "/* eslint-disable @typescript-eslint/naming-convention */\r\nimport type { Nullable } from \"core/types\";\r\nimport { Tools } from \"./tools\";\r\nimport type { BasisFileInfo, BasisTranscodeConfiguration } from \"./basis\";\r\n\r\n// WorkerGlobalScope\r\ndeclare function importScripts(...urls: string[]): void;\r\ndeclare function postMessage(message: any, transfer?: any[]): void;\r\ndeclare let BASIS: any;\r\n/**\r\n * The worker function that gets converted to a blob url to pass into a worker.\r\n * To be used if a developer wants to create their own worker instance and inject it instead of using the default worker.\r\n */\r\nexport function workerFunction(): void {\r\n    const _BASIS_FORMAT = {\r\n        cTFETC1: 0,\r\n        cTFETC2: 1,\r\n        cTFBC1: 2,\r\n        cTFBC3: 3,\r\n        cTFBC4: 4,\r\n        cTFBC5: 5,\r\n        cTFBC7: 6,\r\n        cTFPVRTC1_4_RGB: 8,\r\n        cTFPVRTC1_4_RGBA: 9,\r\n        cTFASTC_4x4: 10,\r\n        cTFATC_RGB: 11,\r\n        cTFATC_RGBA_INTERPOLATED_ALPHA: 12,\r\n        cTFRGBA32: 13,\r\n        cTFRGB565: 14,\r\n        cTFBGR565: 15,\r\n        cTFRGBA4444: 16,\r\n        cTFFXT1_RGB: 17,\r\n        cTFPVRTC2_4_RGB: 18,\r\n        cTFPVRTC2_4_RGBA: 19,\r\n        cTFETC2_EAC_R11: 20,\r\n        cTFETC2_EAC_RG11: 21,\r\n    };\r\n    let transcoderModulePromise: Nullable<PromiseLike<any>> = null;\r\n    onmessage = (event) => {\r\n        if (event.data.action === \"init\") {\r\n            // Load the transcoder if it hasn't been yet\r\n            if (event.data.url) {\r\n                // make sure we loaded the script correctly\r\n                try {\r\n                    importScripts(event.data.url);\r\n                } catch (e) {\r\n                    postMessage({ action: \"error\", error: e });\r\n                }\r\n            }\r\n            if (!transcoderModulePromise) {\r\n                transcoderModulePromise = BASIS({\r\n                    // Override wasm binary\r\n                    wasmBinary: event.data.wasmBinary,\r\n                });\r\n            }\r\n            if (transcoderModulePromise !== null) {\r\n                transcoderModulePromise.then((m) => {\r\n                    BASIS = m;\r\n                    m.initializeBasis();\r\n                    postMessage({ action: \"init\" });\r\n                });\r\n            }\r\n        } else if (event.data.action === \"transcode\") {\r\n            // Transcode the basis image and return the resulting pixels\r\n            const config: BasisTranscodeConfiguration = event.data.config;\r\n            const imgData = event.data.imageData;\r\n            const loadedFile = new BASIS.BasisFile(imgData);\r\n            const fileInfo = GetFileInfo(loadedFile);\r\n            let format = event.data.ignoreSupportedFormats ? null : GetSupportedTranscodeFormat(event.data.config, fileInfo);\r\n\r\n            let needsConversion = false;\r\n            if (format === null) {\r\n                needsConversion = true;\r\n                format = fileInfo.hasAlpha ? _BASIS_FORMAT.cTFBC3 : _BASIS_FORMAT.cTFBC1;\r\n            }\r\n\r\n            // Begin transcode\r\n            let success = true;\r\n            if (!loadedFile.startTranscoding()) {\r\n                success = false;\r\n            }\r\n\r\n            const buffers: Array<any> = [];\r\n            for (let imageIndex = 0; imageIndex < fileInfo.images.length; imageIndex++) {\r\n                if (!success) {\r\n                    break;\r\n                }\r\n                const image = fileInfo.images[imageIndex];\r\n                if (config.loadSingleImage === undefined || config.loadSingleImage === imageIndex) {\r\n                    let mipCount = image.levels.length;\r\n                    if (config.loadMipmapLevels === false) {\r\n                        mipCount = 1;\r\n                    }\r\n                    for (let levelIndex = 0; levelIndex < mipCount; levelIndex++) {\r\n                        const levelInfo = image.levels[levelIndex];\r\n\r\n                        const pixels = TranscodeLevel(loadedFile, imageIndex, levelIndex, format!, needsConversion);\r\n                        if (!pixels) {\r\n                            success = false;\r\n                            break;\r\n                        }\r\n                        levelInfo.transcodedPixels = pixels;\r\n                        buffers.push(levelInfo.transcodedPixels.buffer);\r\n                    }\r\n                }\r\n            }\r\n            // Close file\r\n            loadedFile.close();\r\n            loadedFile.delete();\r\n\r\n            if (needsConversion) {\r\n                format = -1;\r\n            }\r\n            if (!success) {\r\n                postMessage({ action: \"transcode\", success: success, id: event.data.id });\r\n            } else {\r\n                postMessage({ action: \"transcode\", success: success, id: event.data.id, fileInfo: fileInfo, format: format }, buffers);\r\n            }\r\n        }\r\n    };\r\n\r\n    /**\r\n     * Detects the supported transcode format for the file\r\n     * @param config transcode config\r\n     * @param fileInfo info about the file\r\n     * @returns the chosed format or null if none are supported\r\n     */\r\n    function GetSupportedTranscodeFormat(config: BasisTranscodeConfiguration, fileInfo: BasisFileInfo): Nullable<number> {\r\n        let format = null;\r\n        if (config.supportedCompressionFormats) {\r\n            if (config.supportedCompressionFormats.astc) {\r\n                format = _BASIS_FORMAT.cTFASTC_4x4;\r\n            } else if (config.supportedCompressionFormats.bc7) {\r\n                format = _BASIS_FORMAT.cTFBC7;\r\n            } else if (config.supportedCompressionFormats.s3tc) {\r\n                format = fileInfo.hasAlpha ? _BASIS_FORMAT.cTFBC3 : _BASIS_FORMAT.cTFBC1;\r\n            } else if (config.supportedCompressionFormats.pvrtc) {\r\n                format = fileInfo.hasAlpha ? _BASIS_FORMAT.cTFPVRTC1_4_RGBA : _BASIS_FORMAT.cTFPVRTC1_4_RGB;\r\n            } else if (config.supportedCompressionFormats.etc2) {\r\n                format = _BASIS_FORMAT.cTFETC2;\r\n            } else if (config.supportedCompressionFormats.etc1) {\r\n                format = _BASIS_FORMAT.cTFETC1;\r\n            } else {\r\n                format = _BASIS_FORMAT.cTFRGB565;\r\n            }\r\n        }\r\n        return format;\r\n    }\r\n\r\n    /**\r\n     * Retrieves information about the basis file eg. dimensions\r\n     * @param basisFile the basis file to get the info from\r\n     * @returns information about the basis file\r\n     */\r\n    function GetFileInfo(basisFile: any): BasisFileInfo {\r\n        const hasAlpha = basisFile.getHasAlpha();\r\n        const imageCount = basisFile.getNumImages();\r\n        const images = [];\r\n        for (let i = 0; i < imageCount; i++) {\r\n            const imageInfo = {\r\n                levels: [] as Array<any>,\r\n            };\r\n            const levelCount = basisFile.getNumLevels(i);\r\n            for (let level = 0; level < levelCount; level++) {\r\n                const levelInfo = {\r\n                    width: basisFile.getImageWidth(i, level),\r\n                    height: basisFile.getImageHeight(i, level),\r\n                };\r\n                imageInfo.levels.push(levelInfo);\r\n            }\r\n            images.push(imageInfo);\r\n        }\r\n        const info = { hasAlpha, images };\r\n        return info;\r\n    }\r\n\r\n    function TranscodeLevel(loadedFile: any, imageIndex: number, levelIndex: number, format: number, convertToRgb565: boolean): Nullable<Uint8Array | Uint16Array> {\r\n        const dstSize = loadedFile.getImageTranscodedSizeInBytes(imageIndex, levelIndex, format);\r\n        let dst: Uint8Array | Uint16Array = new Uint8Array(dstSize);\r\n        if (!loadedFile.transcodeImage(dst, imageIndex, levelIndex, format, 1, 0)) {\r\n            return null;\r\n        }\r\n        // If no supported format is found, load as dxt and convert to rgb565\r\n        if (convertToRgb565) {\r\n            const alignedWidth = (loadedFile.getImageWidth(imageIndex, levelIndex) + 3) & ~3;\r\n            const alignedHeight = (loadedFile.getImageHeight(imageIndex, levelIndex) + 3) & ~3;\r\n            dst = ConvertDxtToRgb565(dst, 0, alignedWidth, alignedHeight);\r\n        }\r\n        return dst;\r\n    }\r\n\r\n    /**\r\n     * From https://github.com/BinomialLLC/basis_universal/blob/master/webgl/texture/dxt-to-rgb565.js\r\n     * An unoptimized version of dxtToRgb565.  Also, the floating\r\n     * point math used to compute the colors actually results in\r\n     * slightly different colors compared to hardware DXT decoders.\r\n     * @param src dxt src pixels\r\n     * @param srcByteOffset offset for the start of src\r\n     * @param  width aligned width of the image\r\n     * @param  height aligned height of the image\r\n     * @returns the converted pixels\r\n     */\r\n    function ConvertDxtToRgb565(src: Uint8Array, srcByteOffset: number, width: number, height: number): Uint16Array {\r\n        const c = new Uint16Array(4);\r\n        const dst = new Uint16Array(width * height);\r\n\r\n        const blockWidth = width / 4;\r\n        const blockHeight = height / 4;\r\n        for (let blockY = 0; blockY < blockHeight; blockY++) {\r\n            for (let blockX = 0; blockX < blockWidth; blockX++) {\r\n                const i = srcByteOffset + 8 * (blockY * blockWidth + blockX);\r\n                c[0] = src[i] | (src[i + 1] << 8);\r\n                c[1] = src[i + 2] | (src[i + 3] << 8);\r\n                c[2] =\r\n                    ((2 * (c[0] & 0x1f) + 1 * (c[1] & 0x1f)) / 3) |\r\n                    (((2 * (c[0] & 0x7e0) + 1 * (c[1] & 0x7e0)) / 3) & 0x7e0) |\r\n                    (((2 * (c[0] & 0xf800) + 1 * (c[1] & 0xf800)) / 3) & 0xf800);\r\n                c[3] =\r\n                    ((2 * (c[1] & 0x1f) + 1 * (c[0] & 0x1f)) / 3) |\r\n                    (((2 * (c[1] & 0x7e0) + 1 * (c[0] & 0x7e0)) / 3) & 0x7e0) |\r\n                    (((2 * (c[1] & 0xf800) + 1 * (c[0] & 0xf800)) / 3) & 0xf800);\r\n                for (let row = 0; row < 4; row++) {\r\n                    const m = src[i + 4 + row];\r\n                    let dstI = (blockY * 4 + row) * width + blockX * 4;\r\n                    dst[dstI++] = c[m & 0x3];\r\n                    dst[dstI++] = c[(m >> 2) & 0x3];\r\n                    dst[dstI++] = c[(m >> 4) & 0x3];\r\n                    dst[dstI++] = c[(m >> 6) & 0x3];\r\n                }\r\n            }\r\n        }\r\n        return dst;\r\n    }\r\n}\r\n\r\n/**\r\n * Initialize a web worker with the basis transcoder\r\n * @param worker the worker to initialize\r\n * @param wasmBinary the wasm binary to load into the worker\r\n * @param moduleUrl the url to the basis transcoder module\r\n * @returns a promise that resolves when the worker is initialized\r\n */\r\nexport function initializeWebWorker(worker: Worker, wasmBinary: ArrayBuffer, moduleUrl?: string) {\r\n    return new Promise<Worker>((res, reject) => {\r\n        const initHandler = (msg: any) => {\r\n            if (msg.data.action === \"init\") {\r\n                worker!.removeEventListener(\"message\", initHandler);\r\n                res(worker!);\r\n            } else if (msg.data.action === \"error\") {\r\n                reject(msg.data.error || \"error initializing worker\");\r\n            }\r\n        };\r\n        worker.addEventListener(\"message\", initHandler);\r\n        // we can use transferable objects here because the worker will own the ArrayBuffer\r\n        worker.postMessage({ action: \"init\", url: moduleUrl ? Tools.GetBabylonScriptURL(moduleUrl) : undefined, wasmBinary }, [wasmBinary]);\r\n    });\r\n}\r\n", "/* eslint-disable @typescript-eslint/naming-convention */\r\nimport type { Nullable } from \"../types\";\r\nimport { Tools } from \"./tools\";\r\nimport { Texture } from \"../Materials/Textures/texture\";\r\nimport { InternalTexture, InternalTextureSource } from \"../Materials/Textures/internalTexture\";\r\nimport { Scalar } from \"../Maths/math.scalar\";\r\nimport { Constants } from \"../Engines/constants\";\r\nimport type { Engine } from \"../Engines/engine\";\r\nimport { initializeWebWorker, workerFunction } from \"./basisWorker\";\r\n\r\n/**\r\n * Info about the .basis files\r\n */\r\nexport class BasisFileInfo {\r\n    /**\r\n     * If the file has alpha\r\n     */\r\n    public hasAlpha: boolean;\r\n    /**\r\n     * Info about each image of the basis file\r\n     */\r\n    public images: Array<{ levels: Array<{ width: number; height: number; transcodedPixels: ArrayBufferView }> }>;\r\n}\r\n\r\n/**\r\n * Result of transcoding a basis file\r\n */\r\nclass TranscodeResult {\r\n    /**\r\n     * Info about the .basis file\r\n     */\r\n    public fileInfo: BasisFileInfo;\r\n    /**\r\n     * Format to use when loading the file\r\n     */\r\n    public format: number;\r\n}\r\n\r\n/**\r\n * Configuration options for the Basis transcoder\r\n */\r\nexport class BasisTranscodeConfiguration {\r\n    /**\r\n     * Supported compression formats used to determine the supported output format of the transcoder\r\n     */\r\n    supportedCompressionFormats?: {\r\n        /**\r\n         * etc1 compression format\r\n         */\r\n        etc1?: boolean;\r\n        /**\r\n         * s3tc compression format\r\n         */\r\n        s3tc?: boolean;\r\n        /**\r\n         * pvrtc compression format\r\n         */\r\n        pvrtc?: boolean;\r\n        /**\r\n         * etc2 compression format\r\n         */\r\n        etc2?: boolean;\r\n        /**\r\n         * astc compression format\r\n         */\r\n        astc?: boolean;\r\n        /**\r\n         * bc7 compression format\r\n         */\r\n        bc7?: boolean;\r\n    };\r\n    /**\r\n     * If mipmap levels should be loaded for transcoded images (Default: true)\r\n     */\r\n    loadMipmapLevels?: boolean;\r\n    /**\r\n     * Index of a single image to load (Default: all images)\r\n     */\r\n    loadSingleImage?: number;\r\n}\r\n\r\n/**\r\n * @internal\r\n * Enum of basis transcoder formats\r\n */\r\nenum BASIS_FORMATS {\r\n    cTFETC1 = 0,\r\n    cTFETC2 = 1,\r\n    cTFBC1 = 2,\r\n    cTFBC3 = 3,\r\n    cTFBC4 = 4,\r\n    cTFBC5 = 5,\r\n    cTFBC7 = 6,\r\n    cTFPVRTC1_4_RGB = 8,\r\n    cTFPVRTC1_4_RGBA = 9,\r\n    cTFASTC_4x4 = 10,\r\n    cTFATC_RGB = 11,\r\n    cTFATC_RGBA_INTERPOLATED_ALPHA = 12,\r\n    cTFRGBA32 = 13,\r\n    cTFRGB565 = 14,\r\n    cTFBGR565 = 15,\r\n    cTFRGBA4444 = 16,\r\n    cTFFXT1_RGB = 17,\r\n    cTFPVRTC2_4_RGB = 18,\r\n    cTFPVRTC2_4_RGBA = 19,\r\n    cTFETC2_EAC_R11 = 20,\r\n    cTFETC2_EAC_RG11 = 21,\r\n}\r\n\r\n/**\r\n * Used to load .Basis files\r\n * See https://github.com/BinomialLLC/basis_universal/tree/master/webgl\r\n */\r\nexport const BasisToolsOptions = {\r\n    /**\r\n     * URL to use when loading the basis transcoder\r\n     */\r\n    JSModuleURL: `${Tools._DefaultCdnUrl}/basisTranscoder/1/basis_transcoder.js`,\r\n    /**\r\n     * URL to use when loading the wasm module for the transcoder\r\n     */\r\n    WasmModuleURL: `${Tools._DefaultCdnUrl}/basisTranscoder/1/basis_transcoder.wasm`,\r\n};\r\n\r\n/**\r\n * Get the internal format to be passed to texImage2D corresponding to the .basis format value\r\n * @param basisFormat format chosen from GetSupportedTranscodeFormat\r\n * @param engine\r\n * @returns internal format corresponding to the Basis format\r\n */\r\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\r\nexport const GetInternalFormatFromBasisFormat = (basisFormat: number, engine: Engine) => {\r\n    let format;\r\n    switch (basisFormat) {\r\n        case BASIS_FORMATS.cTFETC1:\r\n            format = Constants.TEXTUREFORMAT_COMPRESSED_RGB_ETC1_WEBGL;\r\n            break;\r\n        case BASIS_FORMATS.cTFBC1:\r\n            format = Constants.TEXTUREFORMAT_COMPRESSED_RGB_S3TC_DXT1;\r\n            break;\r\n        case BASIS_FORMATS.cTFBC4:\r\n            format = Constants.TEXTUREFORMAT_COMPRESSED_RGBA_S3TC_DXT5;\r\n            break;\r\n        case BASIS_FORMATS.cTFASTC_4x4:\r\n            format = Constants.TEXTUREFORMAT_COMPRESSED_RGBA_ASTC_4x4;\r\n            break;\r\n        case BASIS_FORMATS.cTFETC2:\r\n            format = Constants.TEXTUREFORMAT_COMPRESSED_RGBA8_ETC2_EAC;\r\n            break;\r\n        case BASIS_FORMATS.cTFBC7:\r\n            format = Constants.TEXTUREFORMAT_COMPRESSED_RGBA_BPTC_UNORM;\r\n            break;\r\n    }\r\n\r\n    if (format === undefined) {\r\n        // eslint-disable-next-line no-throw-literal\r\n        throw \"The chosen Basis transcoder format is not currently supported\";\r\n    }\r\n\r\n    return format;\r\n};\r\n\r\nlet _WorkerPromise: Nullable<Promise<Worker>> = null;\r\nlet _Worker: Nullable<Worker> = null;\r\nlet _actionId = 0;\r\nconst _IgnoreSupportedFormats = false;\r\nconst _CreateWorkerAsync = () => {\r\n    if (!_WorkerPromise) {\r\n        _WorkerPromise = new Promise((res, reject) => {\r\n            if (_Worker) {\r\n                res(_Worker);\r\n            } else {\r\n                Tools.LoadFileAsync(Tools.GetBabylonScriptURL(BasisToolsOptions.WasmModuleURL))\r\n                    .then((wasmBinary) => {\r\n                        if (typeof URL !== \"function\") {\r\n                            return reject(\"Basis transcoder requires an environment with a URL constructor\");\r\n                        }\r\n                        const workerBlobUrl = URL.createObjectURL(new Blob([`(${workerFunction})()`], { type: \"application/javascript\" }));\r\n                        _Worker = new Worker(workerBlobUrl);\r\n                        initializeWebWorker(_Worker, wasmBinary, BasisToolsOptions.JSModuleURL).then(res, reject);\r\n                    })\r\n                    .catch(reject);\r\n            }\r\n        });\r\n    }\r\n    return _WorkerPromise;\r\n};\r\n\r\n/**\r\n * Set the worker to use for transcoding\r\n * @param worker The worker that will be used for transcoding\r\n */\r\nexport const SetBasisTranscoderWorker = (worker: Worker) => {\r\n    _Worker = worker;\r\n};\r\n\r\n/**\r\n * Transcodes a loaded image file to compressed pixel data\r\n * @param data image data to transcode\r\n * @param config configuration options for the transcoding\r\n * @returns a promise resulting in the transcoded image\r\n */\r\nexport const TranscodeAsync = (data: ArrayBuffer | ArrayBufferView, config: BasisTranscodeConfiguration): Promise<TranscodeResult> => {\r\n    const dataView = data instanceof ArrayBuffer ? new Uint8Array(data) : data;\r\n\r\n    return new Promise((res, rej) => {\r\n        _CreateWorkerAsync().then(\r\n            () => {\r\n                const actionId = _actionId++;\r\n                const messageHandler = (msg: any) => {\r\n                    if (msg.data.action === \"transcode\" && msg.data.id === actionId) {\r\n                        _Worker!.removeEventListener(\"message\", messageHandler);\r\n                        if (!msg.data.success) {\r\n                            rej(\"Transcode is not supported on this device\");\r\n                        } else {\r\n                            res(msg.data);\r\n                        }\r\n                    }\r\n                };\r\n                _Worker!.addEventListener(\"message\", messageHandler);\r\n\r\n                const dataViewCopy = new Uint8Array(dataView.byteLength);\r\n                dataViewCopy.set(new Uint8Array(dataView.buffer, dataView.byteOffset, dataView.byteLength));\r\n                _Worker!.postMessage({ action: \"transcode\", id: actionId, imageData: dataViewCopy, config: config, ignoreSupportedFormats: _IgnoreSupportedFormats }, [\r\n                    dataViewCopy.buffer,\r\n                ]);\r\n            },\r\n            (error) => {\r\n                rej(error);\r\n            }\r\n        );\r\n    });\r\n};\r\n\r\n/**\r\n * Binds a texture according to its underlying target.\r\n * @param texture texture to bind\r\n * @param engine the engine to bind the texture in\r\n */\r\nconst BindTexture = (texture: InternalTexture, engine: Engine): void => {\r\n    let target: GLenum = engine._gl?.TEXTURE_2D;\r\n    if (texture.isCube) {\r\n        target = engine._gl?.TEXTURE_CUBE_MAP;\r\n    }\r\n\r\n    engine._bindTextureDirectly(target, texture, true);\r\n};\r\n\r\n/**\r\n * Loads a texture from the transcode result\r\n * @param texture texture load to\r\n * @param transcodeResult the result of transcoding the basis file to load from\r\n */\r\nexport const LoadTextureFromTranscodeResult = (texture: InternalTexture, transcodeResult: TranscodeResult) => {\r\n    const engine = texture.getEngine() as Engine;\r\n    for (let i = 0; i < transcodeResult.fileInfo.images.length; i++) {\r\n        const rootImage = transcodeResult.fileInfo.images[i].levels[0];\r\n        texture._invertVScale = texture.invertY;\r\n        if (transcodeResult.format === -1 || transcodeResult.format === BASIS_FORMATS.cTFRGB565) {\r\n            // No compatable compressed format found, fallback to RGB\r\n            texture.type = Constants.TEXTURETYPE_UNSIGNED_SHORT_5_6_5;\r\n            texture.format = Constants.TEXTUREFORMAT_RGB;\r\n\r\n            if (engine._features.basisNeedsPOT && (Scalar.Log2(rootImage.width) % 1 !== 0 || Scalar.Log2(rootImage.height) % 1 !== 0)) {\r\n                // Create non power of two texture\r\n                const source = new InternalTexture(engine, InternalTextureSource.Temp);\r\n\r\n                texture._invertVScale = texture.invertY;\r\n                source.type = Constants.TEXTURETYPE_UNSIGNED_SHORT_5_6_5;\r\n                source.format = Constants.TEXTUREFORMAT_RGB;\r\n                // Fallback requires aligned width/height\r\n                source.width = (rootImage.width + 3) & ~3;\r\n                source.height = (rootImage.height + 3) & ~3;\r\n                BindTexture(source, engine);\r\n                engine._uploadDataToTextureDirectly(source, new Uint16Array(rootImage.transcodedPixels.buffer), i, 0, Constants.TEXTUREFORMAT_RGB, true);\r\n\r\n                // Resize to power of two\r\n                engine._rescaleTexture(source, texture, engine.scenes[0], engine._getInternalFormat(Constants.TEXTUREFORMAT_RGB), () => {\r\n                    engine._releaseTexture(source);\r\n                    BindTexture(texture, engine);\r\n                });\r\n            } else {\r\n                // Fallback is already inverted\r\n                texture._invertVScale = !texture.invertY;\r\n\r\n                // Upload directly\r\n                texture.width = (rootImage.width + 3) & ~3;\r\n                texture.height = (rootImage.height + 3) & ~3;\r\n                texture.samplingMode = Constants.TEXTURE_LINEAR_LINEAR;\r\n                BindTexture(texture, engine);\r\n                engine._uploadDataToTextureDirectly(texture, new Uint16Array(rootImage.transcodedPixels.buffer), i, 0, Constants.TEXTUREFORMAT_RGB, true);\r\n            }\r\n        } else {\r\n            texture.width = rootImage.width;\r\n            texture.height = rootImage.height;\r\n            texture.generateMipMaps = transcodeResult.fileInfo.images[i].levels.length > 1;\r\n\r\n            const format = BasisTools.GetInternalFormatFromBasisFormat(transcodeResult.format!, engine);\r\n            texture.format = format;\r\n\r\n            BindTexture(texture, engine);\r\n\r\n            // Upload all mip levels in the file\r\n            transcodeResult.fileInfo.images[i].levels.forEach((level: any, index: number) => {\r\n                engine._uploadCompressedDataToTextureDirectly(texture, format, level.width, level.height, level.transcodedPixels, i, index);\r\n            });\r\n\r\n            if (engine._features.basisNeedsPOT && (Scalar.Log2(texture.width) % 1 !== 0 || Scalar.Log2(texture.height) % 1 !== 0)) {\r\n                Tools.Warn(\r\n                    \"Loaded .basis texture width and height are not a power of two. Texture wrapping will be set to Texture.CLAMP_ADDRESSMODE as other modes are not supported with non power of two dimensions in webGL 1.\"\r\n                );\r\n                texture._cachedWrapU = Texture.CLAMP_ADDRESSMODE;\r\n                texture._cachedWrapV = Texture.CLAMP_ADDRESSMODE;\r\n            }\r\n        }\r\n    }\r\n};\r\n\r\n/**\r\n * Used to load .Basis files\r\n * See https://github.com/BinomialLLC/basis_universal/tree/master/webgl\r\n */\r\nexport const BasisTools = {\r\n    /**\r\n     * URL to use when loading the basis transcoder\r\n     */\r\n    JSModuleURL: BasisToolsOptions.JSModuleURL,\r\n    /**\r\n     * URL to use when loading the wasm module for the transcoder\r\n     */\r\n    WasmModuleURL: BasisToolsOptions.WasmModuleURL,\r\n\r\n    /**\r\n     * Get the internal format to be passed to texImage2D corresponding to the .basis format value\r\n     * @param basisFormat format chosen from GetSupportedTranscodeFormat\r\n     * @returns internal format corresponding to the Basis format\r\n     */\r\n    GetInternalFormatFromBasisFormat,\r\n\r\n    /**\r\n     * Transcodes a loaded image file to compressed pixel data\r\n     * @param data image data to transcode\r\n     * @param config configuration options for the transcoding\r\n     * @returns a promise resulting in the transcoded image\r\n     */\r\n    TranscodeAsync,\r\n\r\n    /**\r\n     * Loads a texture from the transcode result\r\n     * @param texture texture load to\r\n     * @param transcodeResult the result of transcoding the basis file to load from\r\n     */\r\n    LoadTextureFromTranscodeResult,\r\n};\r\n\r\nObject.defineProperty(BasisTools, \"JSModuleURL\", {\r\n    get: function (this: null) {\r\n        return BasisToolsOptions.JSModuleURL;\r\n    },\r\n    set: function (this: null, value: string) {\r\n        BasisToolsOptions.JSModuleURL = value;\r\n    },\r\n});\r\n\r\nObject.defineProperty(BasisTools, \"WasmModuleURL\", {\r\n    get: function (this: null) {\r\n        return BasisToolsOptions.WasmModuleURL;\r\n    },\r\n    set: function (this: null, value: string) {\r\n        BasisToolsOptions.WasmModuleURL = value;\r\n    },\r\n});\r\n", "import type { Nullable } from \"../../../types\";\r\nimport { Engine } from \"../../../Engines/engine\";\r\nimport type { InternalTexture } from \"../../../Materials/Textures/internalTexture\";\r\nimport type { IInternalTextureLoader } from \"../../../Materials/Textures/internalTextureLoader\";\r\nimport { LoadTextureFromTranscodeResult, TranscodeAsync } from \"../../../Misc/basis\";\r\nimport { Tools } from \"../../../Misc/tools\";\r\n\r\n/**\r\n * Loader for .basis file format\r\n */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nexport class _BasisTextureLoader implements IInternalTextureLoader {\r\n    /**\r\n     * Defines whether the loader supports cascade loading the different faces.\r\n     */\r\n    public readonly supportCascades = false;\r\n\r\n    /**\r\n     * This returns if the loader support the current file information.\r\n     * @param extension defines the file extension of the file being loaded\r\n     * @returns true if the loader can load the specified file\r\n     */\r\n    public canLoad(extension: string): boolean {\r\n        return extension.endsWith(\".basis\");\r\n    }\r\n\r\n    /**\r\n     * Uploads the cube texture data to the WebGL texture. It has already been bound.\r\n     * @param data contains the texture data\r\n     * @param texture defines the BabylonJS internal texture\r\n     * @param createPolynomials will be true if polynomials have been requested\r\n     * @param onLoad defines the callback to trigger once the texture is ready\r\n     * @param onError defines the callback to trigger in case of error\r\n     */\r\n    public loadCubeData(\r\n        data: ArrayBufferView | ArrayBufferView[],\r\n        texture: InternalTexture,\r\n        createPolynomials: boolean,\r\n        onLoad: Nullable<(data?: any) => void>,\r\n        onError: Nullable<(message?: string, exception?: any) => void>\r\n    ): void {\r\n        if (Array.isArray(data)) {\r\n            return;\r\n        }\r\n        const caps = texture.getEngine().getCaps();\r\n        const transcodeConfig = {\r\n            supportedCompressionFormats: {\r\n                etc1: caps.etc1 ? true : false,\r\n                s3tc: caps.s3tc ? true : false,\r\n                pvrtc: caps.pvrtc ? true : false,\r\n                etc2: caps.etc2 ? true : false,\r\n                astc: caps.astc ? true : false,\r\n                bc7: caps.bptc ? true : false,\r\n            },\r\n        };\r\n        TranscodeAsync(data, transcodeConfig)\r\n            .then((result) => {\r\n                const hasMipmap = result.fileInfo.images[0].levels.length > 1 && texture.generateMipMaps;\r\n                LoadTextureFromTranscodeResult(texture, result);\r\n                (texture.getEngine() as Engine)._setCubeMapTextureParams(texture, hasMipmap);\r\n                texture.isReady = true;\r\n                texture.onLoadedObservable.notifyObservers(texture);\r\n                texture.onLoadedObservable.clear();\r\n                if (onLoad) {\r\n                    onLoad();\r\n                }\r\n            })\r\n            .catch((err) => {\r\n                const errorMessage = \"Failed to transcode Basis file, transcoding may not be supported on this device\";\r\n                Tools.Warn(errorMessage);\r\n                texture.isReady = true;\r\n                if (onError) {\r\n                    onError(err);\r\n                }\r\n            });\r\n    }\r\n\r\n    /**\r\n     * Uploads the 2D texture data to the WebGL texture. It has already been bound once in the callback.\r\n     * @param data contains the texture data\r\n     * @param texture defines the BabylonJS internal texture\r\n     * @param callback defines the method to call once ready to upload\r\n     */\r\n    public loadData(\r\n        data: ArrayBufferView,\r\n        texture: InternalTexture,\r\n        callback: (width: number, height: number, loadMipmap: boolean, isCompressed: boolean, done: () => void, failedLoading?: boolean) => void\r\n    ): void {\r\n        const caps = texture.getEngine().getCaps();\r\n        const transcodeConfig = {\r\n            supportedCompressionFormats: {\r\n                etc1: caps.etc1 ? true : false,\r\n                s3tc: caps.s3tc ? true : false,\r\n                pvrtc: caps.pvrtc ? true : false,\r\n                etc2: caps.etc2 ? true : false,\r\n                astc: caps.astc ? true : false,\r\n                bc7: caps.bptc ? true : false,\r\n            },\r\n        };\r\n        TranscodeAsync(data, transcodeConfig)\r\n            .then((result) => {\r\n                const rootImage = result.fileInfo.images[0].levels[0];\r\n                const hasMipmap = result.fileInfo.images[0].levels.length > 1 && texture.generateMipMaps;\r\n                callback(rootImage.width, rootImage.height, hasMipmap, result.format !== -1, () => {\r\n                    LoadTextureFromTranscodeResult(texture, result);\r\n                });\r\n            })\r\n            .catch((err) => {\r\n                Tools.Warn(\"Failed to transcode Basis file, transcoding may not be supported on this device\");\r\n                Tools.Warn(`Failed to transcode Basis file: ${err}`);\r\n                callback(0, 0, false, false, () => {}, true);\r\n            });\r\n    }\r\n}\r\n\r\n// Register the loader.\r\nEngine._TextureLoaders.push(new _BasisTextureLoader());\r\n"],
  "mappings": "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",
  "names": ["SourceTextureFormat", "TranscodeTarget", "EngineFormat", "data", "workerFunction", "initializeWebWorker", "BASIS_FORMATS", "workerFunction", "initializeWebWorker"]
}
