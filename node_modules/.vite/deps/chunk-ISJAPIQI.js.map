{
  "version": 3,
  "sources": ["../../../dev/core/src/Materials/materialDefines.ts", "../../../dev/core/src/Collisions/intersectionInfo.ts", "../../../dev/core/src/Culling/boundingBox.ts", "../../../dev/core/src/Culling/boundingSphere.ts", "../../../dev/core/src/Culling/boundingInfo.ts", "../../../dev/core/src/Maths/math.functions.ts", "../../../dev/core/src/Meshes/subMesh.ts", "../../../dev/core/src/Materials/materialPluginEvent.ts", "../../../dev/core/src/Materials/clipPlaneMaterialHelper.ts", "../../../dev/core/src/Materials/materialHelper.functions.ts", "../../../dev/core/src/Materials/materialStencilState.ts", "../../../dev/core/src/Materials/material.ts", "../../../dev/core/src/Materials/pushMaterial.ts", "../../../dev/core/src/Materials/effectFallbacks.ts", "../../../dev/core/src/Shaders/ShadersInclude/lightFragmentDeclaration.ts", "../../../dev/core/src/Shaders/ShadersInclude/lightUboDeclaration.ts", "../../../dev/core/src/Shaders/ShadersInclude/lightsFragmentFunctions.ts", "../../../dev/core/src/Shaders/ShadersInclude/shadowsFragmentFunctions.ts", "../../../dev/core/src/Shaders/ShadersInclude/clipPlaneFragmentDeclaration.ts", "../../../dev/core/src/Shaders/ShadersInclude/logDepthDeclaration.ts", "../../../dev/core/src/Shaders/ShadersInclude/fogFragmentDeclaration.ts", "../../../dev/core/src/Shaders/ShadersInclude/clipPlaneFragment.ts", "../../../dev/core/src/Shaders/ShadersInclude/lightFragment.ts", "../../../dev/core/src/Shaders/ShadersInclude/logDepthFragment.ts", "../../../dev/core/src/Shaders/ShadersInclude/fogFragment.ts", "../../../dev/core/src/Shaders/ShadersInclude/bonesDeclaration.ts", "../../../dev/core/src/Shaders/ShadersInclude/bakedVertexAnimationDeclaration.ts", "../../../dev/core/src/Shaders/ShadersInclude/instancesDeclaration.ts", "../../../dev/core/src/Shaders/ShadersInclude/clipPlaneVertexDeclaration.ts", "../../../dev/core/src/Shaders/ShadersInclude/fogVertexDeclaration.ts", "../../../dev/core/src/Shaders/ShadersInclude/instancesVertex.ts", "../../../dev/core/src/Shaders/ShadersInclude/bonesVertex.ts", "../../../dev/core/src/Shaders/ShadersInclude/bakedVertexAnimation.ts", "../../../dev/core/src/Shaders/ShadersInclude/clipPlaneVertex.ts", "../../../dev/core/src/Shaders/ShadersInclude/logDepthVertex.ts", "../../../dev/core/src/Shaders/ShadersInclude/fogVertex.ts", "../../../dev/core/src/Shaders/ShadersInclude/shadowsVertex.ts"],
  "sourcesContent": ["/**\r\n * Manages the defines for the Material\r\n */\r\nexport class MaterialDefines {\r\n    /** @internal */\r\n    protected _keys: string[] = [];\r\n    private _isDirty = true;\r\n    /** @internal */\r\n    public _renderId: number;\r\n\r\n    /** @internal */\r\n    public _areLightsDirty = true;\r\n    /** @internal */\r\n    public _areLightsDisposed = false;\r\n    /** @internal */\r\n    public _areAttributesDirty = true;\r\n    /** @internal */\r\n    public _areTexturesDirty = true;\r\n    /** @internal */\r\n    public _areFresnelDirty = true;\r\n    /** @internal */\r\n    public _areMiscDirty = true;\r\n    /** @internal */\r\n    public _arePrePassDirty = true;\r\n    /** @internal */\r\n    public _areImageProcessingDirty = true;\r\n\r\n    /** @internal */\r\n    public _normals = false;\r\n    /** @internal */\r\n    public _uvs = false;\r\n\r\n    /** @internal */\r\n    public _needNormals = false;\r\n    /** @internal */\r\n    public _needUVs = false;\r\n\r\n    protected _externalProperties?: { [name: string]: { type: string; default: any } };\r\n\r\n    [id: string]: any;\r\n\r\n    /**\r\n     * Creates a new instance\r\n     * @param externalProperties list of external properties to inject into the object\r\n     */\r\n    constructor(externalProperties?: { [name: string]: { type: string; default: any } }) {\r\n        this._externalProperties = externalProperties;\r\n\r\n        // Initialize External Properties\r\n        if (externalProperties) {\r\n            for (const prop in externalProperties) {\r\n                if (Object.prototype.hasOwnProperty.call(externalProperties, prop)) {\r\n                    this._setDefaultValue(prop);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Specifies if the material needs to be re-calculated\r\n     */\r\n    public get isDirty(): boolean {\r\n        return this._isDirty;\r\n    }\r\n\r\n    /**\r\n     * Marks the material to indicate that it has been re-calculated\r\n     */\r\n    public markAsProcessed() {\r\n        this._isDirty = false;\r\n        this._areAttributesDirty = false;\r\n        this._areTexturesDirty = false;\r\n        this._areFresnelDirty = false;\r\n        this._areLightsDirty = false;\r\n        this._areLightsDisposed = false;\r\n        this._areMiscDirty = false;\r\n        this._arePrePassDirty = false;\r\n        this._areImageProcessingDirty = false;\r\n    }\r\n\r\n    /**\r\n     * Marks the material to indicate that it needs to be re-calculated\r\n     */\r\n    public markAsUnprocessed() {\r\n        this._isDirty = true;\r\n    }\r\n\r\n    /**\r\n     * Marks the material to indicate all of its defines need to be re-calculated\r\n     */\r\n    public markAllAsDirty() {\r\n        this._areTexturesDirty = true;\r\n        this._areAttributesDirty = true;\r\n        this._areLightsDirty = true;\r\n        this._areFresnelDirty = true;\r\n        this._areMiscDirty = true;\r\n        this._arePrePassDirty = false;\r\n        this._areImageProcessingDirty = true;\r\n        this._isDirty = true;\r\n    }\r\n\r\n    /**\r\n     * Marks the material to indicate that image processing needs to be re-calculated\r\n     */\r\n    public markAsImageProcessingDirty() {\r\n        this._areImageProcessingDirty = true;\r\n        this._isDirty = true;\r\n    }\r\n\r\n    /**\r\n     * Marks the material to indicate the lights need to be re-calculated\r\n     * @param disposed Defines whether the light is dirty due to dispose or not\r\n     */\r\n    public markAsLightDirty(disposed = false) {\r\n        this._areLightsDirty = true;\r\n        this._areLightsDisposed = this._areLightsDisposed || disposed;\r\n        this._isDirty = true;\r\n    }\r\n\r\n    /**\r\n     * Marks the attribute state as changed\r\n     */\r\n    public markAsAttributesDirty() {\r\n        this._areAttributesDirty = true;\r\n        this._isDirty = true;\r\n    }\r\n\r\n    /**\r\n     * Marks the texture state as changed\r\n     */\r\n    public markAsTexturesDirty() {\r\n        this._areTexturesDirty = true;\r\n        this._isDirty = true;\r\n    }\r\n\r\n    /**\r\n     * Marks the fresnel state as changed\r\n     */\r\n    public markAsFresnelDirty() {\r\n        this._areFresnelDirty = true;\r\n        this._isDirty = true;\r\n    }\r\n\r\n    /**\r\n     * Marks the misc state as changed\r\n     */\r\n    public markAsMiscDirty() {\r\n        this._areMiscDirty = true;\r\n        this._isDirty = true;\r\n    }\r\n\r\n    /**\r\n     * Marks the prepass state as changed\r\n     */\r\n    public markAsPrePassDirty() {\r\n        this._arePrePassDirty = true;\r\n        this._isDirty = true;\r\n    }\r\n\r\n    /**\r\n     * Rebuilds the material defines\r\n     */\r\n    public rebuild() {\r\n        this._keys.length = 0;\r\n\r\n        for (const key of Object.keys(this)) {\r\n            if (key[0] === \"_\") {\r\n                continue;\r\n            }\r\n\r\n            this._keys.push(key);\r\n        }\r\n\r\n        if (this._externalProperties) {\r\n            for (const name in this._externalProperties) {\r\n                if (this._keys.indexOf(name) === -1) {\r\n                    this._keys.push(name);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Specifies if two material defines are equal\r\n     * @param other - A material define instance to compare to\r\n     * @returns - Boolean indicating if the material defines are equal (true) or not (false)\r\n     */\r\n    public isEqual(other: MaterialDefines): boolean {\r\n        if (this._keys.length !== other._keys.length) {\r\n            return false;\r\n        }\r\n\r\n        for (let index = 0; index < this._keys.length; index++) {\r\n            const prop = this._keys[index];\r\n\r\n            if ((<any>this)[prop] !== (<any>other)[prop]) {\r\n                return false;\r\n            }\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Clones this instance's defines to another instance\r\n     * @param other - material defines to clone values to\r\n     */\r\n    public cloneTo(other: MaterialDefines): void {\r\n        if (this._keys.length !== other._keys.length) {\r\n            other._keys = this._keys.slice(0);\r\n        }\r\n\r\n        for (let index = 0; index < this._keys.length; index++) {\r\n            const prop = this._keys[index];\r\n\r\n            (<any>other)[prop] = (<any>this)[prop];\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Resets the material define values\r\n     */\r\n    public reset(): void {\r\n        this._keys.forEach((prop) => this._setDefaultValue(prop));\r\n    }\r\n\r\n    private _setDefaultValue(prop: string): void {\r\n        const type = this._externalProperties?.[prop]?.type ?? typeof (<any>this)[prop];\r\n        const defValue = this._externalProperties?.[prop]?.default;\r\n\r\n        switch (type) {\r\n            case \"number\":\r\n                (<any>this)[prop] = defValue ?? 0;\r\n                break;\r\n            case \"string\":\r\n                (<any>this)[prop] = defValue ?? \"\";\r\n                break;\r\n            default:\r\n                (<any>this)[prop] = defValue ?? false;\r\n                break;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Converts the material define values to a string\r\n     * @returns - String of material define information\r\n     */\r\n    public toString(): string {\r\n        let result = \"\";\r\n        for (let index = 0; index < this._keys.length; index++) {\r\n            const prop = this._keys[index];\r\n            const value = (<any>this)[prop];\r\n            const type = typeof value;\r\n\r\n            switch (type) {\r\n                case \"number\":\r\n                case \"string\":\r\n                    result += \"#define \" + prop + \" \" + value + \"\\n\";\r\n                    break;\r\n                default:\r\n                    if (value) {\r\n                        result += \"#define \" + prop + \"\\n\";\r\n                    }\r\n                    break;\r\n            }\r\n        }\r\n\r\n        return result;\r\n    }\r\n}\r\n", "import type { Nullable } from \"../types\";\r\n\r\n/**\r\n * @internal\r\n */\r\nexport class IntersectionInfo {\r\n    public faceId = 0;\r\n    public subMeshId = 0;\r\n\r\n    constructor(\r\n        public bu: Nullable<number>,\r\n        public bv: Nullable<number>,\r\n        public distance: number\r\n    ) {}\r\n}\r\n", "import type { DeepImmutable, Nullable } from \"../types\";\r\nimport { ArrayTools } from \"../Misc/arrayTools\";\r\nimport { Matrix, Vector3 } from \"../Maths/math.vector\";\r\nimport type { BoundingSphere } from \"../Culling/boundingSphere\";\r\n\r\nimport type { ICullable } from \"./boundingInfo\";\r\nimport { Epsilon } from \"../Maths/math.constants\";\r\nimport type { Plane } from \"../Maths/math.plane\";\r\n\r\nimport type { DrawWrapper } from \"../Materials/drawWrapper\";\r\n\r\n/**\r\n * Class used to store bounding box information\r\n */\r\nexport class BoundingBox implements ICullable {\r\n    /**\r\n     * Gets the 8 vectors representing the bounding box in local space\r\n     */\r\n    public readonly vectors: Vector3[] = ArrayTools.BuildArray(8, Vector3.Zero);\r\n    /**\r\n     * Gets the center of the bounding box in local space\r\n     */\r\n    public readonly center: Vector3 = Vector3.Zero();\r\n    /**\r\n     * Gets the center of the bounding box in world space\r\n     */\r\n    public readonly centerWorld: Vector3 = Vector3.Zero();\r\n    /**\r\n     * Gets the extend size in local space\r\n     */\r\n    public readonly extendSize: Vector3 = Vector3.Zero();\r\n    /**\r\n     * Gets the extend size in world space\r\n     */\r\n    public readonly extendSizeWorld: Vector3 = Vector3.Zero();\r\n    /**\r\n     * Gets the OBB (object bounding box) directions\r\n     */\r\n    public readonly directions: Vector3[] = ArrayTools.BuildArray(3, Vector3.Zero);\r\n    /**\r\n     * Gets the 8 vectors representing the bounding box in world space\r\n     */\r\n    public readonly vectorsWorld: Vector3[] = ArrayTools.BuildArray(8, Vector3.Zero);\r\n    /**\r\n     * Gets the minimum vector in world space\r\n     */\r\n    public readonly minimumWorld: Vector3 = Vector3.Zero();\r\n    /**\r\n     * Gets the maximum vector in world space\r\n     */\r\n    public readonly maximumWorld: Vector3 = Vector3.Zero();\r\n    /**\r\n     * Gets the minimum vector in local space\r\n     */\r\n    public readonly minimum: Vector3 = Vector3.Zero();\r\n    /**\r\n     * Gets the maximum vector in local space\r\n     */\r\n    public readonly maximum: Vector3 = Vector3.Zero();\r\n\r\n    private _worldMatrix: DeepImmutable<Matrix>;\r\n    private static readonly _TmpVector3 = ArrayTools.BuildArray(3, Vector3.Zero);\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _tag: number;\r\n\r\n    /** @internal */\r\n    public _drawWrapperFront: Nullable<DrawWrapper> = null;\r\n    /** @internal */\r\n    public _drawWrapperBack: Nullable<DrawWrapper> = null;\r\n\r\n    /**\r\n     * Creates a new bounding box\r\n     * @param min defines the minimum vector (in local space)\r\n     * @param max defines the maximum vector (in local space)\r\n     * @param worldMatrix defines the new world matrix\r\n     */\r\n    constructor(min: DeepImmutable<Vector3>, max: DeepImmutable<Vector3>, worldMatrix?: DeepImmutable<Matrix>) {\r\n        this.reConstruct(min, max, worldMatrix);\r\n    }\r\n\r\n    // Methods\r\n\r\n    /**\r\n     * Recreates the entire bounding box from scratch as if we call the constructor in place\r\n     * @param min defines the new minimum vector (in local space)\r\n     * @param max defines the new maximum vector (in local space)\r\n     * @param worldMatrix defines the new world matrix\r\n     */\r\n    public reConstruct(min: DeepImmutable<Vector3>, max: DeepImmutable<Vector3>, worldMatrix?: DeepImmutable<Matrix>) {\r\n        const minX = min.x,\r\n            minY = min.y,\r\n            minZ = min.z,\r\n            maxX = max.x,\r\n            maxY = max.y,\r\n            maxZ = max.z;\r\n        const vectors = this.vectors;\r\n\r\n        this.minimum.copyFromFloats(minX, minY, minZ);\r\n        this.maximum.copyFromFloats(maxX, maxY, maxZ);\r\n        vectors[0].copyFromFloats(minX, minY, minZ);\r\n        vectors[1].copyFromFloats(maxX, maxY, maxZ);\r\n        vectors[2].copyFromFloats(maxX, minY, minZ);\r\n        vectors[3].copyFromFloats(minX, maxY, minZ);\r\n        vectors[4].copyFromFloats(minX, minY, maxZ);\r\n        vectors[5].copyFromFloats(maxX, maxY, minZ);\r\n        vectors[6].copyFromFloats(minX, maxY, maxZ);\r\n        vectors[7].copyFromFloats(maxX, minY, maxZ);\r\n\r\n        // OBB\r\n        max.addToRef(min, this.center).scaleInPlace(0.5);\r\n        max.subtractToRef(min, this.extendSize).scaleInPlace(0.5);\r\n\r\n        this._worldMatrix = worldMatrix || Matrix.IdentityReadOnly;\r\n\r\n        this._update(this._worldMatrix);\r\n    }\r\n\r\n    /**\r\n     * Scale the current bounding box by applying a scale factor\r\n     * @param factor defines the scale factor to apply\r\n     * @returns the current bounding box\r\n     */\r\n    public scale(factor: number): BoundingBox {\r\n        const tmpVectors = BoundingBox._TmpVector3;\r\n        const diff = this.maximum.subtractToRef(this.minimum, tmpVectors[0]);\r\n        const len = diff.length();\r\n        diff.normalizeFromLength(len);\r\n        const distance = len * factor;\r\n        const newRadius = diff.scaleInPlace(distance * 0.5);\r\n\r\n        const min = this.center.subtractToRef(newRadius, tmpVectors[1]);\r\n        const max = this.center.addToRef(newRadius, tmpVectors[2]);\r\n\r\n        this.reConstruct(min, max, this._worldMatrix);\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Gets the world matrix of the bounding box\r\n     * @returns a matrix\r\n     */\r\n    public getWorldMatrix(): DeepImmutable<Matrix> {\r\n        return this._worldMatrix;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _update(world: DeepImmutable<Matrix>): void {\r\n        const minWorld = this.minimumWorld;\r\n        const maxWorld = this.maximumWorld;\r\n        const directions = this.directions;\r\n        const vectorsWorld = this.vectorsWorld;\r\n        const vectors = this.vectors;\r\n\r\n        if (!world.isIdentity()) {\r\n            minWorld.setAll(Number.MAX_VALUE);\r\n            maxWorld.setAll(-Number.MAX_VALUE);\r\n\r\n            for (let index = 0; index < 8; ++index) {\r\n                const v = vectorsWorld[index];\r\n                Vector3.TransformCoordinatesToRef(vectors[index], world, v);\r\n                minWorld.minimizeInPlace(v);\r\n                maxWorld.maximizeInPlace(v);\r\n            }\r\n\r\n            // Extend\r\n            maxWorld.subtractToRef(minWorld, this.extendSizeWorld).scaleInPlace(0.5);\r\n            maxWorld.addToRef(minWorld, this.centerWorld).scaleInPlace(0.5);\r\n        } else {\r\n            minWorld.copyFrom(this.minimum);\r\n            maxWorld.copyFrom(this.maximum);\r\n            for (let index = 0; index < 8; ++index) {\r\n                vectorsWorld[index].copyFrom(vectors[index]);\r\n            }\r\n\r\n            // Extend\r\n            this.extendSizeWorld.copyFrom(this.extendSize);\r\n            this.centerWorld.copyFrom(this.center);\r\n        }\r\n\r\n        Vector3.FromArrayToRef(world.m, 0, directions[0]);\r\n        Vector3.FromArrayToRef(world.m, 4, directions[1]);\r\n        Vector3.FromArrayToRef(world.m, 8, directions[2]);\r\n\r\n        this._worldMatrix = world;\r\n    }\r\n\r\n    /**\r\n     * Tests if the bounding box is intersecting the frustum planes\r\n     * @param frustumPlanes defines the frustum planes to test\r\n     * @returns true if there is an intersection\r\n     */\r\n    public isInFrustum(frustumPlanes: Array<DeepImmutable<Plane>>): boolean {\r\n        return BoundingBox.IsInFrustum(this.vectorsWorld, frustumPlanes);\r\n    }\r\n\r\n    /**\r\n     * Tests if the bounding box is entirely inside the frustum planes\r\n     * @param frustumPlanes defines the frustum planes to test\r\n     * @returns true if there is an inclusion\r\n     */\r\n    public isCompletelyInFrustum(frustumPlanes: Array<DeepImmutable<Plane>>): boolean {\r\n        return BoundingBox.IsCompletelyInFrustum(this.vectorsWorld, frustumPlanes);\r\n    }\r\n\r\n    /**\r\n     * Tests if a point is inside the bounding box\r\n     * @param point defines the point to test\r\n     * @returns true if the point is inside the bounding box\r\n     */\r\n    public intersectsPoint(point: DeepImmutable<Vector3>): boolean {\r\n        const min = this.minimumWorld;\r\n        const max = this.maximumWorld;\r\n        const minX = min.x,\r\n            minY = min.y,\r\n            minZ = min.z,\r\n            maxX = max.x,\r\n            maxY = max.y,\r\n            maxZ = max.z;\r\n        const pointX = point.x,\r\n            pointY = point.y,\r\n            pointZ = point.z;\r\n        const delta = -Epsilon;\r\n\r\n        if (maxX - pointX < delta || delta > pointX - minX) {\r\n            return false;\r\n        }\r\n\r\n        if (maxY - pointY < delta || delta > pointY - minY) {\r\n            return false;\r\n        }\r\n\r\n        if (maxZ - pointZ < delta || delta > pointZ - minZ) {\r\n            return false;\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Tests if the bounding box intersects with a bounding sphere\r\n     * @param sphere defines the sphere to test\r\n     * @returns true if there is an intersection\r\n     */\r\n    public intersectsSphere(sphere: DeepImmutable<BoundingSphere>): boolean {\r\n        return BoundingBox.IntersectsSphere(this.minimumWorld, this.maximumWorld, sphere.centerWorld, sphere.radiusWorld);\r\n    }\r\n\r\n    /**\r\n     * Tests if the bounding box intersects with a box defined by a min and max vectors\r\n     * @param min defines the min vector to use\r\n     * @param max defines the max vector to use\r\n     * @returns true if there is an intersection\r\n     */\r\n    public intersectsMinMax(min: DeepImmutable<Vector3>, max: DeepImmutable<Vector3>): boolean {\r\n        const myMin = this.minimumWorld;\r\n        const myMax = this.maximumWorld;\r\n        const myMinX = myMin.x,\r\n            myMinY = myMin.y,\r\n            myMinZ = myMin.z,\r\n            myMaxX = myMax.x,\r\n            myMaxY = myMax.y,\r\n            myMaxZ = myMax.z;\r\n        const minX = min.x,\r\n            minY = min.y,\r\n            minZ = min.z,\r\n            maxX = max.x,\r\n            maxY = max.y,\r\n            maxZ = max.z;\r\n        if (myMaxX < minX || myMinX > maxX) {\r\n            return false;\r\n        }\r\n\r\n        if (myMaxY < minY || myMinY > maxY) {\r\n            return false;\r\n        }\r\n\r\n        if (myMaxZ < minZ || myMinZ > maxZ) {\r\n            return false;\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Disposes the resources of the class\r\n     */\r\n    public dispose(): void {\r\n        this._drawWrapperFront?.dispose();\r\n        this._drawWrapperBack?.dispose();\r\n    }\r\n\r\n    // Statics\r\n\r\n    /**\r\n     * Tests if two bounding boxes are intersections\r\n     * @param box0 defines the first box to test\r\n     * @param box1 defines the second box to test\r\n     * @returns true if there is an intersection\r\n     */\r\n    public static Intersects(box0: DeepImmutable<BoundingBox>, box1: DeepImmutable<BoundingBox>): boolean {\r\n        return box0.intersectsMinMax(box1.minimumWorld, box1.maximumWorld);\r\n    }\r\n\r\n    /**\r\n     * Tests if a bounding box defines by a min/max vectors intersects a sphere\r\n     * @param minPoint defines the minimum vector of the bounding box\r\n     * @param maxPoint defines the maximum vector of the bounding box\r\n     * @param sphereCenter defines the sphere center\r\n     * @param sphereRadius defines the sphere radius\r\n     * @returns true if there is an intersection\r\n     */\r\n    public static IntersectsSphere(minPoint: DeepImmutable<Vector3>, maxPoint: DeepImmutable<Vector3>, sphereCenter: DeepImmutable<Vector3>, sphereRadius: number): boolean {\r\n        const vector = BoundingBox._TmpVector3[0];\r\n        Vector3.ClampToRef(sphereCenter, minPoint, maxPoint, vector);\r\n        const num = Vector3.DistanceSquared(sphereCenter, vector);\r\n        return num <= sphereRadius * sphereRadius;\r\n    }\r\n\r\n    /**\r\n     * Tests if a bounding box defined with 8 vectors is entirely inside frustum planes\r\n     * @param boundingVectors defines an array of 8 vectors representing a bounding box\r\n     * @param frustumPlanes defines the frustum planes to test\r\n     * @returns true if there is an inclusion\r\n     */\r\n    public static IsCompletelyInFrustum(boundingVectors: Array<DeepImmutable<Vector3>>, frustumPlanes: Array<DeepImmutable<Plane>>): boolean {\r\n        for (let p = 0; p < 6; ++p) {\r\n            const frustumPlane = frustumPlanes[p];\r\n            for (let i = 0; i < 8; ++i) {\r\n                if (frustumPlane.dotCoordinate(boundingVectors[i]) < 0) {\r\n                    return false;\r\n                }\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Tests if a bounding box defined with 8 vectors intersects frustum planes\r\n     * @param boundingVectors defines an array of 8 vectors representing a bounding box\r\n     * @param frustumPlanes defines the frustum planes to test\r\n     * @returns true if there is an intersection\r\n     */\r\n    public static IsInFrustum(boundingVectors: Array<DeepImmutable<Vector3>>, frustumPlanes: Array<DeepImmutable<Plane>>): boolean {\r\n        for (let p = 0; p < 6; ++p) {\r\n            let canReturnFalse = true;\r\n            const frustumPlane = frustumPlanes[p];\r\n            for (let i = 0; i < 8; ++i) {\r\n                if (frustumPlane.dotCoordinate(boundingVectors[i]) >= 0) {\r\n                    canReturnFalse = false;\r\n                    break;\r\n                }\r\n            }\r\n            if (canReturnFalse) {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n}\r\n", "import type { DeepImmutable } from \"../types\";\r\nimport { ArrayTools } from \"../Misc/arrayTools\";\r\nimport { Matrix, Vector3 } from \"../Maths/math.vector\";\r\nimport type { Plane } from \"../Maths/math.plane\";\r\n\r\n/**\r\n * Class used to store bounding sphere information\r\n */\r\nexport class BoundingSphere {\r\n    /**\r\n     * Gets the center of the bounding sphere in local space\r\n     */\r\n    public readonly center = Vector3.Zero();\r\n    /**\r\n     * Radius of the bounding sphere in local space\r\n     */\r\n    public radius: number;\r\n    /**\r\n     * Gets the center of the bounding sphere in world space\r\n     */\r\n    public readonly centerWorld = Vector3.Zero();\r\n    /**\r\n     * Radius of the bounding sphere in world space\r\n     */\r\n    public radiusWorld: number;\r\n    /**\r\n     * Gets the minimum vector in local space\r\n     */\r\n    public readonly minimum = Vector3.Zero();\r\n    /**\r\n     * Gets the maximum vector in local space\r\n     */\r\n    public readonly maximum = Vector3.Zero();\r\n\r\n    private _worldMatrix: DeepImmutable<Matrix>;\r\n    private static readonly _TmpVector3 = ArrayTools.BuildArray(3, Vector3.Zero);\r\n\r\n    /**\r\n     * Creates a new bounding sphere\r\n     * @param min defines the minimum vector (in local space)\r\n     * @param max defines the maximum vector (in local space)\r\n     * @param worldMatrix defines the new world matrix\r\n     */\r\n    constructor(min: DeepImmutable<Vector3>, max: DeepImmutable<Vector3>, worldMatrix?: DeepImmutable<Matrix>) {\r\n        this.reConstruct(min, max, worldMatrix);\r\n    }\r\n\r\n    /**\r\n     * Recreates the entire bounding sphere from scratch as if we call the constructor in place\r\n     * @param min defines the new minimum vector (in local space)\r\n     * @param max defines the new maximum vector (in local space)\r\n     * @param worldMatrix defines the new world matrix\r\n     */\r\n    public reConstruct(min: DeepImmutable<Vector3>, max: DeepImmutable<Vector3>, worldMatrix?: DeepImmutable<Matrix>) {\r\n        this.minimum.copyFrom(min);\r\n        this.maximum.copyFrom(max);\r\n\r\n        const distance = Vector3.Distance(min, max);\r\n\r\n        max.addToRef(min, this.center).scaleInPlace(0.5);\r\n        this.radius = distance * 0.5;\r\n\r\n        this._update(worldMatrix || Matrix.IdentityReadOnly);\r\n    }\r\n\r\n    /**\r\n     * Scale the current bounding sphere by applying a scale factor\r\n     * @param factor defines the scale factor to apply\r\n     * @returns the current bounding box\r\n     */\r\n    public scale(factor: number): BoundingSphere {\r\n        const newRadius = this.radius * factor;\r\n        const tmpVectors = BoundingSphere._TmpVector3;\r\n        const tempRadiusVector = tmpVectors[0].setAll(newRadius);\r\n        const min = this.center.subtractToRef(tempRadiusVector, tmpVectors[1]);\r\n        const max = this.center.addToRef(tempRadiusVector, tmpVectors[2]);\r\n\r\n        this.reConstruct(min, max, this._worldMatrix);\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Gets the world matrix of the bounding box\r\n     * @returns a matrix\r\n     */\r\n    public getWorldMatrix(): DeepImmutable<Matrix> {\r\n        return this._worldMatrix;\r\n    }\r\n\r\n    // Methods\r\n    /**\r\n     * @internal\r\n     */\r\n    public _update(worldMatrix: DeepImmutable<Matrix>): void {\r\n        if (!worldMatrix.isIdentity()) {\r\n            Vector3.TransformCoordinatesToRef(this.center, worldMatrix, this.centerWorld);\r\n            const tempVector = BoundingSphere._TmpVector3[0];\r\n            Vector3.TransformNormalFromFloatsToRef(1.0, 1.0, 1.0, worldMatrix, tempVector);\r\n            this.radiusWorld = Math.max(Math.abs(tempVector.x), Math.abs(tempVector.y), Math.abs(tempVector.z)) * this.radius;\r\n        } else {\r\n            this.centerWorld.copyFrom(this.center);\r\n            this.radiusWorld = this.radius;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Tests if the bounding sphere is intersecting the frustum planes\r\n     * @param frustumPlanes defines the frustum planes to test\r\n     * @returns true if there is an intersection\r\n     */\r\n    public isInFrustum(frustumPlanes: Array<DeepImmutable<Plane>>): boolean {\r\n        const center = this.centerWorld;\r\n        const radius = this.radiusWorld;\r\n        for (let i = 0; i < 6; i++) {\r\n            if (frustumPlanes[i].dotCoordinate(center) <= -radius) {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Tests if the bounding sphere center is in between the frustum planes.\r\n     * Used for optimistic fast inclusion.\r\n     * @param frustumPlanes defines the frustum planes to test\r\n     * @returns true if the sphere center is in between the frustum planes\r\n     */\r\n    public isCenterInFrustum(frustumPlanes: Array<DeepImmutable<Plane>>): boolean {\r\n        const center = this.centerWorld;\r\n        for (let i = 0; i < 6; i++) {\r\n            if (frustumPlanes[i].dotCoordinate(center) < 0) {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Tests if a point is inside the bounding sphere\r\n     * @param point defines the point to test\r\n     * @returns true if the point is inside the bounding sphere\r\n     */\r\n    public intersectsPoint(point: DeepImmutable<Vector3>): boolean {\r\n        const squareDistance = Vector3.DistanceSquared(this.centerWorld, point);\r\n        if (this.radiusWorld * this.radiusWorld < squareDistance) {\r\n            return false;\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    // Statics\r\n    /**\r\n     * Checks if two sphere intersect\r\n     * @param sphere0 sphere 0\r\n     * @param sphere1 sphere 1\r\n     * @returns true if the spheres intersect\r\n     */\r\n    public static Intersects(sphere0: DeepImmutable<BoundingSphere>, sphere1: DeepImmutable<BoundingSphere>): boolean {\r\n        const squareDistance = Vector3.DistanceSquared(sphere0.centerWorld, sphere1.centerWorld);\r\n        const radiusSum = sphere0.radiusWorld + sphere1.radiusWorld;\r\n\r\n        if (radiusSum * radiusSum < squareDistance) {\r\n            return false;\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Creates a sphere from a center and a radius\r\n     * @param center The center\r\n     * @param radius radius\r\n     * @param matrix Optional worldMatrix\r\n     * @returns The sphere\r\n     */\r\n    public static CreateFromCenterAndRadius(center: DeepImmutable<Vector3>, radius: number, matrix?: DeepImmutable<Matrix>): BoundingSphere {\r\n        this._TmpVector3[0].copyFrom(center);\r\n        this._TmpVector3[1].copyFromFloats(0, 0, radius);\r\n        this._TmpVector3[2].copyFrom(center);\r\n        this._TmpVector3[0].addInPlace(this._TmpVector3[1]);\r\n        this._TmpVector3[2].subtractInPlace(this._TmpVector3[1]);\r\n\r\n        const sphere = new BoundingSphere(this._TmpVector3[0], this._TmpVector3[2]);\r\n\r\n        if (matrix) {\r\n            sphere._worldMatrix = matrix;\r\n        } else {\r\n            sphere._worldMatrix = Matrix.Identity();\r\n        }\r\n\r\n        return sphere;\r\n    }\r\n}\r\n", "import type { DeepImmutable } from \"../types\";\r\nimport { ArrayTools } from \"../Misc/arrayTools\";\r\nimport type { Matrix } from \"../Maths/math.vector\";\r\nimport { TmpVectors } from \"../Maths/math.vector\";\r\nimport { Vector3 } from \"../Maths/math.vector\";\r\nimport { Constants } from \"../Engines/constants\";\r\nimport { BoundingBox } from \"./boundingBox\";\r\nimport { BoundingSphere } from \"./boundingSphere\";\r\nimport type { Plane } from \"../Maths/math.plane\";\r\n\r\nimport type { Collider } from \"../Collisions/collider\";\r\n\r\nconst _result0 = { min: 0, max: 0 };\r\nconst _result1 = { min: 0, max: 0 };\r\nconst computeBoxExtents = (axis: DeepImmutable<Vector3>, box: DeepImmutable<BoundingBox>, result: { min: number; max: number }) => {\r\n    const p = Vector3.Dot(box.centerWorld, axis);\r\n\r\n    const r0 = Math.abs(Vector3.Dot(box.directions[0], axis)) * box.extendSize.x;\r\n    const r1 = Math.abs(Vector3.Dot(box.directions[1], axis)) * box.extendSize.y;\r\n    const r2 = Math.abs(Vector3.Dot(box.directions[2], axis)) * box.extendSize.z;\r\n\r\n    const r = r0 + r1 + r2;\r\n    result.min = p - r;\r\n    result.max = p + r;\r\n};\r\n\r\nconst axisOverlap = (axis: DeepImmutable<Vector3>, box0: DeepImmutable<BoundingBox>, box1: DeepImmutable<BoundingBox>): boolean => {\r\n    computeBoxExtents(axis, box0, _result0);\r\n    computeBoxExtents(axis, box1, _result1);\r\n    return !(_result0.min > _result1.max || _result1.min > _result0.max);\r\n};\r\n\r\n/**\r\n * Interface for cullable objects\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/materials/using/materials_introduction#back-face-culling\r\n */\r\nexport interface ICullable {\r\n    /**\r\n     * Checks if the object or part of the object is in the frustum\r\n     * @param frustumPlanes Camera near/planes\r\n     * @returns true if the object is in frustum otherwise false\r\n     */\r\n    isInFrustum(frustumPlanes: Plane[]): boolean;\r\n    /**\r\n     * Checks if a cullable object (mesh...) is in the camera frustum\r\n     * Unlike isInFrustum this checks the full bounding box\r\n     * @param frustumPlanes Camera near/planes\r\n     * @returns true if the object is in frustum otherwise false\r\n     */\r\n    isCompletelyInFrustum(frustumPlanes: Plane[]): boolean;\r\n}\r\n\r\n/**\r\n * Info for a bounding data of a mesh\r\n */\r\nexport class BoundingInfo implements ICullable {\r\n    /**\r\n     * Bounding box for the mesh\r\n     */\r\n    public readonly boundingBox: BoundingBox;\r\n    /**\r\n     * Bounding sphere for the mesh\r\n     */\r\n    public readonly boundingSphere: BoundingSphere;\r\n\r\n    private _isLocked = false;\r\n\r\n    private static readonly _TmpVector3 = ArrayTools.BuildArray(2, Vector3.Zero);\r\n\r\n    /**\r\n     * Constructs bounding info\r\n     * @param minimum min vector of the bounding box/sphere\r\n     * @param maximum max vector of the bounding box/sphere\r\n     * @param worldMatrix defines the new world matrix\r\n     */\r\n    constructor(minimum: DeepImmutable<Vector3>, maximum: DeepImmutable<Vector3>, worldMatrix?: DeepImmutable<Matrix>) {\r\n        this.boundingBox = new BoundingBox(minimum, maximum, worldMatrix);\r\n        this.boundingSphere = new BoundingSphere(minimum, maximum, worldMatrix);\r\n    }\r\n\r\n    /**\r\n     * Recreates the entire bounding info from scratch as if we call the constructor in place\r\n     * @param min defines the new minimum vector (in local space)\r\n     * @param max defines the new maximum vector (in local space)\r\n     * @param worldMatrix defines the new world matrix\r\n     */\r\n    public reConstruct(min: DeepImmutable<Vector3>, max: DeepImmutable<Vector3>, worldMatrix?: DeepImmutable<Matrix>) {\r\n        this.boundingBox.reConstruct(min, max, worldMatrix);\r\n        this.boundingSphere.reConstruct(min, max, worldMatrix);\r\n    }\r\n\r\n    /**\r\n     * min vector of the bounding box/sphere\r\n     */\r\n    public get minimum(): Vector3 {\r\n        return this.boundingBox.minimum;\r\n    }\r\n\r\n    /**\r\n     * max vector of the bounding box/sphere\r\n     */\r\n    public get maximum(): Vector3 {\r\n        return this.boundingBox.maximum;\r\n    }\r\n\r\n    /**\r\n     * If the info is locked and won't be updated to avoid perf overhead\r\n     */\r\n    public get isLocked(): boolean {\r\n        return this._isLocked;\r\n    }\r\n\r\n    public set isLocked(value: boolean) {\r\n        this._isLocked = value;\r\n    }\r\n\r\n    // Methods\r\n    /**\r\n     * Updates the bounding sphere and box\r\n     * @param world world matrix to be used to update\r\n     */\r\n    public update(world: DeepImmutable<Matrix>) {\r\n        if (this._isLocked) {\r\n            return;\r\n        }\r\n        this.boundingBox._update(world);\r\n        this.boundingSphere._update(world);\r\n    }\r\n\r\n    /**\r\n     * Recreate the bounding info to be centered around a specific point given a specific extend.\r\n     * @param center New center of the bounding info\r\n     * @param extend New extend of the bounding info\r\n     * @returns the current bounding info\r\n     */\r\n    public centerOn(center: DeepImmutable<Vector3>, extend: DeepImmutable<Vector3>): BoundingInfo {\r\n        const minimum = BoundingInfo._TmpVector3[0].copyFrom(center).subtractInPlace(extend);\r\n        const maximum = BoundingInfo._TmpVector3[1].copyFrom(center).addInPlace(extend);\r\n\r\n        this.boundingBox.reConstruct(minimum, maximum, this.boundingBox.getWorldMatrix());\r\n        this.boundingSphere.reConstruct(minimum, maximum, this.boundingBox.getWorldMatrix());\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Grows the bounding info to include the given point.\r\n     * @param point The point that will be included in the current bounding info (in local space)\r\n     * @returns the current bounding info\r\n     */\r\n    public encapsulate(point: Vector3): BoundingInfo {\r\n        const minimum = Vector3.Minimize(this.minimum, point);\r\n        const maximum = Vector3.Maximize(this.maximum, point);\r\n        this.reConstruct(minimum, maximum, this.boundingBox.getWorldMatrix());\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Grows the bounding info to encapsulate the given bounding info.\r\n     * @param toEncapsulate The bounding info that will be encapsulated in the current bounding info\r\n     * @returns the current bounding info\r\n     */\r\n    public encapsulateBoundingInfo(toEncapsulate: BoundingInfo): BoundingInfo {\r\n        const invw = TmpVectors.Matrix[0];\r\n        this.boundingBox.getWorldMatrix().invertToRef(invw);\r\n\r\n        const v = TmpVectors.Vector3[0];\r\n\r\n        Vector3.TransformCoordinatesToRef(toEncapsulate.boundingBox.minimumWorld, invw, v);\r\n        this.encapsulate(v);\r\n\r\n        Vector3.TransformCoordinatesToRef(toEncapsulate.boundingBox.maximumWorld, invw, v);\r\n        this.encapsulate(v);\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Scale the current bounding info by applying a scale factor\r\n     * @param factor defines the scale factor to apply\r\n     * @returns the current bounding info\r\n     */\r\n    public scale(factor: number): BoundingInfo {\r\n        this.boundingBox.scale(factor);\r\n        this.boundingSphere.scale(factor);\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Returns `true` if the bounding info is within the frustum defined by the passed array of planes.\r\n     * @param frustumPlanes defines the frustum to test\r\n     * @param strategy defines the strategy to use for the culling (default is BABYLON.AbstractMesh.CULLINGSTRATEGY_STANDARD)\r\n     * The different strategies available are:\r\n     * * BABYLON.AbstractMesh.CULLINGSTRATEGY_STANDARD most accurate but slower @see https://doc.babylonjs.com/typedoc/classes/BABYLON.AbstractMesh#CULLINGSTRATEGY_STANDARD\r\n     * * BABYLON.AbstractMesh.CULLINGSTRATEGY_BOUNDINGSPHERE_ONLY faster but less accurate @see https://doc.babylonjs.com/typedoc/classes/BABYLON.AbstractMesh#CULLINGSTRATEGY_BOUNDINGSPHERE_ONLY\r\n     * * BABYLON.AbstractMesh.CULLINGSTRATEGY_OPTIMISTIC_INCLUSION can be faster if always visible @see https://doc.babylonjs.com/typedoc/classes/BABYLON.AbstractMesh#CULLINGSTRATEGY_OPTIMISTIC_INCLUSION\r\n     * * BABYLON.AbstractMesh.CULLINGSTRATEGY_OPTIMISTIC_INCLUSION_THEN_BSPHERE_ONLY can be faster if always visible @see https://doc.babylonjs.com/typedoc/classes/BABYLON.AbstractMesh#CULLINGSTRATEGY_OPTIMISTIC_INCLUSION_THEN_BSPHERE_ONLY\r\n     * @returns true if the bounding info is in the frustum planes\r\n     */\r\n    public isInFrustum(frustumPlanes: Array<DeepImmutable<Plane>>, strategy: number = Constants.MESHES_CULLINGSTRATEGY_STANDARD): boolean {\r\n        const inclusionTest =\r\n            strategy === Constants.MESHES_CULLINGSTRATEGY_OPTIMISTIC_INCLUSION || strategy === Constants.MESHES_CULLINGSTRATEGY_OPTIMISTIC_INCLUSION_THEN_BSPHERE_ONLY;\r\n        if (inclusionTest) {\r\n            if (this.boundingSphere.isCenterInFrustum(frustumPlanes)) {\r\n                return true;\r\n            }\r\n        }\r\n\r\n        if (!this.boundingSphere.isInFrustum(frustumPlanes)) {\r\n            return false;\r\n        }\r\n\r\n        const bSphereOnlyTest =\r\n            strategy === Constants.MESHES_CULLINGSTRATEGY_BOUNDINGSPHERE_ONLY || strategy === Constants.MESHES_CULLINGSTRATEGY_OPTIMISTIC_INCLUSION_THEN_BSPHERE_ONLY;\r\n        if (bSphereOnlyTest) {\r\n            return true;\r\n        }\r\n\r\n        return this.boundingBox.isInFrustum(frustumPlanes);\r\n    }\r\n\r\n    /**\r\n     * Gets the world distance between the min and max points of the bounding box\r\n     */\r\n    public get diagonalLength(): number {\r\n        const boundingBox = this.boundingBox;\r\n        const diag = boundingBox.maximumWorld.subtractToRef(boundingBox.minimumWorld, BoundingInfo._TmpVector3[0]);\r\n        return diag.length();\r\n    }\r\n\r\n    /**\r\n     * Checks if a cullable object (mesh...) is in the camera frustum\r\n     * Unlike isInFrustum this checks the full bounding box\r\n     * @param frustumPlanes Camera near/planes\r\n     * @returns true if the object is in frustum otherwise false\r\n     */\r\n    public isCompletelyInFrustum(frustumPlanes: Array<DeepImmutable<Plane>>): boolean {\r\n        return this.boundingBox.isCompletelyInFrustum(frustumPlanes);\r\n    }\r\n    /**\r\n     * @internal\r\n     */\r\n    public _checkCollision(collider: Collider): boolean {\r\n        return collider._canDoCollision(this.boundingSphere.centerWorld, this.boundingSphere.radiusWorld, this.boundingBox.minimumWorld, this.boundingBox.maximumWorld);\r\n    }\r\n\r\n    /**\r\n     * Checks if a point is inside the bounding box and bounding sphere or the mesh\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/interactions/mesh_intersect\r\n     * @param point the point to check intersection with\r\n     * @returns if the point intersects\r\n     */\r\n    public intersectsPoint(point: DeepImmutable<Vector3>): boolean {\r\n        if (!this.boundingSphere.centerWorld) {\r\n            return false;\r\n        }\r\n\r\n        if (!this.boundingSphere.intersectsPoint(point)) {\r\n            return false;\r\n        }\r\n\r\n        if (!this.boundingBox.intersectsPoint(point)) {\r\n            return false;\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Checks if another bounding info intersects the bounding box and bounding sphere or the mesh\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/interactions/mesh_intersect\r\n     * @param boundingInfo the bounding info to check intersection with\r\n     * @param precise if the intersection should be done using OBB\r\n     * @returns if the bounding info intersects\r\n     */\r\n    public intersects(boundingInfo: DeepImmutable<BoundingInfo>, precise: boolean): boolean {\r\n        if (!BoundingSphere.Intersects(this.boundingSphere, boundingInfo.boundingSphere)) {\r\n            return false;\r\n        }\r\n\r\n        if (!BoundingBox.Intersects(this.boundingBox, boundingInfo.boundingBox)) {\r\n            return false;\r\n        }\r\n\r\n        if (!precise) {\r\n            return true;\r\n        }\r\n\r\n        const box0 = this.boundingBox;\r\n        const box1 = boundingInfo.boundingBox;\r\n\r\n        if (!axisOverlap(box0.directions[0], box0, box1)) {\r\n            return false;\r\n        }\r\n        if (!axisOverlap(box0.directions[1], box0, box1)) {\r\n            return false;\r\n        }\r\n        if (!axisOverlap(box0.directions[2], box0, box1)) {\r\n            return false;\r\n        }\r\n        if (!axisOverlap(box1.directions[0], box0, box1)) {\r\n            return false;\r\n        }\r\n        if (!axisOverlap(box1.directions[1], box0, box1)) {\r\n            return false;\r\n        }\r\n        if (!axisOverlap(box1.directions[2], box0, box1)) {\r\n            return false;\r\n        }\r\n        if (!axisOverlap(Vector3.Cross(box0.directions[0], box1.directions[0]), box0, box1)) {\r\n            return false;\r\n        }\r\n        if (!axisOverlap(Vector3.Cross(box0.directions[0], box1.directions[1]), box0, box1)) {\r\n            return false;\r\n        }\r\n        if (!axisOverlap(Vector3.Cross(box0.directions[0], box1.directions[2]), box0, box1)) {\r\n            return false;\r\n        }\r\n        if (!axisOverlap(Vector3.Cross(box0.directions[1], box1.directions[0]), box0, box1)) {\r\n            return false;\r\n        }\r\n        if (!axisOverlap(Vector3.Cross(box0.directions[1], box1.directions[1]), box0, box1)) {\r\n            return false;\r\n        }\r\n        if (!axisOverlap(Vector3.Cross(box0.directions[1], box1.directions[2]), box0, box1)) {\r\n            return false;\r\n        }\r\n        if (!axisOverlap(Vector3.Cross(box0.directions[2], box1.directions[0]), box0, box1)) {\r\n            return false;\r\n        }\r\n        if (!axisOverlap(Vector3.Cross(box0.directions[2], box1.directions[1]), box0, box1)) {\r\n            return false;\r\n        }\r\n        if (!axisOverlap(Vector3.Cross(box0.directions[2], box1.directions[2]), box0, box1)) {\r\n            return false;\r\n        }\r\n\r\n        return true;\r\n    }\r\n}\r\n", "import type { FloatArray, Nullable, IndicesArray } from \"../types\";\r\nimport type { Vector2 } from \"./math.vector\";\r\nimport { Vector3 } from \"./math.vector\";\r\nimport { nativeOverride } from \"../Misc/decorators\";\r\n\r\n// This helper class is only here so we can apply the nativeOverride decorator to functions.\r\nclass MathHelpers {\r\n    @nativeOverride.filter((...[positions, indices]: Parameters<typeof MathHelpers.extractMinAndMaxIndexed>) => !Array.isArray(positions) && !Array.isArray(indices))\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    public static extractMinAndMaxIndexed(positions: FloatArray, indices: IndicesArray, indexStart: number, indexCount: number, minimum: Vector3, maximum: Vector3): void {\r\n        for (let index = indexStart; index < indexStart + indexCount; index++) {\r\n            const offset = indices[index] * 3;\r\n            const x = positions[offset];\r\n            const y = positions[offset + 1];\r\n            const z = positions[offset + 2];\r\n            minimum.minimizeInPlaceFromFloats(x, y, z);\r\n            maximum.maximizeInPlaceFromFloats(x, y, z);\r\n        }\r\n    }\r\n\r\n    @nativeOverride.filter((...[positions]: Parameters<typeof MathHelpers.extractMinAndMax>) => !Array.isArray(positions))\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    public static extractMinAndMax(positions: FloatArray, start: number, count: number, stride: number, minimum: Vector3, maximum: Vector3): void {\r\n        for (let index = start, offset = start * stride; index < start + count; index++, offset += stride) {\r\n            const x = positions[offset];\r\n            const y = positions[offset + 1];\r\n            const z = positions[offset + 2];\r\n            minimum.minimizeInPlaceFromFloats(x, y, z);\r\n            maximum.maximizeInPlaceFromFloats(x, y, z);\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * Extracts minimum and maximum values from a list of indexed positions\r\n * @param positions defines the positions to use\r\n * @param indices defines the indices to the positions\r\n * @param indexStart defines the start index\r\n * @param indexCount defines the end index\r\n * @param bias defines bias value to add to the result\r\n * @returns minimum and maximum values\r\n */\r\nexport function extractMinAndMaxIndexed(\r\n    positions: FloatArray,\r\n    indices: IndicesArray,\r\n    indexStart: number,\r\n    indexCount: number,\r\n    bias: Nullable<Vector2> = null\r\n): { minimum: Vector3; maximum: Vector3 } {\r\n    const minimum = new Vector3(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);\r\n    const maximum = new Vector3(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE);\r\n\r\n    MathHelpers.extractMinAndMaxIndexed(positions, indices, indexStart, indexCount, minimum, maximum);\r\n\r\n    if (bias) {\r\n        minimum.x -= minimum.x * bias.x + bias.y;\r\n        minimum.y -= minimum.y * bias.x + bias.y;\r\n        minimum.z -= minimum.z * bias.x + bias.y;\r\n        maximum.x += maximum.x * bias.x + bias.y;\r\n        maximum.y += maximum.y * bias.x + bias.y;\r\n        maximum.z += maximum.z * bias.x + bias.y;\r\n    }\r\n\r\n    return {\r\n        minimum: minimum,\r\n        maximum: maximum,\r\n    };\r\n}\r\n\r\n/**\r\n * Extracts minimum and maximum values from a list of positions\r\n * @param positions defines the positions to use\r\n * @param start defines the start index in the positions array\r\n * @param count defines the number of positions to handle\r\n * @param bias defines bias value to add to the result\r\n * @param stride defines the stride size to use (distance between two positions in the positions array)\r\n * @returns minimum and maximum values\r\n */\r\nexport function extractMinAndMax(positions: FloatArray, start: number, count: number, bias: Nullable<Vector2> = null, stride?: number): { minimum: Vector3; maximum: Vector3 } {\r\n    const minimum = new Vector3(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);\r\n    const maximum = new Vector3(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE);\r\n\r\n    if (!stride) {\r\n        stride = 3;\r\n    }\r\n\r\n    MathHelpers.extractMinAndMax(positions, start, count, stride, minimum, maximum);\r\n\r\n    if (bias) {\r\n        minimum.x -= minimum.x * bias.x + bias.y;\r\n        minimum.y -= minimum.y * bias.x + bias.y;\r\n        minimum.z -= minimum.z * bias.x + bias.y;\r\n        maximum.x += maximum.x * bias.x + bias.y;\r\n        maximum.y += maximum.y * bias.x + bias.y;\r\n        maximum.z += maximum.z * bias.x + bias.y;\r\n    }\r\n\r\n    return {\r\n        minimum: minimum,\r\n        maximum: maximum,\r\n    };\r\n}\r\n", "import type { Nullable, IndicesArray, DeepImmutable, FloatArray } from \"../types\";\r\nimport type { Matrix, Vector3 } from \"../Maths/math.vector\";\r\nimport type { Engine } from \"../Engines/engine\";\r\nimport { VertexBuffer } from \"../Buffers/buffer\";\r\nimport { IntersectionInfo } from \"../Collisions/intersectionInfo\";\r\nimport type { ICullable } from \"../Culling/boundingInfo\";\r\nimport { BoundingInfo } from \"../Culling/boundingInfo\";\r\nimport type { Effect } from \"../Materials/effect\";\r\nimport { Constants } from \"../Engines/constants\";\r\nimport type { DataBuffer } from \"../Buffers/dataBuffer\";\r\nimport { extractMinAndMaxIndexed } from \"../Maths/math.functions\";\r\nimport type { Plane } from \"../Maths/math.plane\";\r\nimport { DrawWrapper } from \"../Materials/drawWrapper\";\r\nimport type { IMaterialContext } from \"../Engines/IMaterialContext\";\r\n\r\nimport type { Collider } from \"../Collisions/collider\";\r\nimport type { Material } from \"../Materials/material\";\r\nimport type { MaterialDefines } from \"../Materials/materialDefines\";\r\nimport type { MultiMaterial } from \"../Materials/multiMaterial\";\r\nimport type { AbstractMesh } from \"./abstractMesh\";\r\nimport type { Mesh } from \"./mesh\";\r\nimport type { Ray } from \"../Culling/ray\";\r\nimport type { TrianglePickingPredicate } from \"../Culling/ray\";\r\n\r\n/**\r\n * Defines a subdivision inside a mesh\r\n */\r\nexport class SubMesh implements ICullable {\r\n    private _engine: Engine;\r\n    /** @internal */\r\n    public _drawWrappers: Array<DrawWrapper>; // index in this array = pass id\r\n    private _mainDrawWrapperOverride: Nullable<DrawWrapper> = null;\r\n\r\n    /**\r\n     * Gets material defines used by the effect associated to the sub mesh\r\n     */\r\n    public get materialDefines(): Nullable<MaterialDefines> {\r\n        return this._mainDrawWrapperOverride ? (this._mainDrawWrapperOverride.defines as MaterialDefines) : (this._getDrawWrapper()?.defines as Nullable<MaterialDefines>);\r\n    }\r\n\r\n    /**\r\n     * Sets material defines used by the effect associated to the sub mesh\r\n     */\r\n    public set materialDefines(defines: Nullable<MaterialDefines>) {\r\n        const drawWrapper = this._mainDrawWrapperOverride ?? this._getDrawWrapper(undefined, true)!;\r\n        drawWrapper.defines = defines;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _getDrawWrapper(passId?: number, createIfNotExisting = false): DrawWrapper | undefined {\r\n        passId = passId ?? this._engine.currentRenderPassId;\r\n        let drawWrapper = this._drawWrappers[passId];\r\n        if (!drawWrapper && createIfNotExisting) {\r\n            this._drawWrappers[passId] = drawWrapper = new DrawWrapper(this._mesh.getScene().getEngine());\r\n        }\r\n        return drawWrapper;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _removeDrawWrapper(passId: number, disposeWrapper = true) {\r\n        if (disposeWrapper) {\r\n            this._drawWrappers[passId]?.dispose();\r\n        }\r\n        this._drawWrappers[passId] = undefined as any;\r\n    }\r\n\r\n    /**\r\n     * Gets associated (main) effect (possibly the effect override if defined)\r\n     */\r\n    public get effect(): Nullable<Effect> {\r\n        return this._mainDrawWrapperOverride ? this._mainDrawWrapperOverride.effect : this._getDrawWrapper()?.effect ?? null;\r\n    }\r\n\r\n    /** @internal */\r\n    public get _drawWrapper(): DrawWrapper {\r\n        return this._mainDrawWrapperOverride ?? this._getDrawWrapper(undefined, true)!;\r\n    }\r\n\r\n    /** @internal */\r\n    public get _drawWrapperOverride(): Nullable<DrawWrapper> {\r\n        return this._mainDrawWrapperOverride;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _setMainDrawWrapperOverride(wrapper: Nullable<DrawWrapper>): void {\r\n        this._mainDrawWrapperOverride = wrapper;\r\n    }\r\n\r\n    /**\r\n     * Sets associated effect (effect used to render this submesh)\r\n     * @param effect defines the effect to associate with\r\n     * @param defines defines the set of defines used to compile this effect\r\n     * @param materialContext material context associated to the effect\r\n     * @param resetContext true to reset the draw context\r\n     */\r\n    public setEffect(effect: Nullable<Effect>, defines: Nullable<string | MaterialDefines> = null, materialContext?: IMaterialContext, resetContext = true) {\r\n        const drawWrapper = this._drawWrapper;\r\n        drawWrapper.setEffect(effect, defines, resetContext);\r\n        if (materialContext !== undefined) {\r\n            drawWrapper.materialContext = materialContext;\r\n        }\r\n        if (!effect) {\r\n            drawWrapper.defines = null;\r\n            drawWrapper.materialContext = undefined;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Resets the draw wrappers cache\r\n     * @param passId If provided, releases only the draw wrapper corresponding to this render pass id\r\n     */\r\n    public resetDrawCache(passId?: number): void {\r\n        if (this._drawWrappers) {\r\n            if (passId !== undefined) {\r\n                this._removeDrawWrapper(passId);\r\n                return;\r\n            } else {\r\n                for (const drawWrapper of this._drawWrappers) {\r\n                    drawWrapper?.dispose();\r\n                }\r\n            }\r\n        }\r\n        this._drawWrappers = [];\r\n    }\r\n\r\n    /** @internal */\r\n    public _linesIndexCount: number = 0;\r\n    private _mesh: AbstractMesh;\r\n    private _renderingMesh: Mesh;\r\n    private _boundingInfo: BoundingInfo;\r\n    private _linesIndexBuffer: Nullable<DataBuffer> = null;\r\n    /** @internal */\r\n    public _lastColliderWorldVertices: Nullable<Vector3[]> = null;\r\n    /** @internal */\r\n    public _trianglePlanes: Plane[];\r\n    /** @internal */\r\n    public _lastColliderTransformMatrix: Nullable<Matrix> = null;\r\n    /** @internal */\r\n    public _wasDispatched = false;\r\n\r\n    /** @internal */\r\n    public _renderId = 0;\r\n    /** @internal */\r\n    public _alphaIndex: number = 0;\r\n    /** @internal */\r\n    public _distanceToCamera: number = 0;\r\n    /** @internal */\r\n    public _id: number;\r\n\r\n    private _currentMaterial: Nullable<Material> = null;\r\n\r\n    /**\r\n     * Add a new submesh to a mesh\r\n     * @param materialIndex defines the material index to use\r\n     * @param verticesStart defines vertex index start\r\n     * @param verticesCount defines vertices count\r\n     * @param indexStart defines index start\r\n     * @param indexCount defines indices count\r\n     * @param mesh defines the parent mesh\r\n     * @param renderingMesh defines an optional rendering mesh\r\n     * @param createBoundingBox defines if bounding box should be created for this submesh\r\n     * @returns the new submesh\r\n     */\r\n    public static AddToMesh(\r\n        materialIndex: number,\r\n        verticesStart: number,\r\n        verticesCount: number,\r\n        indexStart: number,\r\n        indexCount: number,\r\n        mesh: AbstractMesh,\r\n        renderingMesh?: Mesh,\r\n        createBoundingBox: boolean = true\r\n    ): SubMesh {\r\n        return new SubMesh(materialIndex, verticesStart, verticesCount, indexStart, indexCount, mesh, renderingMesh, createBoundingBox);\r\n    }\r\n\r\n    /**\r\n     * Creates a new submesh\r\n     * @param materialIndex defines the material index to use\r\n     * @param verticesStart defines vertex index start\r\n     * @param verticesCount defines vertices count\r\n     * @param indexStart defines index start\r\n     * @param indexCount defines indices count\r\n     * @param mesh defines the parent mesh\r\n     * @param renderingMesh defines an optional rendering mesh\r\n     * @param createBoundingBox defines if bounding box should be created for this submesh\r\n     * @param addToMesh defines a boolean indicating that the submesh must be added to the mesh.subMeshes array (true by default)\r\n     */\r\n    constructor(\r\n        /** the material index to use */\r\n        public materialIndex: number,\r\n        /** vertex index start */\r\n        public verticesStart: number,\r\n        /** vertices count */\r\n        public verticesCount: number,\r\n        /** index start */\r\n        public indexStart: number,\r\n        /** indices count */\r\n        public indexCount: number,\r\n        mesh: AbstractMesh,\r\n        renderingMesh?: Mesh,\r\n        createBoundingBox: boolean = true,\r\n        addToMesh = true\r\n    ) {\r\n        this._mesh = mesh;\r\n        this._renderingMesh = renderingMesh || <Mesh>mesh;\r\n        if (addToMesh) {\r\n            mesh.subMeshes.push(this);\r\n        }\r\n\r\n        this._engine = this._mesh.getScene().getEngine();\r\n        this.resetDrawCache();\r\n        this._trianglePlanes = [];\r\n\r\n        this._id = mesh.subMeshes.length - 1;\r\n\r\n        if (createBoundingBox) {\r\n            this.refreshBoundingInfo();\r\n            mesh.computeWorldMatrix(true);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Returns true if this submesh covers the entire parent mesh\r\n     * @ignorenaming\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    public get IsGlobal(): boolean {\r\n        return this.verticesStart === 0 && this.verticesCount === this._mesh.getTotalVertices() && this.indexStart === 0 && this.indexCount === this._mesh.getTotalIndices();\r\n    }\r\n\r\n    /**\r\n     * Returns the submesh BoundingInfo object\r\n     * @returns current bounding info (or mesh's one if the submesh is global)\r\n     */\r\n    public getBoundingInfo(): BoundingInfo {\r\n        if (this.IsGlobal || this._mesh.hasThinInstances) {\r\n            return this._mesh.getBoundingInfo();\r\n        }\r\n\r\n        return this._boundingInfo;\r\n    }\r\n\r\n    /**\r\n     * Sets the submesh BoundingInfo\r\n     * @param boundingInfo defines the new bounding info to use\r\n     * @returns the SubMesh\r\n     */\r\n    public setBoundingInfo(boundingInfo: BoundingInfo): SubMesh {\r\n        this._boundingInfo = boundingInfo;\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Returns the mesh of the current submesh\r\n     * @returns the parent mesh\r\n     */\r\n    public getMesh(): AbstractMesh {\r\n        return this._mesh;\r\n    }\r\n\r\n    /**\r\n     * Returns the rendering mesh of the submesh\r\n     * @returns the rendering mesh (could be different from parent mesh)\r\n     */\r\n    public getRenderingMesh(): Mesh {\r\n        return this._renderingMesh;\r\n    }\r\n\r\n    /**\r\n     * Returns the replacement mesh of the submesh\r\n     * @returns the replacement mesh (could be different from parent mesh)\r\n     */\r\n    public getReplacementMesh(): Nullable<AbstractMesh> {\r\n        return this._mesh._internalAbstractMeshDataInfo._actAsRegularMesh ? this._mesh : null;\r\n    }\r\n\r\n    /**\r\n     * Returns the effective mesh of the submesh\r\n     * @returns the effective mesh (could be different from parent mesh)\r\n     */\r\n    public getEffectiveMesh(): AbstractMesh {\r\n        const replacementMesh = this._mesh._internalAbstractMeshDataInfo._actAsRegularMesh ? this._mesh : null;\r\n\r\n        return replacementMesh ? replacementMesh : this._renderingMesh;\r\n    }\r\n\r\n    /**\r\n     * Returns the submesh material\r\n     * @param getDefaultMaterial Defines whether or not to get the default material if nothing has been defined.\r\n     * @returns null or the current material\r\n     */\r\n    public getMaterial(getDefaultMaterial = true): Nullable<Material> {\r\n        const rootMaterial = this._renderingMesh.getMaterialForRenderPass(this._engine.currentRenderPassId) ?? this._renderingMesh.material;\r\n\r\n        if (!rootMaterial) {\r\n            return getDefaultMaterial ? this._mesh.getScene().defaultMaterial : null;\r\n        } else if (this._isMultiMaterial(rootMaterial)) {\r\n            const effectiveMaterial = rootMaterial.getSubMaterial(this.materialIndex);\r\n\r\n            if (this._currentMaterial !== effectiveMaterial) {\r\n                this._currentMaterial = effectiveMaterial;\r\n                this.resetDrawCache();\r\n            }\r\n\r\n            return effectiveMaterial;\r\n        }\r\n\r\n        return rootMaterial;\r\n    }\r\n\r\n    private _isMultiMaterial(material: Material): material is MultiMaterial {\r\n        return (material as MultiMaterial).getSubMaterial !== undefined;\r\n    }\r\n\r\n    // Methods\r\n\r\n    /**\r\n     * Sets a new updated BoundingInfo object to the submesh\r\n     * @param data defines an optional position array to use to determine the bounding info\r\n     * @returns the SubMesh\r\n     */\r\n    public refreshBoundingInfo(data: Nullable<FloatArray> = null): SubMesh {\r\n        this._lastColliderWorldVertices = null;\r\n\r\n        if (this.IsGlobal || !this._renderingMesh || !this._renderingMesh.geometry) {\r\n            return this;\r\n        }\r\n\r\n        if (!data) {\r\n            data = this._renderingMesh.getVerticesData(VertexBuffer.PositionKind);\r\n        }\r\n\r\n        if (!data) {\r\n            this._boundingInfo = this._mesh.getBoundingInfo();\r\n            return this;\r\n        }\r\n\r\n        const indices = <IndicesArray>this._renderingMesh.getIndices();\r\n        let extend: { minimum: Vector3; maximum: Vector3 };\r\n\r\n        //is this the only submesh?\r\n        if (this.indexStart === 0 && this.indexCount === indices.length) {\r\n            const boundingInfo = this._renderingMesh.getBoundingInfo();\r\n\r\n            //the rendering mesh's bounding info can be used, it is the standard submesh for all indices.\r\n            extend = { minimum: boundingInfo.minimum.clone(), maximum: boundingInfo.maximum.clone() };\r\n        } else {\r\n            extend = extractMinAndMaxIndexed(data, indices, this.indexStart, this.indexCount, this._renderingMesh.geometry.boundingBias);\r\n        }\r\n\r\n        if (this._boundingInfo) {\r\n            this._boundingInfo.reConstruct(extend.minimum, extend.maximum);\r\n        } else {\r\n            this._boundingInfo = new BoundingInfo(extend.minimum, extend.maximum);\r\n        }\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _checkCollision(collider: Collider): boolean {\r\n        const boundingInfo = this.getBoundingInfo();\r\n\r\n        return boundingInfo._checkCollision(collider);\r\n    }\r\n\r\n    /**\r\n     * Updates the submesh BoundingInfo\r\n     * @param world defines the world matrix to use to update the bounding info\r\n     * @returns the submesh\r\n     */\r\n    public updateBoundingInfo(world: DeepImmutable<Matrix>): SubMesh {\r\n        let boundingInfo = this.getBoundingInfo();\r\n\r\n        if (!boundingInfo) {\r\n            this.refreshBoundingInfo();\r\n            boundingInfo = this.getBoundingInfo();\r\n        }\r\n        if (boundingInfo) {\r\n            (<BoundingInfo>boundingInfo).update(world);\r\n        }\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * True is the submesh bounding box intersects the frustum defined by the passed array of planes.\r\n     * @param frustumPlanes defines the frustum planes\r\n     * @returns true if the submesh is intersecting with the frustum\r\n     */\r\n    public isInFrustum(frustumPlanes: Plane[]): boolean {\r\n        const boundingInfo = this.getBoundingInfo();\r\n\r\n        if (!boundingInfo) {\r\n            return false;\r\n        }\r\n        return boundingInfo.isInFrustum(frustumPlanes, this._mesh.cullingStrategy);\r\n    }\r\n\r\n    /**\r\n     * True is the submesh bounding box is completely inside the frustum defined by the passed array of planes\r\n     * @param frustumPlanes defines the frustum planes\r\n     * @returns true if the submesh is inside the frustum\r\n     */\r\n    public isCompletelyInFrustum(frustumPlanes: Plane[]): boolean {\r\n        const boundingInfo = this.getBoundingInfo();\r\n\r\n        if (!boundingInfo) {\r\n            return false;\r\n        }\r\n        return boundingInfo.isCompletelyInFrustum(frustumPlanes);\r\n    }\r\n\r\n    /**\r\n     * Renders the submesh\r\n     * @param enableAlphaMode defines if alpha needs to be used\r\n     * @returns the submesh\r\n     */\r\n    public render(enableAlphaMode: boolean): SubMesh {\r\n        this._renderingMesh.render(this, enableAlphaMode, this._mesh._internalAbstractMeshDataInfo._actAsRegularMesh ? this._mesh : undefined);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _getLinesIndexBuffer(indices: IndicesArray, engine: Engine): DataBuffer {\r\n        if (!this._linesIndexBuffer) {\r\n            const linesIndices = [];\r\n\r\n            for (let index = this.indexStart; index < this.indexStart + this.indexCount; index += 3) {\r\n                linesIndices.push(indices[index], indices[index + 1], indices[index + 1], indices[index + 2], indices[index + 2], indices[index]);\r\n            }\r\n\r\n            this._linesIndexBuffer = engine.createIndexBuffer(linesIndices);\r\n            this._linesIndexCount = linesIndices.length;\r\n        }\r\n        return this._linesIndexBuffer;\r\n    }\r\n\r\n    /**\r\n     * Checks if the submesh intersects with a ray\r\n     * @param ray defines the ray to test\r\n     * @returns true is the passed ray intersects the submesh bounding box\r\n     */\r\n    public canIntersects(ray: Ray): boolean {\r\n        const boundingInfo = this.getBoundingInfo();\r\n\r\n        if (!boundingInfo) {\r\n            return false;\r\n        }\r\n        return ray.intersectsBox(boundingInfo.boundingBox);\r\n    }\r\n\r\n    /**\r\n     * Intersects current submesh with a ray\r\n     * @param ray defines the ray to test\r\n     * @param positions defines mesh's positions array\r\n     * @param indices defines mesh's indices array\r\n     * @param fastCheck defines if the first intersection will be used (and not the closest)\r\n     * @param trianglePredicate defines an optional predicate used to select faces when a mesh intersection is detected\r\n     * @returns intersection info or null if no intersection\r\n     */\r\n    public intersects(ray: Ray, positions: Vector3[], indices: IndicesArray, fastCheck?: boolean, trianglePredicate?: TrianglePickingPredicate): Nullable<IntersectionInfo> {\r\n        const material = this.getMaterial();\r\n        if (!material) {\r\n            return null;\r\n        }\r\n        let step = 3;\r\n        let checkStopper = false;\r\n\r\n        switch (material.fillMode) {\r\n            case Constants.MATERIAL_PointListDrawMode:\r\n            case Constants.MATERIAL_LineLoopDrawMode:\r\n            case Constants.MATERIAL_LineStripDrawMode:\r\n            case Constants.MATERIAL_TriangleFanDrawMode:\r\n                return null;\r\n            case Constants.MATERIAL_TriangleStripDrawMode:\r\n                step = 1;\r\n                checkStopper = true;\r\n                break;\r\n            default:\r\n                break;\r\n        }\r\n\r\n        // LineMesh first as it's also a Mesh...\r\n        if (material.fillMode === Constants.MATERIAL_LineListDrawMode) {\r\n            // Check if mesh is unindexed\r\n            if (!indices.length) {\r\n                return this._intersectUnIndexedLines(ray, positions, indices, (this._mesh as any).intersectionThreshold, fastCheck);\r\n            }\r\n            return this._intersectLines(ray, positions, indices, (this._mesh as any).intersectionThreshold, fastCheck);\r\n        } else {\r\n            // Check if mesh is unindexed\r\n            if (!indices.length && this._mesh._unIndexed) {\r\n                return this._intersectUnIndexedTriangles(ray, positions, indices, fastCheck, trianglePredicate);\r\n            }\r\n\r\n            return this._intersectTriangles(ray, positions, indices, step, checkStopper, fastCheck, trianglePredicate);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    private _intersectLines(ray: Ray, positions: Vector3[], indices: IndicesArray, intersectionThreshold: number, fastCheck?: boolean): Nullable<IntersectionInfo> {\r\n        let intersectInfo: Nullable<IntersectionInfo> = null;\r\n\r\n        // Line test\r\n        for (let index = this.indexStart; index < this.indexStart + this.indexCount; index += 2) {\r\n            const p0 = positions[indices[index]];\r\n            const p1 = positions[indices[index + 1]];\r\n\r\n            const length = ray.intersectionSegment(p0, p1, intersectionThreshold);\r\n            if (length < 0) {\r\n                continue;\r\n            }\r\n\r\n            if (fastCheck || !intersectInfo || length < intersectInfo.distance) {\r\n                intersectInfo = new IntersectionInfo(null, null, length);\r\n                intersectInfo.faceId = index / 2;\r\n                if (fastCheck) {\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        return intersectInfo;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    private _intersectUnIndexedLines(ray: Ray, positions: Vector3[], indices: IndicesArray, intersectionThreshold: number, fastCheck?: boolean): Nullable<IntersectionInfo> {\r\n        let intersectInfo: Nullable<IntersectionInfo> = null;\r\n\r\n        // Line test\r\n        for (let index = this.verticesStart; index < this.verticesStart + this.verticesCount; index += 2) {\r\n            const p0 = positions[index];\r\n            const p1 = positions[index + 1];\r\n\r\n            const length = ray.intersectionSegment(p0, p1, intersectionThreshold);\r\n            if (length < 0) {\r\n                continue;\r\n            }\r\n\r\n            if (fastCheck || !intersectInfo || length < intersectInfo.distance) {\r\n                intersectInfo = new IntersectionInfo(null, null, length);\r\n                intersectInfo.faceId = index / 2;\r\n                if (fastCheck) {\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n\r\n        return intersectInfo;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    private _intersectTriangles(\r\n        ray: Ray,\r\n        positions: Vector3[],\r\n        indices: IndicesArray,\r\n        step: number,\r\n        checkStopper: boolean,\r\n        fastCheck?: boolean,\r\n        trianglePredicate?: TrianglePickingPredicate\r\n    ): Nullable<IntersectionInfo> {\r\n        let intersectInfo: Nullable<IntersectionInfo> = null;\r\n\r\n        // Triangles test\r\n        let faceId = -1;\r\n        for (let index = this.indexStart; index < this.indexStart + this.indexCount - (3 - step); index += step) {\r\n            faceId++;\r\n            const indexA = indices[index];\r\n            const indexB = indices[index + 1];\r\n            const indexC = indices[index + 2];\r\n\r\n            if (checkStopper && indexC === 0xffffffff) {\r\n                index += 2;\r\n                continue;\r\n            }\r\n\r\n            const p0 = positions[indexA];\r\n            const p1 = positions[indexB];\r\n            const p2 = positions[indexC];\r\n\r\n            // stay defensive and don't check against undefined positions.\r\n            if (!p0 || !p1 || !p2) {\r\n                continue;\r\n            }\r\n\r\n            if (trianglePredicate && !trianglePredicate(p0, p1, p2, ray, indexA, indexB, indexC)) {\r\n                continue;\r\n            }\r\n\r\n            const currentIntersectInfo = ray.intersectsTriangle(p0, p1, p2);\r\n\r\n            if (currentIntersectInfo) {\r\n                if (currentIntersectInfo.distance < 0) {\r\n                    continue;\r\n                }\r\n\r\n                if (fastCheck || !intersectInfo || currentIntersectInfo.distance < intersectInfo.distance) {\r\n                    intersectInfo = currentIntersectInfo;\r\n                    intersectInfo.faceId = faceId;\r\n\r\n                    if (fastCheck) {\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return intersectInfo;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    private _intersectUnIndexedTriangles(\r\n        ray: Ray,\r\n        positions: Vector3[],\r\n        indices: IndicesArray,\r\n        fastCheck?: boolean,\r\n        trianglePredicate?: TrianglePickingPredicate\r\n    ): Nullable<IntersectionInfo> {\r\n        let intersectInfo: Nullable<IntersectionInfo> = null;\r\n        // Triangles test\r\n        for (let index = this.verticesStart; index < this.verticesStart + this.verticesCount; index += 3) {\r\n            const p0 = positions[index];\r\n            const p1 = positions[index + 1];\r\n            const p2 = positions[index + 2];\r\n\r\n            if (trianglePredicate && !trianglePredicate(p0, p1, p2, ray, -1, -1, -1)) {\r\n                continue;\r\n            }\r\n\r\n            const currentIntersectInfo = ray.intersectsTriangle(p0, p1, p2);\r\n\r\n            if (currentIntersectInfo) {\r\n                if (currentIntersectInfo.distance < 0) {\r\n                    continue;\r\n                }\r\n\r\n                if (fastCheck || !intersectInfo || currentIntersectInfo.distance < intersectInfo.distance) {\r\n                    intersectInfo = currentIntersectInfo;\r\n                    intersectInfo.faceId = index / 3;\r\n\r\n                    if (fastCheck) {\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return intersectInfo;\r\n    }\r\n\r\n    /** @internal */\r\n    public _rebuild(): void {\r\n        if (this._linesIndexBuffer) {\r\n            this._linesIndexBuffer = null;\r\n        }\r\n    }\r\n\r\n    // Clone\r\n    /**\r\n     * Creates a new submesh from the passed mesh\r\n     * @param newMesh defines the new hosting mesh\r\n     * @param newRenderingMesh defines an optional rendering mesh\r\n     * @returns the new submesh\r\n     */\r\n    public clone(newMesh: AbstractMesh, newRenderingMesh?: Mesh): SubMesh {\r\n        const result = new SubMesh(this.materialIndex, this.verticesStart, this.verticesCount, this.indexStart, this.indexCount, newMesh, newRenderingMesh, false);\r\n\r\n        if (!this.IsGlobal) {\r\n            const boundingInfo = this.getBoundingInfo();\r\n\r\n            if (!boundingInfo) {\r\n                return result;\r\n            }\r\n\r\n            result._boundingInfo = new BoundingInfo(boundingInfo.minimum, boundingInfo.maximum);\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    // Dispose\r\n\r\n    /**\r\n     * Release associated resources\r\n     */\r\n    public dispose(): void {\r\n        if (this._linesIndexBuffer) {\r\n            this._mesh.getScene().getEngine()._releaseBuffer(this._linesIndexBuffer);\r\n            this._linesIndexBuffer = null;\r\n        }\r\n\r\n        // Remove from mesh\r\n        const index = this._mesh.subMeshes.indexOf(this);\r\n        this._mesh.subMeshes.splice(index, 1);\r\n\r\n        this.resetDrawCache();\r\n    }\r\n\r\n    /**\r\n     * Gets the class name\r\n     * @returns the string \"SubMesh\".\r\n     */\r\n    public getClassName(): string {\r\n        return \"SubMesh\";\r\n    }\r\n\r\n    // Statics\r\n    /**\r\n     * Creates a new submesh from indices data\r\n     * @param materialIndex the index of the main mesh material\r\n     * @param startIndex the index where to start the copy in the mesh indices array\r\n     * @param indexCount the number of indices to copy then from the startIndex\r\n     * @param mesh the main mesh to create the submesh from\r\n     * @param renderingMesh the optional rendering mesh\r\n     * @param createBoundingBox defines if bounding box should be created for this submesh\r\n     * @returns a new submesh\r\n     */\r\n    public static CreateFromIndices(\r\n        materialIndex: number,\r\n        startIndex: number,\r\n        indexCount: number,\r\n        mesh: AbstractMesh,\r\n        renderingMesh?: Mesh,\r\n        createBoundingBox: boolean = true\r\n    ): SubMesh {\r\n        let minVertexIndex = Number.MAX_VALUE;\r\n        let maxVertexIndex = -Number.MAX_VALUE;\r\n\r\n        const whatWillRender = renderingMesh || mesh;\r\n        const indices = whatWillRender!.getIndices()!;\r\n\r\n        for (let index = startIndex; index < startIndex + indexCount; index++) {\r\n            const vertexIndex = indices[index];\r\n\r\n            if (vertexIndex < minVertexIndex) {\r\n                minVertexIndex = vertexIndex;\r\n            }\r\n            if (vertexIndex > maxVertexIndex) {\r\n                maxVertexIndex = vertexIndex;\r\n            }\r\n        }\r\n\r\n        return new SubMesh(materialIndex, minVertexIndex, maxVertexIndex - minVertexIndex + 1, startIndex, indexCount, mesh, renderingMesh, createBoundingBox);\r\n    }\r\n}\r\n", "import type { ShaderCustomProcessingFunction } from \"../Engines/Processors/shaderProcessingOptions\";\r\nimport type { SmartArray } from \"../Misc/smartArray\";\r\n\r\nimport type { BaseTexture } from \"./Textures/baseTexture\";\r\nimport type { EffectFallbacks } from \"./effectFallbacks\";\r\nimport type { MaterialDefines } from \"./materialDefines\";\r\nimport type { UniformBuffer } from \"./uniformBuffer\";\r\nimport type { SubMesh } from \"../Meshes/subMesh\";\r\nimport type { AbstractMesh } from \"../Meshes/abstractMesh\";\r\nimport type { IAnimatable } from \"../Animations/animatable.interface\";\r\nimport type { RenderTargetTexture } from \"./Textures/renderTargetTexture\";\r\n\r\n/** @internal */\r\nexport type MaterialPluginCreated = {};\r\n\r\n/** @internal */\r\nexport type MaterialPluginDisposed = {\r\n    forceDisposeTextures?: boolean;\r\n};\r\n\r\n/** @internal */\r\nexport type MaterialPluginHasTexture = {\r\n    hasTexture: boolean;\r\n    texture: BaseTexture;\r\n};\r\n\r\n/** @internal */\r\nexport type MaterialPluginIsReadyForSubMesh = {\r\n    isReadyForSubMesh: boolean;\r\n    defines: MaterialDefines;\r\n    subMesh: SubMesh;\r\n};\r\n\r\n/** @internal */\r\nexport type MaterialPluginGetDefineNames = {\r\n    defineNames?: { [name: string]: { type: string; default: any } };\r\n};\r\n\r\n/** @internal */\r\nexport type MaterialPluginPrepareEffect = {\r\n    defines: MaterialDefines;\r\n    fallbacks: EffectFallbacks;\r\n    fallbackRank: number;\r\n    customCode?: ShaderCustomProcessingFunction;\r\n    attributes: string[];\r\n    uniforms: string[];\r\n    samplers: string[];\r\n    uniformBuffersNames: string[];\r\n    mesh: AbstractMesh;\r\n    indexParameters: any;\r\n};\r\n\r\n/** @internal */\r\nexport type MaterialPluginPrepareDefines = {\r\n    defines: MaterialDefines;\r\n    mesh: AbstractMesh;\r\n};\r\n\r\n/** @internal */\r\nexport type MaterialPluginPrepareUniformBuffer = {\r\n    ubo: UniformBuffer;\r\n};\r\n\r\n/** @internal */\r\nexport type MaterialPluginBindForSubMesh = {\r\n    subMesh: SubMesh;\r\n};\r\n\r\n/** @internal */\r\nexport type MaterialPluginGetAnimatables = {\r\n    animatables: IAnimatable[];\r\n};\r\n\r\n/** @internal */\r\nexport type MaterialPluginGetActiveTextures = {\r\n    activeTextures: BaseTexture[];\r\n};\r\n\r\n/** @internal */\r\nexport type MaterialPluginFillRenderTargetTextures = {\r\n    renderTargets: SmartArray<RenderTargetTexture>;\r\n};\r\n\r\n/** @internal */\r\nexport type MaterialPluginHasRenderTargetTextures = {\r\n    hasRenderTargetTextures: boolean;\r\n};\r\n\r\n/** @internal */\r\nexport type MaterialPluginHardBindForSubMesh = {\r\n    subMesh: SubMesh;\r\n};\r\n\r\n/**\r\n * @internal\r\n */\r\nexport enum MaterialPluginEvent {\r\n    Created = 0x0001,\r\n    Disposed = 0x0002,\r\n    GetDefineNames = 0x0004,\r\n    PrepareUniformBuffer = 0x0008,\r\n    IsReadyForSubMesh = 0x0010,\r\n    PrepareDefines = 0x0020,\r\n    BindForSubMesh = 0x0040,\r\n    PrepareEffect = 0x0080,\r\n    GetAnimatables = 0x0100,\r\n    GetActiveTextures = 0x0200,\r\n    HasTexture = 0x0400,\r\n    FillRenderTargetTextures = 0x0800,\r\n    HasRenderTargetTextures = 0x1000,\r\n    HardBindForSubMesh = 0x2000,\r\n}\r\n", "import type { Effect } from \"./effect\";\r\nimport type { IClipPlanesHolder } from \"../Misc/interfaces/iClipPlanesHolder\";\r\nimport type { Nullable } from \"../types\";\r\nimport type { Plane } from \"../Maths/math.plane\";\r\n\r\n/** @internal */\r\nexport function addClipPlaneUniforms(uniforms: string[]): void {\r\n    if (uniforms.indexOf(\"vClipPlane\") === -1) {\r\n        uniforms.push(\"vClipPlane\");\r\n    }\r\n    if (uniforms.indexOf(\"vClipPlane2\") === -1) {\r\n        uniforms.push(\"vClipPlane2\");\r\n    }\r\n    if (uniforms.indexOf(\"vClipPlane3\") === -1) {\r\n        uniforms.push(\"vClipPlane3\");\r\n    }\r\n    if (uniforms.indexOf(\"vClipPlane4\") === -1) {\r\n        uniforms.push(\"vClipPlane4\");\r\n    }\r\n    if (uniforms.indexOf(\"vClipPlane5\") === -1) {\r\n        uniforms.push(\"vClipPlane5\");\r\n    }\r\n    if (uniforms.indexOf(\"vClipPlane6\") === -1) {\r\n        uniforms.push(\"vClipPlane6\");\r\n    }\r\n}\r\n\r\n/** @internal */\r\nexport function prepareStringDefinesForClipPlanes(primaryHolder: IClipPlanesHolder, secondaryHolder: IClipPlanesHolder, defines: string[]): void {\r\n    const clipPlane = !!(primaryHolder.clipPlane ?? secondaryHolder.clipPlane);\r\n    const clipPlane2 = !!(primaryHolder.clipPlane2 ?? secondaryHolder.clipPlane2);\r\n    const clipPlane3 = !!(primaryHolder.clipPlane3 ?? secondaryHolder.clipPlane3);\r\n    const clipPlane4 = !!(primaryHolder.clipPlane4 ?? secondaryHolder.clipPlane4);\r\n    const clipPlane5 = !!(primaryHolder.clipPlane5 ?? secondaryHolder.clipPlane5);\r\n    const clipPlane6 = !!(primaryHolder.clipPlane6 ?? secondaryHolder.clipPlane6);\r\n\r\n    if (clipPlane) defines.push(\"#define CLIPPLANE\");\r\n    if (clipPlane2) defines.push(\"#define CLIPPLANE2\");\r\n    if (clipPlane3) defines.push(\"#define CLIPPLANE3\");\r\n    if (clipPlane4) defines.push(\"#define CLIPPLANE4\");\r\n    if (clipPlane5) defines.push(\"#define CLIPPLANE5\");\r\n    if (clipPlane6) defines.push(\"#define CLIPPLANE6\");\r\n}\r\n\r\n/** @internal */\r\nexport function prepareDefinesForClipPlanes(primaryHolder: IClipPlanesHolder, secondaryHolder: IClipPlanesHolder, defines: Record<string, any>): boolean {\r\n    let changed = false;\r\n\r\n    const clipPlane = !!(primaryHolder.clipPlane ?? secondaryHolder.clipPlane);\r\n    const clipPlane2 = !!(primaryHolder.clipPlane2 ?? secondaryHolder.clipPlane2);\r\n    const clipPlane3 = !!(primaryHolder.clipPlane3 ?? secondaryHolder.clipPlane3);\r\n    const clipPlane4 = !!(primaryHolder.clipPlane4 ?? secondaryHolder.clipPlane4);\r\n    const clipPlane5 = !!(primaryHolder.clipPlane5 ?? secondaryHolder.clipPlane5);\r\n    const clipPlane6 = !!(primaryHolder.clipPlane6 ?? secondaryHolder.clipPlane6);\r\n\r\n    // Do not factorize this code, it breaks browsers optimizations.\r\n    if (defines[\"CLIPPLANE\"] !== clipPlane) {\r\n        defines[\"CLIPPLANE\"] = clipPlane;\r\n        changed = true;\r\n    }\r\n    if (defines[\"CLIPPLANE2\"] !== clipPlane2) {\r\n        defines[\"CLIPPLANE2\"] = clipPlane2;\r\n        changed = true;\r\n    }\r\n    if (defines[\"CLIPPLANE3\"] !== clipPlane3) {\r\n        defines[\"CLIPPLANE3\"] = clipPlane3;\r\n        changed = true;\r\n    }\r\n    if (defines[\"CLIPPLANE4\"] !== clipPlane4) {\r\n        defines[\"CLIPPLANE4\"] = clipPlane4;\r\n        changed = true;\r\n    }\r\n    if (defines[\"CLIPPLANE5\"] !== clipPlane5) {\r\n        defines[\"CLIPPLANE5\"] = clipPlane5;\r\n        changed = true;\r\n    }\r\n    if (defines[\"CLIPPLANE6\"] !== clipPlane6) {\r\n        defines[\"CLIPPLANE6\"] = clipPlane6;\r\n        changed = true;\r\n    }\r\n\r\n    return changed;\r\n}\r\n\r\n/** @internal */\r\nexport function bindClipPlane(effect: Effect, primaryHolder: IClipPlanesHolder, secondaryHolder: IClipPlanesHolder): void {\r\n    let clipPlane = primaryHolder.clipPlane ?? secondaryHolder.clipPlane;\r\n    setClipPlane(effect, \"vClipPlane\", clipPlane);\r\n    clipPlane = primaryHolder.clipPlane2 ?? secondaryHolder.clipPlane2;\r\n    setClipPlane(effect, \"vClipPlane2\", clipPlane);\r\n    clipPlane = primaryHolder.clipPlane3 ?? secondaryHolder.clipPlane3;\r\n    setClipPlane(effect, \"vClipPlane3\", clipPlane);\r\n    clipPlane = primaryHolder.clipPlane4 ?? secondaryHolder.clipPlane4;\r\n    setClipPlane(effect, \"vClipPlane4\", clipPlane);\r\n    clipPlane = primaryHolder.clipPlane5 ?? secondaryHolder.clipPlane5;\r\n    setClipPlane(effect, \"vClipPlane5\", clipPlane);\r\n    clipPlane = primaryHolder.clipPlane6 ?? secondaryHolder.clipPlane6;\r\n    setClipPlane(effect, \"vClipPlane6\", clipPlane);\r\n}\r\n\r\nfunction setClipPlane(effect: Effect, uniformName: string, clipPlane: Nullable<Plane>): void {\r\n    if (clipPlane) {\r\n        effect.setFloat4(uniformName, clipPlane.normal.x, clipPlane.normal.y, clipPlane.normal.z, clipPlane.d);\r\n    }\r\n}\r\n", "import { Logger } from \"../Misc/logger\";\r\nimport type { Camera } from \"../Cameras/camera\";\r\nimport type { Scene } from \"../scene\";\r\nimport type { Effect, IEffectCreationOptions } from \"./effect\";\r\nimport type { AbstractMesh } from \"../Meshes/abstractMesh\";\r\nimport { Constants } from \"../Engines/constants\";\r\nimport { Color3 } from \"../Maths/math.color\";\r\nimport { EngineStore } from \"../Engines/engineStore\";\r\nimport type { Mesh } from \"../Meshes/mesh\";\r\nimport type { UniformBuffer } from \"./uniformBuffer\";\r\nimport type { BaseTexture } from \"./Textures/baseTexture\";\r\nimport type { PrePassConfiguration } from \"./prePassConfiguration\";\r\nimport type { Light } from \"../Lights/light\";\r\nimport type { MaterialDefines } from \"./materialDefines\";\r\nimport type { EffectFallbacks } from \"./effectFallbacks\";\r\nimport { LightConstants } from \"../Lights/lightConstants\";\r\nimport type { Engine } from \"../Engines/engine\";\r\nimport type { Material } from \"./material\";\r\nimport type { Nullable } from \"../types\";\r\nimport { prepareDefinesForClipPlanes } from \"./clipPlaneMaterialHelper\";\r\n\r\n// Temps\r\nconst _TempFogColor = Color3.Black();\r\nconst _TmpMorphInfluencers = { NUM_MORPH_INFLUENCERS: 0 };\r\n\r\n/**\r\n * Binds the logarithmic depth information from the scene to the effect for the given defines.\r\n * @param defines The generated defines used in the effect\r\n * @param effect The effect we are binding the data to\r\n * @param scene The scene we are willing to render with logarithmic scale for\r\n */\r\nexport function BindLogDepth(defines: any, effect: Effect, scene: Scene): void {\r\n    if (!defines || defines[\"LOGARITHMICDEPTH\"] || (defines.indexOf && defines.indexOf(\"LOGARITHMICDEPTH\") >= 0)) {\r\n        const camera = scene.activeCamera as Camera;\r\n        if (camera.mode === Constants.ORTHOGRAPHIC_CAMERA) {\r\n            Logger.Error(\"Logarithmic depth is not compatible with orthographic cameras!\", 20);\r\n        }\r\n        effect.setFloat(\"logarithmicDepthConstant\", 2.0 / (Math.log(camera.maxZ + 1.0) / Math.LN2));\r\n    }\r\n}\r\n\r\n/**\r\n * Binds the fog information from the scene to the effect for the given mesh.\r\n * @param scene The scene the lights belongs to\r\n * @param mesh The mesh we are binding the information to render\r\n * @param effect The effect we are binding the data to\r\n * @param linearSpace Defines if the fog effect is applied in linear space\r\n */\r\nexport function BindFogParameters(scene: Scene, mesh?: AbstractMesh, effect?: Effect, linearSpace = false): void {\r\n    if (effect && scene.fogEnabled && (!mesh || mesh.applyFog) && scene.fogMode !== Constants.FOGMODE_NONE) {\r\n        effect.setFloat4(\"vFogInfos\", scene.fogMode, scene.fogStart, scene.fogEnd, scene.fogDensity);\r\n        // Convert fog color to linear space if used in a linear space computed shader.\r\n        if (linearSpace) {\r\n            scene.fogColor.toLinearSpaceToRef(_TempFogColor, scene.getEngine().useExactSrgbConversions);\r\n            effect.setColor3(\"vFogColor\", _TempFogColor);\r\n        } else {\r\n            effect.setColor3(\"vFogColor\", scene.fogColor);\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * Prepares the list of attributes required for morph targets according to the effect defines.\r\n * @param attribs The current list of supported attribs\r\n * @param mesh The mesh to prepare the morph targets attributes for\r\n * @param influencers The number of influencers\r\n */\r\nexport function PrepareAttributesForMorphTargetsInfluencers(attribs: string[], mesh: AbstractMesh, influencers: number): void {\r\n    _TmpMorphInfluencers.NUM_MORPH_INFLUENCERS = influencers;\r\n    PrepareAttributesForMorphTargets(attribs, mesh, _TmpMorphInfluencers);\r\n}\r\n\r\n/**\r\n * Prepares the list of attributes required for morph targets according to the effect defines.\r\n * @param attribs The current list of supported attribs\r\n * @param mesh The mesh to prepare the morph targets attributes for\r\n * @param defines The current Defines of the effect\r\n */\r\nexport function PrepareAttributesForMorphTargets(attribs: string[], mesh: AbstractMesh, defines: any): void {\r\n    const influencers = defines[\"NUM_MORPH_INFLUENCERS\"];\r\n\r\n    if (influencers > 0 && EngineStore.LastCreatedEngine) {\r\n        const maxAttributesCount = EngineStore.LastCreatedEngine.getCaps().maxVertexAttribs;\r\n        const manager = (mesh as Mesh).morphTargetManager;\r\n        if (manager?.isUsingTextureForTargets) {\r\n            return;\r\n        }\r\n        const normal = manager && manager.supportsNormals && defines[\"NORMAL\"];\r\n        const tangent = manager && manager.supportsTangents && defines[\"TANGENT\"];\r\n        const uv = manager && manager.supportsUVs && defines[\"UV1\"];\r\n        for (let index = 0; index < influencers; index++) {\r\n            attribs.push(Constants.PositionKind + index);\r\n\r\n            if (normal) {\r\n                attribs.push(Constants.NormalKind + index);\r\n            }\r\n\r\n            if (tangent) {\r\n                attribs.push(Constants.TangentKind + index);\r\n            }\r\n\r\n            if (uv) {\r\n                attribs.push(Constants.UVKind + \"_\" + index);\r\n            }\r\n\r\n            if (attribs.length > maxAttributesCount) {\r\n                Logger.Error(\"Cannot add more vertex attributes for mesh \" + mesh.name);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * Add the list of attributes required for instances to the attribs array.\r\n * @param attribs The current list of supported attribs\r\n * @param needsPreviousMatrices If the shader needs previous matrices\r\n */\r\nexport function PushAttributesForInstances(attribs: string[], needsPreviousMatrices: boolean = false): void {\r\n    attribs.push(\"world0\");\r\n    attribs.push(\"world1\");\r\n    attribs.push(\"world2\");\r\n    attribs.push(\"world3\");\r\n    if (needsPreviousMatrices) {\r\n        attribs.push(\"previousWorld0\");\r\n        attribs.push(\"previousWorld1\");\r\n        attribs.push(\"previousWorld2\");\r\n        attribs.push(\"previousWorld3\");\r\n    }\r\n}\r\n\r\n/**\r\n * Binds the morph targets information from the mesh to the effect.\r\n * @param abstractMesh The mesh we are binding the information to render\r\n * @param effect The effect we are binding the data to\r\n */\r\nexport function BindMorphTargetParameters(abstractMesh: AbstractMesh, effect: Effect): void {\r\n    const manager = (<Mesh>abstractMesh).morphTargetManager;\r\n    if (!abstractMesh || !manager) {\r\n        return;\r\n    }\r\n\r\n    effect.setFloatArray(\"morphTargetInfluences\", manager.influences);\r\n}\r\n\r\n/**\r\n * Binds the scene's uniform buffer to the effect.\r\n * @param effect defines the effect to bind to the scene uniform buffer\r\n * @param sceneUbo defines the uniform buffer storing scene data\r\n */\r\nexport function BindSceneUniformBuffer(effect: Effect, sceneUbo: UniformBuffer): void {\r\n    sceneUbo.bindToEffect(effect, \"Scene\");\r\n}\r\n\r\n/**\r\n * Helps preparing the defines values about the UVs in used in the effect.\r\n * UVs are shared as much as we can across channels in the shaders.\r\n * @param texture The texture we are preparing the UVs for\r\n * @param defines The defines to update\r\n * @param key The channel key \"diffuse\", \"specular\"... used in the shader\r\n */\r\nexport function PrepareDefinesForMergedUV(texture: BaseTexture, defines: any, key: string): void {\r\n    defines._needUVs = true;\r\n    defines[key] = true;\r\n    if (texture.optimizeUVAllocation && texture.getTextureMatrix().isIdentityAs3x2()) {\r\n        defines[key + \"DIRECTUV\"] = texture.coordinatesIndex + 1;\r\n        defines[\"MAINUV\" + (texture.coordinatesIndex + 1)] = true;\r\n    } else {\r\n        defines[key + \"DIRECTUV\"] = 0;\r\n    }\r\n}\r\n\r\n/**\r\n * Binds a texture matrix value to its corresponding uniform\r\n * @param texture The texture to bind the matrix for\r\n * @param uniformBuffer The uniform buffer receiving the data\r\n * @param key The channel key \"diffuse\", \"specular\"... used in the shader\r\n */\r\nexport function BindTextureMatrix(texture: BaseTexture, uniformBuffer: UniformBuffer, key: string): void {\r\n    const matrix = texture.getTextureMatrix();\r\n\r\n    uniformBuffer.updateMatrix(key + \"Matrix\", matrix);\r\n}\r\n\r\n/**\r\n * Prepares the list of attributes required for baked vertex animations according to the effect defines.\r\n * @param attribs The current list of supported attribs\r\n * @param mesh The mesh to prepare for baked vertex animations\r\n * @param defines The current Defines of the effect\r\n */\r\nexport function PrepareAttributesForBakedVertexAnimation(attribs: string[], mesh: AbstractMesh, defines: any): void {\r\n    const enabled = defines[\"BAKED_VERTEX_ANIMATION_TEXTURE\"] && defines[\"INSTANCES\"];\r\n\r\n    if (enabled) {\r\n        attribs.push(\"bakedVertexAnimationSettingsInstanced\");\r\n    }\r\n}\r\n\r\n// Copies the bones transformation matrices into the target array and returns the target's reference\r\nfunction _CopyBonesTransformationMatrices(source: Float32Array, target: Float32Array): Float32Array {\r\n    target.set(source);\r\n\r\n    return target;\r\n}\r\n\r\n/**\r\n * Binds the bones information from the mesh to the effect.\r\n * @param mesh The mesh we are binding the information to render\r\n * @param effect The effect we are binding the data to\r\n * @param prePassConfiguration Configuration for the prepass, in case prepass is activated\r\n */\r\nexport function BindBonesParameters(mesh?: AbstractMesh, effect?: Effect, prePassConfiguration?: PrePassConfiguration): void {\r\n    if (!effect || !mesh) {\r\n        return;\r\n    }\r\n    if (mesh.computeBonesUsingShaders && effect._bonesComputationForcedToCPU) {\r\n        mesh.computeBonesUsingShaders = false;\r\n    }\r\n\r\n    if (mesh.useBones && mesh.computeBonesUsingShaders && mesh.skeleton) {\r\n        const skeleton = mesh.skeleton;\r\n\r\n        if (skeleton.isUsingTextureForMatrices && effect.getUniformIndex(\"boneTextureWidth\") > -1) {\r\n            const boneTexture = skeleton.getTransformMatrixTexture(mesh);\r\n            effect.setTexture(\"boneSampler\", boneTexture);\r\n            effect.setFloat(\"boneTextureWidth\", 4.0 * (skeleton.bones.length + 1));\r\n        } else {\r\n            const matrices = skeleton.getTransformMatrices(mesh);\r\n\r\n            if (matrices) {\r\n                effect.setMatrices(\"mBones\", matrices);\r\n                if (prePassConfiguration && mesh.getScene().prePassRenderer && mesh.getScene().prePassRenderer!.getIndex(Constants.PREPASS_VELOCITY_TEXTURE_TYPE)) {\r\n                    if (!prePassConfiguration.previousBones[mesh.uniqueId]) {\r\n                        prePassConfiguration.previousBones[mesh.uniqueId] = matrices.slice();\r\n                    }\r\n                    effect.setMatrices(\"mPreviousBones\", prePassConfiguration.previousBones[mesh.uniqueId]);\r\n                    _CopyBonesTransformationMatrices(matrices, prePassConfiguration.previousBones[mesh.uniqueId]);\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * Binds the light information to the effect.\r\n * @param light The light containing the generator\r\n * @param effect The effect we are binding the data to\r\n * @param lightIndex The light index in the effect used to render\r\n */\r\nexport function BindLightProperties(light: Light, effect: Effect, lightIndex: number): void {\r\n    light.transferToEffect(effect, lightIndex + \"\");\r\n}\r\n\r\n/**\r\n * Binds the lights information from the scene to the effect for the given mesh.\r\n * @param light Light to bind\r\n * @param lightIndex Light index\r\n * @param scene The scene where the light belongs to\r\n * @param effect The effect we are binding the data to\r\n * @param useSpecular Defines if specular is supported\r\n * @param receiveShadows Defines if the effect (mesh) we bind the light for receives shadows\r\n */\r\nexport function BindLight(light: Light, lightIndex: number, scene: Scene, effect: Effect, useSpecular: boolean, receiveShadows = true): void {\r\n    light._bindLight(lightIndex, scene, effect, useSpecular, receiveShadows);\r\n}\r\n\r\n/**\r\n * Binds the lights information from the scene to the effect for the given mesh.\r\n * @param scene The scene the lights belongs to\r\n * @param mesh The mesh we are binding the information to render\r\n * @param effect The effect we are binding the data to\r\n * @param defines The generated defines for the effect\r\n * @param maxSimultaneousLights The maximum number of light that can be bound to the effect\r\n */\r\nexport function BindLights(scene: Scene, mesh: AbstractMesh, effect: Effect, defines: any, maxSimultaneousLights = 4): void {\r\n    const len = Math.min(mesh.lightSources.length, maxSimultaneousLights);\r\n\r\n    for (let i = 0; i < len; i++) {\r\n        const light = mesh.lightSources[i];\r\n        BindLight(light, i, scene, effect, typeof defines === \"boolean\" ? defines : defines[\"SPECULARTERM\"], mesh.receiveShadows);\r\n    }\r\n}\r\n\r\n/**\r\n * Prepares the list of attributes required for bones according to the effect defines.\r\n * @param attribs The current list of supported attribs\r\n * @param mesh The mesh to prepare the bones attributes for\r\n * @param defines The current Defines of the effect\r\n * @param fallbacks The current effect fallback strategy\r\n */\r\nexport function PrepareAttributesForBones(attribs: string[], mesh: AbstractMesh, defines: any, fallbacks: EffectFallbacks): void {\r\n    if (defines[\"NUM_BONE_INFLUENCERS\"] > 0) {\r\n        fallbacks.addCPUSkinningFallback(0, mesh);\r\n\r\n        attribs.push(Constants.MatricesIndicesKind);\r\n        attribs.push(Constants.MatricesWeightsKind);\r\n        if (defines[\"NUM_BONE_INFLUENCERS\"] > 4) {\r\n            attribs.push(Constants.MatricesIndicesExtraKind);\r\n            attribs.push(Constants.MatricesWeightsExtraKind);\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * Check and prepare the list of attributes required for instances according to the effect defines.\r\n * @param attribs The current list of supported attribs\r\n * @param defines The current MaterialDefines of the effect\r\n */\r\nexport function PrepareAttributesForInstances(attribs: string[], defines: MaterialDefines): void {\r\n    if (defines[\"INSTANCES\"] || defines[\"THIN_INSTANCES\"]) {\r\n        PushAttributesForInstances(attribs, !!defines[\"PREPASS_VELOCITY\"]);\r\n    }\r\n\r\n    if (defines.INSTANCESCOLOR) {\r\n        attribs.push(Constants.ColorInstanceKind);\r\n    }\r\n}\r\n\r\n/**\r\n * This helps decreasing rank by rank the shadow quality (0 being the highest rank and quality)\r\n * @param defines The defines to update while falling back\r\n * @param fallbacks The authorized effect fallbacks\r\n * @param maxSimultaneousLights The maximum number of lights allowed\r\n * @param rank the current rank of the Effect\r\n * @returns The newly affected rank\r\n */\r\nexport function HandleFallbacksForShadows(defines: any, fallbacks: EffectFallbacks, maxSimultaneousLights = 4, rank = 0): number {\r\n    let lightFallbackRank = 0;\r\n    for (let lightIndex = 0; lightIndex < maxSimultaneousLights; lightIndex++) {\r\n        if (!defines[\"LIGHT\" + lightIndex]) {\r\n            break;\r\n        }\r\n\r\n        if (lightIndex > 0) {\r\n            lightFallbackRank = rank + lightIndex;\r\n            fallbacks.addFallback(lightFallbackRank, \"LIGHT\" + lightIndex);\r\n        }\r\n\r\n        if (!defines[\"SHADOWS\"]) {\r\n            if (defines[\"SHADOW\" + lightIndex]) {\r\n                fallbacks.addFallback(rank, \"SHADOW\" + lightIndex);\r\n            }\r\n\r\n            if (defines[\"SHADOWPCF\" + lightIndex]) {\r\n                fallbacks.addFallback(rank, \"SHADOWPCF\" + lightIndex);\r\n            }\r\n\r\n            if (defines[\"SHADOWPCSS\" + lightIndex]) {\r\n                fallbacks.addFallback(rank, \"SHADOWPCSS\" + lightIndex);\r\n            }\r\n\r\n            if (defines[\"SHADOWPOISSON\" + lightIndex]) {\r\n                fallbacks.addFallback(rank, \"SHADOWPOISSON\" + lightIndex);\r\n            }\r\n\r\n            if (defines[\"SHADOWESM\" + lightIndex]) {\r\n                fallbacks.addFallback(rank, \"SHADOWESM\" + lightIndex);\r\n            }\r\n\r\n            if (defines[\"SHADOWCLOSEESM\" + lightIndex]) {\r\n                fallbacks.addFallback(rank, \"SHADOWCLOSEESM\" + lightIndex);\r\n            }\r\n        }\r\n    }\r\n    return lightFallbackRank++;\r\n}\r\n\r\n/**\r\n * Gets the current status of the fog (should it be enabled?)\r\n * @param mesh defines the mesh to evaluate for fog support\r\n * @param scene defines the hosting scene\r\n * @returns true if fog must be enabled\r\n */\r\nexport function GetFogState(mesh: AbstractMesh, scene: Scene) {\r\n    return scene.fogEnabled && mesh.applyFog && scene.fogMode !== Constants.FOGMODE_NONE;\r\n}\r\n\r\n/**\r\n * Helper used to prepare the list of defines associated with misc. values for shader compilation\r\n * @param mesh defines the current mesh\r\n * @param scene defines the current scene\r\n * @param useLogarithmicDepth defines if logarithmic depth has to be turned on\r\n * @param pointsCloud defines if point cloud rendering has to be turned on\r\n * @param fogEnabled defines if fog has to be turned on\r\n * @param alphaTest defines if alpha testing has to be turned on\r\n * @param defines defines the current list of defines\r\n * @param applyDecalAfterDetail Defines if the decal is applied after or before the detail\r\n */\r\nexport function PrepareDefinesForMisc(\r\n    mesh: AbstractMesh,\r\n    scene: Scene,\r\n    useLogarithmicDepth: boolean,\r\n    pointsCloud: boolean,\r\n    fogEnabled: boolean,\r\n    alphaTest: boolean,\r\n    defines: any,\r\n    applyDecalAfterDetail: boolean = false\r\n): void {\r\n    if (defines._areMiscDirty) {\r\n        defines[\"LOGARITHMICDEPTH\"] = useLogarithmicDepth;\r\n        defines[\"POINTSIZE\"] = pointsCloud;\r\n        defines[\"FOG\"] = fogEnabled && GetFogState(mesh, scene);\r\n        defines[\"NONUNIFORMSCALING\"] = mesh.nonUniformScaling;\r\n        defines[\"ALPHATEST\"] = alphaTest;\r\n        defines[\"DECAL_AFTER_DETAIL\"] = applyDecalAfterDetail;\r\n    }\r\n}\r\n\r\n/**\r\n * Prepares the defines related to the light information passed in parameter\r\n * @param scene The scene we are intending to draw\r\n * @param mesh The mesh the effect is compiling for\r\n * @param defines The defines to update\r\n * @param specularSupported Specifies whether specular is supported or not (override lights data)\r\n * @param maxSimultaneousLights Specifies how manuy lights can be added to the effect at max\r\n * @param disableLighting Specifies whether the lighting is disabled (override scene and light)\r\n * @returns true if normals will be required for the rest of the effect\r\n */\r\nexport function PrepareDefinesForLights(scene: Scene, mesh: AbstractMesh, defines: any, specularSupported: boolean, maxSimultaneousLights = 4, disableLighting = false): boolean {\r\n    if (!defines._areLightsDirty) {\r\n        return defines._needNormals;\r\n    }\r\n\r\n    let lightIndex = 0;\r\n    const state = {\r\n        needNormals: defines._needNormals, // prevents overriding previous reflection or other needs for normals\r\n        needRebuild: false,\r\n        lightmapMode: false,\r\n        shadowEnabled: false,\r\n        specularEnabled: false,\r\n    };\r\n\r\n    if (scene.lightsEnabled && !disableLighting) {\r\n        for (const light of mesh.lightSources) {\r\n            PrepareDefinesForLight(scene, mesh, light, lightIndex, defines, specularSupported, state);\r\n\r\n            lightIndex++;\r\n            if (lightIndex === maxSimultaneousLights) {\r\n                break;\r\n            }\r\n        }\r\n    }\r\n\r\n    defines[\"SPECULARTERM\"] = state.specularEnabled;\r\n    defines[\"SHADOWS\"] = state.shadowEnabled;\r\n\r\n    // Resetting all other lights if any\r\n    for (let index = lightIndex; index < maxSimultaneousLights; index++) {\r\n        if (defines[\"LIGHT\" + index] !== undefined) {\r\n            defines[\"LIGHT\" + index] = false;\r\n            defines[\"HEMILIGHT\" + index] = false;\r\n            defines[\"POINTLIGHT\" + index] = false;\r\n            defines[\"DIRLIGHT\" + index] = false;\r\n            defines[\"SPOTLIGHT\" + index] = false;\r\n            defines[\"SHADOW\" + index] = false;\r\n            defines[\"SHADOWCSM\" + index] = false;\r\n            defines[\"SHADOWCSMDEBUG\" + index] = false;\r\n            defines[\"SHADOWCSMNUM_CASCADES\" + index] = false;\r\n            defines[\"SHADOWCSMUSESHADOWMAXZ\" + index] = false;\r\n            defines[\"SHADOWCSMNOBLEND\" + index] = false;\r\n            defines[\"SHADOWCSM_RIGHTHANDED\" + index] = false;\r\n            defines[\"SHADOWPCF\" + index] = false;\r\n            defines[\"SHADOWPCSS\" + index] = false;\r\n            defines[\"SHADOWPOISSON\" + index] = false;\r\n            defines[\"SHADOWESM\" + index] = false;\r\n            defines[\"SHADOWCLOSEESM\" + index] = false;\r\n            defines[\"SHADOWCUBE\" + index] = false;\r\n            defines[\"SHADOWLOWQUALITY\" + index] = false;\r\n            defines[\"SHADOWMEDIUMQUALITY\" + index] = false;\r\n        }\r\n    }\r\n\r\n    const caps = scene.getEngine().getCaps();\r\n\r\n    if (defines[\"SHADOWFLOAT\"] === undefined) {\r\n        state.needRebuild = true;\r\n    }\r\n\r\n    defines[\"SHADOWFLOAT\"] =\r\n        state.shadowEnabled && ((caps.textureFloatRender && caps.textureFloatLinearFiltering) || (caps.textureHalfFloatRender && caps.textureHalfFloatLinearFiltering));\r\n    defines[\"LIGHTMAPEXCLUDED\"] = state.lightmapMode;\r\n\r\n    if (state.needRebuild) {\r\n        defines.rebuild();\r\n    }\r\n\r\n    return state.needNormals;\r\n}\r\n\r\n/**\r\n * Prepares the defines related to the light information passed in parameter\r\n * @param scene The scene we are intending to draw\r\n * @param mesh The mesh the effect is compiling for\r\n * @param light The light the effect is compiling for\r\n * @param lightIndex The index of the light\r\n * @param defines The defines to update\r\n * @param specularSupported Specifies whether specular is supported or not (override lights data)\r\n * @param state Defines the current state regarding what is needed (normals, etc...)\r\n * @param state.needNormals\r\n * @param state.needRebuild\r\n * @param state.shadowEnabled\r\n * @param state.specularEnabled\r\n * @param state.lightmapMode\r\n */\r\nexport function PrepareDefinesForLight(\r\n    scene: Scene,\r\n    mesh: AbstractMesh,\r\n    light: Light,\r\n    lightIndex: number,\r\n    defines: any,\r\n    specularSupported: boolean,\r\n    state: {\r\n        needNormals: boolean;\r\n        needRebuild: boolean;\r\n        shadowEnabled: boolean;\r\n        specularEnabled: boolean;\r\n        lightmapMode: boolean;\r\n    }\r\n) {\r\n    state.needNormals = true;\r\n\r\n    if (defines[\"LIGHT\" + lightIndex] === undefined) {\r\n        state.needRebuild = true;\r\n    }\r\n\r\n    defines[\"LIGHT\" + lightIndex] = true;\r\n\r\n    defines[\"SPOTLIGHT\" + lightIndex] = false;\r\n    defines[\"HEMILIGHT\" + lightIndex] = false;\r\n    defines[\"POINTLIGHT\" + lightIndex] = false;\r\n    defines[\"DIRLIGHT\" + lightIndex] = false;\r\n\r\n    light.prepareLightSpecificDefines(defines, lightIndex);\r\n\r\n    // FallOff.\r\n    defines[\"LIGHT_FALLOFF_PHYSICAL\" + lightIndex] = false;\r\n    defines[\"LIGHT_FALLOFF_GLTF\" + lightIndex] = false;\r\n    defines[\"LIGHT_FALLOFF_STANDARD\" + lightIndex] = false;\r\n\r\n    switch (light.falloffType) {\r\n        case LightConstants.FALLOFF_GLTF:\r\n            defines[\"LIGHT_FALLOFF_GLTF\" + lightIndex] = true;\r\n            break;\r\n        case LightConstants.FALLOFF_PHYSICAL:\r\n            defines[\"LIGHT_FALLOFF_PHYSICAL\" + lightIndex] = true;\r\n            break;\r\n        case LightConstants.FALLOFF_STANDARD:\r\n            defines[\"LIGHT_FALLOFF_STANDARD\" + lightIndex] = true;\r\n            break;\r\n    }\r\n\r\n    // Specular\r\n    if (specularSupported && !light.specular.equalsFloats(0, 0, 0)) {\r\n        state.specularEnabled = true;\r\n    }\r\n\r\n    // Shadows\r\n    defines[\"SHADOW\" + lightIndex] = false;\r\n    defines[\"SHADOWCSM\" + lightIndex] = false;\r\n    defines[\"SHADOWCSMDEBUG\" + lightIndex] = false;\r\n    defines[\"SHADOWCSMNUM_CASCADES\" + lightIndex] = false;\r\n    defines[\"SHADOWCSMUSESHADOWMAXZ\" + lightIndex] = false;\r\n    defines[\"SHADOWCSMNOBLEND\" + lightIndex] = false;\r\n    defines[\"SHADOWCSM_RIGHTHANDED\" + lightIndex] = false;\r\n    defines[\"SHADOWPCF\" + lightIndex] = false;\r\n    defines[\"SHADOWPCSS\" + lightIndex] = false;\r\n    defines[\"SHADOWPOISSON\" + lightIndex] = false;\r\n    defines[\"SHADOWESM\" + lightIndex] = false;\r\n    defines[\"SHADOWCLOSEESM\" + lightIndex] = false;\r\n    defines[\"SHADOWCUBE\" + lightIndex] = false;\r\n    defines[\"SHADOWLOWQUALITY\" + lightIndex] = false;\r\n    defines[\"SHADOWMEDIUMQUALITY\" + lightIndex] = false;\r\n\r\n    if (mesh && mesh.receiveShadows && scene.shadowsEnabled && light.shadowEnabled) {\r\n        const shadowGenerator = light.getShadowGenerator(scene.activeCamera) ?? light.getShadowGenerator();\r\n        if (shadowGenerator) {\r\n            const shadowMap = shadowGenerator.getShadowMap();\r\n            if (shadowMap) {\r\n                if (shadowMap.renderList && shadowMap.renderList.length > 0) {\r\n                    state.shadowEnabled = true;\r\n                    shadowGenerator.prepareDefines(defines, lightIndex);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    if (light.lightmapMode != LightConstants.LIGHTMAP_DEFAULT) {\r\n        state.lightmapMode = true;\r\n        defines[\"LIGHTMAPEXCLUDED\" + lightIndex] = true;\r\n        defines[\"LIGHTMAPNOSPECULAR\" + lightIndex] = light.lightmapMode == LightConstants.LIGHTMAP_SHADOWSONLY;\r\n    } else {\r\n        defines[\"LIGHTMAPEXCLUDED\" + lightIndex] = false;\r\n        defines[\"LIGHTMAPNOSPECULAR\" + lightIndex] = false;\r\n    }\r\n}\r\n\r\n/**\r\n * Helper used to prepare the list of defines associated with frame values for shader compilation\r\n * @param scene defines the current scene\r\n * @param engine defines the current engine\r\n * @param material defines the material we are compiling the shader for\r\n * @param defines specifies the list of active defines\r\n * @param useInstances defines if instances have to be turned on\r\n * @param useClipPlane defines if clip plane have to be turned on\r\n * @param useThinInstances defines if thin instances have to be turned on\r\n */\r\nexport function PrepareDefinesForFrameBoundValues(\r\n    scene: Scene,\r\n    engine: Engine,\r\n    material: Material,\r\n    defines: any,\r\n    useInstances: boolean,\r\n    useClipPlane: Nullable<boolean> = null,\r\n    useThinInstances: boolean = false\r\n): void {\r\n    let changed = PrepareDefinesForCamera(scene, defines);\r\n\r\n    if (useClipPlane !== false) {\r\n        changed = prepareDefinesForClipPlanes(material, scene, defines);\r\n    }\r\n\r\n    if (defines[\"DEPTHPREPASS\"] !== !engine.getColorWrite()) {\r\n        defines[\"DEPTHPREPASS\"] = !defines[\"DEPTHPREPASS\"];\r\n        changed = true;\r\n    }\r\n\r\n    if (defines[\"INSTANCES\"] !== useInstances) {\r\n        defines[\"INSTANCES\"] = useInstances;\r\n        changed = true;\r\n    }\r\n\r\n    if (defines[\"THIN_INSTANCES\"] !== useThinInstances) {\r\n        defines[\"THIN_INSTANCES\"] = useThinInstances;\r\n        changed = true;\r\n    }\r\n\r\n    if (changed) {\r\n        defines.markAsUnprocessed();\r\n    }\r\n}\r\n\r\n/**\r\n * Prepares the defines for bones\r\n * @param mesh The mesh containing the geometry data we will draw\r\n * @param defines The defines to update\r\n */\r\nexport function PrepareDefinesForBones(mesh: AbstractMesh, defines: any) {\r\n    if (mesh.useBones && mesh.computeBonesUsingShaders && mesh.skeleton) {\r\n        defines[\"NUM_BONE_INFLUENCERS\"] = mesh.numBoneInfluencers;\r\n\r\n        const materialSupportsBoneTexture = defines[\"BONETEXTURE\"] !== undefined;\r\n\r\n        if (mesh.skeleton.isUsingTextureForMatrices && materialSupportsBoneTexture) {\r\n            defines[\"BONETEXTURE\"] = true;\r\n        } else {\r\n            defines[\"BonesPerMesh\"] = mesh.skeleton.bones.length + 1;\r\n            defines[\"BONETEXTURE\"] = materialSupportsBoneTexture ? false : undefined;\r\n\r\n            const prePassRenderer = mesh.getScene().prePassRenderer;\r\n            if (prePassRenderer && prePassRenderer.enabled) {\r\n                const nonExcluded = prePassRenderer.excludedSkinnedMesh.indexOf(mesh) === -1;\r\n                defines[\"BONES_VELOCITY_ENABLED\"] = nonExcluded;\r\n            }\r\n        }\r\n    } else {\r\n        defines[\"NUM_BONE_INFLUENCERS\"] = 0;\r\n        defines[\"BonesPerMesh\"] = 0;\r\n        if (defines[\"BONETEXTURE\"] !== undefined) {\r\n            defines[\"BONETEXTURE\"] = false;\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * Prepares the defines for morph targets\r\n * @param mesh The mesh containing the geometry data we will draw\r\n * @param defines The defines to update\r\n */\r\nexport function PrepareDefinesForMorphTargets(mesh: AbstractMesh, defines: any) {\r\n    const manager = (<Mesh>mesh).morphTargetManager;\r\n    if (manager) {\r\n        defines[\"MORPHTARGETS_UV\"] = manager.supportsUVs && defines[\"UV1\"];\r\n        defines[\"MORPHTARGETS_TANGENT\"] = manager.supportsTangents && defines[\"TANGENT\"];\r\n        defines[\"MORPHTARGETS_NORMAL\"] = manager.supportsNormals && defines[\"NORMAL\"];\r\n        defines[\"NUM_MORPH_INFLUENCERS\"] = manager.numMaxInfluencers || manager.numInfluencers;\r\n        defines[\"MORPHTARGETS\"] = defines[\"NUM_MORPH_INFLUENCERS\"] > 0;\r\n\r\n        defines[\"MORPHTARGETS_TEXTURE\"] = manager.isUsingTextureForTargets;\r\n    } else {\r\n        defines[\"MORPHTARGETS_UV\"] = false;\r\n        defines[\"MORPHTARGETS_TANGENT\"] = false;\r\n        defines[\"MORPHTARGETS_NORMAL\"] = false;\r\n        defines[\"MORPHTARGETS\"] = false;\r\n        defines[\"NUM_MORPH_INFLUENCERS\"] = 0;\r\n    }\r\n}\r\n\r\n/**\r\n * Prepares the defines for baked vertex animation\r\n * @param mesh The mesh containing the geometry data we will draw\r\n * @param defines The defines to update\r\n */\r\nexport function PrepareDefinesForBakedVertexAnimation(mesh: AbstractMesh, defines: any) {\r\n    const manager = (<Mesh>mesh).bakedVertexAnimationManager;\r\n    defines[\"BAKED_VERTEX_ANIMATION_TEXTURE\"] = manager && manager.isEnabled ? true : false;\r\n}\r\n\r\n/**\r\n * Prepares the defines used in the shader depending on the attributes data available in the mesh\r\n * @param mesh The mesh containing the geometry data we will draw\r\n * @param defines The defines to update\r\n * @param useVertexColor Precise whether vertex colors should be used or not (override mesh info)\r\n * @param useBones Precise whether bones should be used or not (override mesh info)\r\n * @param useMorphTargets Precise whether morph targets should be used or not (override mesh info)\r\n * @param useVertexAlpha Precise whether vertex alpha should be used or not (override mesh info)\r\n * @param useBakedVertexAnimation Precise whether baked vertex animation should be used or not (override mesh info)\r\n * @returns false if defines are considered not dirty and have not been checked\r\n */\r\nexport function PrepareDefinesForAttributes(\r\n    mesh: AbstractMesh,\r\n    defines: any,\r\n    useVertexColor: boolean,\r\n    useBones: boolean,\r\n    useMorphTargets = false,\r\n    useVertexAlpha = true,\r\n    useBakedVertexAnimation = true\r\n): boolean {\r\n    if (!defines._areAttributesDirty && defines._needNormals === defines._normals && defines._needUVs === defines._uvs) {\r\n        return false;\r\n    }\r\n\r\n    defines._normals = defines._needNormals;\r\n    defines._uvs = defines._needUVs;\r\n\r\n    defines[\"NORMAL\"] = defines._needNormals && mesh.isVerticesDataPresent(Constants.NormalKind);\r\n\r\n    if (defines._needNormals && mesh.isVerticesDataPresent(Constants.TangentKind)) {\r\n        defines[\"TANGENT\"] = true;\r\n    }\r\n\r\n    for (let i = 1; i <= Constants.MAX_SUPPORTED_UV_SETS; ++i) {\r\n        defines[\"UV\" + i] = defines._needUVs ? mesh.isVerticesDataPresent(`uv${i === 1 ? \"\" : i}`) : false;\r\n    }\r\n\r\n    if (useVertexColor) {\r\n        const hasVertexColors = mesh.useVertexColors && mesh.isVerticesDataPresent(Constants.ColorKind);\r\n        defines[\"VERTEXCOLOR\"] = hasVertexColors;\r\n        defines[\"VERTEXALPHA\"] = mesh.hasVertexAlpha && hasVertexColors && useVertexAlpha;\r\n    }\r\n\r\n    if (mesh.isVerticesDataPresent(Constants.ColorInstanceKind) && (mesh.hasInstances || mesh.hasThinInstances)) {\r\n        defines[\"INSTANCESCOLOR\"] = true;\r\n    }\r\n\r\n    if (useBones) {\r\n        PrepareDefinesForBones(mesh, defines);\r\n    }\r\n\r\n    if (useMorphTargets) {\r\n        PrepareDefinesForMorphTargets(mesh, defines);\r\n    }\r\n\r\n    if (useBakedVertexAnimation) {\r\n        PrepareDefinesForBakedVertexAnimation(mesh, defines);\r\n    }\r\n\r\n    return true;\r\n}\r\n\r\n/**\r\n * Prepares the defines related to multiview\r\n * @param scene The scene we are intending to draw\r\n * @param defines The defines to update\r\n */\r\nexport function PrepareDefinesForMultiview(scene: Scene, defines: any) {\r\n    if (scene.activeCamera) {\r\n        const previousMultiview = defines.MULTIVIEW;\r\n        defines.MULTIVIEW = scene.activeCamera.outputRenderTarget !== null && scene.activeCamera.outputRenderTarget.getViewCount() > 1;\r\n        if (defines.MULTIVIEW != previousMultiview) {\r\n            defines.markAsUnprocessed();\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * Prepares the defines related to order independant transparency\r\n * @param scene The scene we are intending to draw\r\n * @param defines The defines to update\r\n * @param needAlphaBlending Determines if the material needs alpha blending\r\n */\r\nexport function PrepareDefinesForOIT(scene: Scene, defines: any, needAlphaBlending: boolean) {\r\n    const previousDefine = defines.ORDER_INDEPENDENT_TRANSPARENCY;\r\n    const previousDefine16Bits = defines.ORDER_INDEPENDENT_TRANSPARENCY_16BITS;\r\n\r\n    defines.ORDER_INDEPENDENT_TRANSPARENCY = scene.useOrderIndependentTransparency && needAlphaBlending;\r\n    defines.ORDER_INDEPENDENT_TRANSPARENCY_16BITS = !scene.getEngine().getCaps().textureFloatLinearFiltering;\r\n\r\n    if (previousDefine !== defines.ORDER_INDEPENDENT_TRANSPARENCY || previousDefine16Bits !== defines.ORDER_INDEPENDENT_TRANSPARENCY_16BITS) {\r\n        defines.markAsUnprocessed();\r\n    }\r\n}\r\n\r\n/**\r\n * Prepares the defines related to the prepass\r\n * @param scene The scene we are intending to draw\r\n * @param defines The defines to update\r\n * @param canRenderToMRT Indicates if this material renders to several textures in the prepass\r\n */\r\nexport function PrepareDefinesForPrePass(scene: Scene, defines: any, canRenderToMRT: boolean) {\r\n    const previousPrePass = defines.PREPASS;\r\n\r\n    if (!defines._arePrePassDirty) {\r\n        return;\r\n    }\r\n\r\n    const texturesList = [\r\n        {\r\n            type: Constants.PREPASS_POSITION_TEXTURE_TYPE,\r\n            define: \"PREPASS_POSITION\",\r\n            index: \"PREPASS_POSITION_INDEX\",\r\n        },\r\n        {\r\n            type: Constants.PREPASS_VELOCITY_TEXTURE_TYPE,\r\n            define: \"PREPASS_VELOCITY\",\r\n            index: \"PREPASS_VELOCITY_INDEX\",\r\n        },\r\n        {\r\n            type: Constants.PREPASS_REFLECTIVITY_TEXTURE_TYPE,\r\n            define: \"PREPASS_REFLECTIVITY\",\r\n            index: \"PREPASS_REFLECTIVITY_INDEX\",\r\n        },\r\n        {\r\n            type: Constants.PREPASS_IRRADIANCE_TEXTURE_TYPE,\r\n            define: \"PREPASS_IRRADIANCE\",\r\n            index: \"PREPASS_IRRADIANCE_INDEX\",\r\n        },\r\n        {\r\n            type: Constants.PREPASS_ALBEDO_SQRT_TEXTURE_TYPE,\r\n            define: \"PREPASS_ALBEDO_SQRT\",\r\n            index: \"PREPASS_ALBEDO_SQRT_INDEX\",\r\n        },\r\n        {\r\n            type: Constants.PREPASS_DEPTH_TEXTURE_TYPE,\r\n            define: \"PREPASS_DEPTH\",\r\n            index: \"PREPASS_DEPTH_INDEX\",\r\n        },\r\n        {\r\n            type: Constants.PREPASS_NORMAL_TEXTURE_TYPE,\r\n            define: \"PREPASS_NORMAL\",\r\n            index: \"PREPASS_NORMAL_INDEX\",\r\n        },\r\n    ];\r\n\r\n    if (scene.prePassRenderer && scene.prePassRenderer.enabled && canRenderToMRT) {\r\n        defines.PREPASS = true;\r\n        defines.SCENE_MRT_COUNT = scene.prePassRenderer.mrtCount;\r\n        defines.PREPASS_NORMAL_WORLDSPACE = scene.prePassRenderer.generateNormalsInWorldSpace;\r\n\r\n        for (let i = 0; i < texturesList.length; i++) {\r\n            const index = scene.prePassRenderer.getIndex(texturesList[i].type);\r\n            if (index !== -1) {\r\n                defines[texturesList[i].define] = true;\r\n                defines[texturesList[i].index] = index;\r\n            } else {\r\n                defines[texturesList[i].define] = false;\r\n            }\r\n        }\r\n    } else {\r\n        defines.PREPASS = false;\r\n        for (let i = 0; i < texturesList.length; i++) {\r\n            defines[texturesList[i].define] = false;\r\n        }\r\n    }\r\n\r\n    if (defines.PREPASS != previousPrePass) {\r\n        defines.markAsUnprocessed();\r\n        defines.markAsImageProcessingDirty();\r\n    }\r\n}\r\n\r\n/**\r\n * Helper used to prepare the defines relative to the active camera\r\n * @param scene defines the current scene\r\n * @param defines specifies the list of active defines\r\n * @returns true if the defines have been updated, else false\r\n */\r\nexport function PrepareDefinesForCamera(scene: Scene, defines: any): boolean {\r\n    let changed = false;\r\n\r\n    if (scene.activeCamera) {\r\n        const wasOrtho = defines[\"CAMERA_ORTHOGRAPHIC\"] ? 1 : 0;\r\n        const wasPersp = defines[\"CAMERA_PERSPECTIVE\"] ? 1 : 0;\r\n        const isOrtho = scene.activeCamera.mode === Constants.ORTHOGRAPHIC_CAMERA ? 1 : 0;\r\n        const isPersp = scene.activeCamera.mode === Constants.PERSPECTIVE_CAMERA ? 1 : 0;\r\n\r\n        if (wasOrtho ^ isOrtho || wasPersp ^ isPersp) {\r\n            defines[\"CAMERA_ORTHOGRAPHIC\"] = isOrtho === 1;\r\n            defines[\"CAMERA_PERSPECTIVE\"] = isPersp === 1;\r\n            changed = true;\r\n        }\r\n    }\r\n\r\n    return changed;\r\n}\r\n\r\n/**\r\n * Prepares the uniforms and samplers list to be used in the effect (for a specific light)\r\n * @param lightIndex defines the light index\r\n * @param uniformsList The uniform list\r\n * @param samplersList The sampler list\r\n * @param projectedLightTexture defines if projected texture must be used\r\n * @param uniformBuffersList defines an optional list of uniform buffers\r\n * @param updateOnlyBuffersList True to only update the uniformBuffersList array\r\n */\r\nexport function PrepareUniformsAndSamplersForLight(\r\n    lightIndex: number,\r\n    uniformsList: string[],\r\n    samplersList: string[],\r\n    projectedLightTexture?: any,\r\n    uniformBuffersList: Nullable<string[]> = null,\r\n    updateOnlyBuffersList = false\r\n) {\r\n    if (uniformBuffersList) {\r\n        uniformBuffersList.push(\"Light\" + lightIndex);\r\n    }\r\n\r\n    if (updateOnlyBuffersList) {\r\n        return;\r\n    }\r\n\r\n    uniformsList.push(\r\n        \"vLightData\" + lightIndex,\r\n        \"vLightDiffuse\" + lightIndex,\r\n        \"vLightSpecular\" + lightIndex,\r\n        \"vLightDirection\" + lightIndex,\r\n        \"vLightFalloff\" + lightIndex,\r\n        \"vLightGround\" + lightIndex,\r\n        \"lightMatrix\" + lightIndex,\r\n        \"shadowsInfo\" + lightIndex,\r\n        \"depthValues\" + lightIndex\r\n    );\r\n\r\n    samplersList.push(\"shadowSampler\" + lightIndex);\r\n    samplersList.push(\"depthSampler\" + lightIndex);\r\n\r\n    uniformsList.push(\r\n        \"viewFrustumZ\" + lightIndex,\r\n        \"cascadeBlendFactor\" + lightIndex,\r\n        \"lightSizeUVCorrection\" + lightIndex,\r\n        \"depthCorrection\" + lightIndex,\r\n        \"penumbraDarkness\" + lightIndex,\r\n        \"frustumLengths\" + lightIndex\r\n    );\r\n\r\n    if (projectedLightTexture) {\r\n        samplersList.push(\"projectionLightSampler\" + lightIndex);\r\n        uniformsList.push(\"textureProjectionMatrix\" + lightIndex);\r\n    }\r\n}\r\n\r\n/**\r\n * Prepares the uniforms and samplers list to be used in the effect\r\n * @param uniformsListOrOptions The uniform names to prepare or an EffectCreationOptions containing the list and extra information\r\n * @param samplersList The sampler list\r\n * @param defines The defines helping in the list generation\r\n * @param maxSimultaneousLights The maximum number of simultaneous light allowed in the effect\r\n */\r\nexport function PrepareUniformsAndSamplersList(uniformsListOrOptions: string[] | IEffectCreationOptions, samplersList?: string[], defines?: any, maxSimultaneousLights = 4): void {\r\n    let uniformsList: string[];\r\n    let uniformBuffersList: Nullable<string[]> = null;\r\n\r\n    if ((<IEffectCreationOptions>uniformsListOrOptions).uniformsNames) {\r\n        const options = <IEffectCreationOptions>uniformsListOrOptions;\r\n        uniformsList = options.uniformsNames;\r\n        uniformBuffersList = options.uniformBuffersNames;\r\n        samplersList = options.samplers;\r\n        defines = options.defines;\r\n        maxSimultaneousLights = options.maxSimultaneousLights || 0;\r\n    } else {\r\n        uniformsList = <string[]>uniformsListOrOptions;\r\n        if (!samplersList) {\r\n            samplersList = [];\r\n        }\r\n    }\r\n\r\n    for (let lightIndex = 0; lightIndex < maxSimultaneousLights; lightIndex++) {\r\n        if (!defines[\"LIGHT\" + lightIndex]) {\r\n            break;\r\n        }\r\n        PrepareUniformsAndSamplersForLight(lightIndex, uniformsList, samplersList, defines[\"PROJECTEDLIGHTTEXTURE\" + lightIndex], uniformBuffersList);\r\n    }\r\n\r\n    if (defines[\"NUM_MORPH_INFLUENCERS\"]) {\r\n        uniformsList.push(\"morphTargetInfluences\");\r\n        uniformsList.push(\"morphTargetCount\");\r\n    }\r\n\r\n    if (defines[\"BAKED_VERTEX_ANIMATION_TEXTURE\"]) {\r\n        uniformsList.push(\"bakedVertexAnimationSettings\");\r\n        uniformsList.push(\"bakedVertexAnimationTextureSizeInverted\");\r\n        uniformsList.push(\"bakedVertexAnimationTime\");\r\n        samplersList.push(\"bakedVertexAnimationTexture\");\r\n    }\r\n}\r\n", "import { SerializationHelper } from \"../Misc/decorators.serialization\";\r\nimport { Constants } from \"../Engines/constants\";\r\nimport { serialize } from \"../Misc/decorators\";\r\nimport type { IStencilState } from \"../States/IStencilState\";\r\n\r\nimport type { Scene } from \"../scene\";\r\n\r\n/**\r\n * Class that holds the different stencil states of a material\r\n * Usage example: https://playground.babylonjs.com/#CW5PRI#10\r\n */\r\nexport class MaterialStencilState implements IStencilState {\r\n    /**\r\n     * Creates a material stencil state instance\r\n     */\r\n    public constructor() {\r\n        this.reset();\r\n    }\r\n\r\n    /**\r\n     * Resets all the stencil states to default values\r\n     */\r\n    public reset() {\r\n        this.enabled = false;\r\n        this.mask = 0xff;\r\n\r\n        this.func = Constants.ALWAYS;\r\n        this.funcRef = 1;\r\n        this.funcMask = 0xff;\r\n\r\n        this.opStencilFail = Constants.KEEP;\r\n        this.opDepthFail = Constants.KEEP;\r\n        this.opStencilDepthPass = Constants.REPLACE;\r\n    }\r\n\r\n    private _func: number;\r\n    /**\r\n     * Gets or sets the stencil function\r\n     */\r\n    @serialize()\r\n    public get func(): number {\r\n        return this._func;\r\n    }\r\n\r\n    public set func(value: number) {\r\n        this._func = value;\r\n    }\r\n\r\n    private _funcRef: number;\r\n    /**\r\n     * Gets or sets the stencil function reference\r\n     */\r\n    @serialize()\r\n    public get funcRef(): number {\r\n        return this._funcRef;\r\n    }\r\n\r\n    public set funcRef(value: number) {\r\n        this._funcRef = value;\r\n    }\r\n\r\n    private _funcMask: number;\r\n    /**\r\n     * Gets or sets the stencil function mask\r\n     */\r\n    @serialize()\r\n    public get funcMask(): number {\r\n        return this._funcMask;\r\n    }\r\n\r\n    public set funcMask(value: number) {\r\n        this._funcMask = value;\r\n    }\r\n\r\n    private _opStencilFail: number;\r\n    /**\r\n     * Gets or sets the operation when the stencil test fails\r\n     */\r\n    @serialize()\r\n    public get opStencilFail(): number {\r\n        return this._opStencilFail;\r\n    }\r\n\r\n    public set opStencilFail(value: number) {\r\n        this._opStencilFail = value;\r\n    }\r\n\r\n    private _opDepthFail: number;\r\n    /**\r\n     * Gets or sets the operation when the depth test fails\r\n     */\r\n    @serialize()\r\n    public get opDepthFail(): number {\r\n        return this._opDepthFail;\r\n    }\r\n\r\n    public set opDepthFail(value: number) {\r\n        this._opDepthFail = value;\r\n    }\r\n\r\n    private _opStencilDepthPass: number;\r\n    /**\r\n     * Gets or sets the operation when the stencil+depth test succeeds\r\n     */\r\n    @serialize()\r\n    public get opStencilDepthPass(): number {\r\n        return this._opStencilDepthPass;\r\n    }\r\n\r\n    public set opStencilDepthPass(value: number) {\r\n        this._opStencilDepthPass = value;\r\n    }\r\n\r\n    private _mask: number;\r\n    /**\r\n     * Gets or sets the stencil mask\r\n     */\r\n    @serialize()\r\n    public get mask(): number {\r\n        return this._mask;\r\n    }\r\n\r\n    public set mask(value: number) {\r\n        this._mask = value;\r\n    }\r\n\r\n    private _enabled: boolean;\r\n    /**\r\n     * Enables or disables the stencil test\r\n     */\r\n    @serialize()\r\n    public get enabled(): boolean {\r\n        return this._enabled;\r\n    }\r\n\r\n    public set enabled(value: boolean) {\r\n        this._enabled = value;\r\n    }\r\n\r\n    /**\r\n     * Get the current class name, useful for serialization or dynamic coding.\r\n     * @returns \"MaterialStencilState\"\r\n     */\r\n    public getClassName(): string {\r\n        return \"MaterialStencilState\";\r\n    }\r\n\r\n    /**\r\n     * Makes a duplicate of the current configuration into another one.\r\n     * @param stencilState defines stencil state where to copy the info\r\n     */\r\n    public copyTo(stencilState: MaterialStencilState): void {\r\n        SerializationHelper.Clone(() => stencilState, this);\r\n    }\r\n\r\n    /**\r\n     * Serializes this stencil configuration.\r\n     * @returns - An object with the serialized config.\r\n     */\r\n    public serialize(): any {\r\n        return SerializationHelper.Serialize(this);\r\n    }\r\n\r\n    /**\r\n     * Parses a stencil state configuration from a serialized object.\r\n     * @param source - Serialized object.\r\n     * @param scene Defines the scene we are parsing for\r\n     * @param rootUrl Defines the rootUrl to load from\r\n     */\r\n    public parse(source: any, scene: Scene, rootUrl: string): void {\r\n        SerializationHelper.Parse(() => this, source, scene, rootUrl);\r\n    }\r\n}\r\n", "import { serialize } from \"../Misc/decorators\";\r\nimport { Tools } from \"../Misc/tools\";\r\nimport type { IAnimatable } from \"../Animations/animatable.interface\";\r\nimport type { SmartArray } from \"../Misc/smartArray\";\r\nimport type { Observer } from \"../Misc/observable\";\r\nimport { Observable } from \"../Misc/observable\";\r\nimport type { Nullable } from \"../types\";\r\nimport type { Matrix } from \"../Maths/math.vector\";\r\nimport { EngineStore } from \"../Engines/engineStore\";\r\nimport { SubMesh } from \"../Meshes/subMesh\";\r\nimport type { AbstractMesh } from \"../Meshes/abstractMesh\";\r\nimport { UniformBuffer } from \"./uniformBuffer\";\r\nimport type { Effect } from \"./effect\";\r\nimport type { BaseTexture } from \"../Materials/Textures/baseTexture\";\r\nimport type { RenderTargetTexture } from \"../Materials/Textures/renderTargetTexture\";\r\nimport type { MaterialDefines } from \"./materialDefines\";\r\nimport { Constants } from \"../Engines/constants\";\r\nimport { Logger } from \"../Misc/logger\";\r\nimport type { IInspectable } from \"../Misc/iInspectable\";\r\nimport { Plane } from \"../Maths/math.plane\";\r\nimport type { ShadowDepthWrapper } from \"./shadowDepthWrapper\";\r\nimport type { IMaterialContext } from \"../Engines/IMaterialContext\";\r\nimport { DrawWrapper } from \"./drawWrapper\";\r\nimport { MaterialStencilState } from \"./materialStencilState\";\r\nimport { ScenePerformancePriority } from \"../scene\";\r\nimport type { Scene } from \"../scene\";\r\nimport type { AbstractScene } from \"../abstractScene\";\r\nimport type {\r\n    MaterialPluginDisposed,\r\n    MaterialPluginIsReadyForSubMesh,\r\n    MaterialPluginGetDefineNames,\r\n    MaterialPluginBindForSubMesh,\r\n    MaterialPluginGetActiveTextures,\r\n    MaterialPluginHasTexture,\r\n    MaterialPluginGetAnimatables,\r\n    MaterialPluginPrepareDefines,\r\n    MaterialPluginPrepareEffect,\r\n    MaterialPluginPrepareUniformBuffer,\r\n    MaterialPluginCreated,\r\n    MaterialPluginFillRenderTargetTextures,\r\n    MaterialPluginHasRenderTargetTextures,\r\n    MaterialPluginHardBindForSubMesh,\r\n} from \"./materialPluginEvent\";\r\nimport { MaterialPluginEvent } from \"./materialPluginEvent\";\r\nimport type { ShaderCustomProcessingFunction } from \"../Engines/Processors/shaderProcessingOptions\";\r\nimport type { IClipPlanesHolder } from \"../Misc/interfaces/iClipPlanesHolder\";\r\n\r\nimport type { PrePassRenderer } from \"../Rendering/prePassRenderer\";\r\nimport type { Mesh } from \"../Meshes/mesh\";\r\nimport type { Animation } from \"../Animations/animation\";\r\nimport type { InstancedMesh } from \"../Meshes/instancedMesh\";\r\nimport { BindSceneUniformBuffer } from \"./materialHelper.functions\";\r\nimport { SerializationHelper } from \"../Misc/decorators.serialization\";\r\n\r\ndeclare let BABYLON: any;\r\n\r\n/**\r\n * Options for compiling materials.\r\n */\r\nexport interface IMaterialCompilationOptions {\r\n    /**\r\n     * Defines whether clip planes are enabled.\r\n     */\r\n    clipPlane: boolean;\r\n\r\n    /**\r\n     * Defines whether instances are enabled.\r\n     */\r\n    useInstances: boolean;\r\n}\r\n\r\n/**\r\n * Options passed when calling customShaderNameResolve\r\n */\r\nexport interface ICustomShaderNameResolveOptions {\r\n    /**\r\n     * If provided, will be called two times with the vertex and fragment code so that this code can be updated before it is compiled by the GPU\r\n     */\r\n    processFinalCode?: Nullable<ShaderCustomProcessingFunction>;\r\n}\r\n\r\n/**\r\n * Base class for the main features of a material in Babylon.js\r\n */\r\nexport class Material implements IAnimatable, IClipPlanesHolder {\r\n    /**\r\n     * Returns the triangle fill mode\r\n     */\r\n    public static readonly TriangleFillMode = Constants.MATERIAL_TriangleFillMode;\r\n    /**\r\n     * Returns the wireframe mode\r\n     */\r\n    public static readonly WireFrameFillMode = Constants.MATERIAL_WireFrameFillMode;\r\n    /**\r\n     * Returns the point fill mode\r\n     */\r\n    public static readonly PointFillMode = Constants.MATERIAL_PointFillMode;\r\n    /**\r\n     * Returns the point list draw mode\r\n     */\r\n    public static readonly PointListDrawMode = Constants.MATERIAL_PointListDrawMode;\r\n    /**\r\n     * Returns the line list draw mode\r\n     */\r\n    public static readonly LineListDrawMode = Constants.MATERIAL_LineListDrawMode;\r\n    /**\r\n     * Returns the line loop draw mode\r\n     */\r\n    public static readonly LineLoopDrawMode = Constants.MATERIAL_LineLoopDrawMode;\r\n    /**\r\n     * Returns the line strip draw mode\r\n     */\r\n    public static readonly LineStripDrawMode = Constants.MATERIAL_LineStripDrawMode;\r\n    /**\r\n     * Returns the triangle strip draw mode\r\n     */\r\n    public static readonly TriangleStripDrawMode = Constants.MATERIAL_TriangleStripDrawMode;\r\n    /**\r\n     * Returns the triangle fan draw mode\r\n     */\r\n    public static readonly TriangleFanDrawMode = Constants.MATERIAL_TriangleFanDrawMode;\r\n\r\n    /**\r\n     * Stores the clock-wise side orientation\r\n     */\r\n    public static readonly ClockWiseSideOrientation = Constants.MATERIAL_ClockWiseSideOrientation;\r\n\r\n    /**\r\n     * Stores the counter clock-wise side orientation\r\n     */\r\n    public static readonly CounterClockWiseSideOrientation = Constants.MATERIAL_CounterClockWiseSideOrientation;\r\n\r\n    /**\r\n     * The dirty texture flag value\r\n     */\r\n    public static readonly TextureDirtyFlag = Constants.MATERIAL_TextureDirtyFlag;\r\n\r\n    /**\r\n     * The dirty light flag value\r\n     */\r\n    public static readonly LightDirtyFlag = Constants.MATERIAL_LightDirtyFlag;\r\n\r\n    /**\r\n     * The dirty fresnel flag value\r\n     */\r\n    public static readonly FresnelDirtyFlag = Constants.MATERIAL_FresnelDirtyFlag;\r\n\r\n    /**\r\n     * The dirty attribute flag value\r\n     */\r\n    public static readonly AttributesDirtyFlag = Constants.MATERIAL_AttributesDirtyFlag;\r\n\r\n    /**\r\n     * The dirty misc flag value\r\n     */\r\n    public static readonly MiscDirtyFlag = Constants.MATERIAL_MiscDirtyFlag;\r\n\r\n    /**\r\n     * The dirty prepass flag value\r\n     */\r\n    public static readonly PrePassDirtyFlag = Constants.MATERIAL_PrePassDirtyFlag;\r\n\r\n    /**\r\n     * The all dirty flag value\r\n     */\r\n    public static readonly AllDirtyFlag = Constants.MATERIAL_AllDirtyFlag;\r\n\r\n    /**\r\n     * MaterialTransparencyMode: No transparency mode, Alpha channel is not use.\r\n     */\r\n    public static readonly MATERIAL_OPAQUE = 0;\r\n\r\n    /**\r\n     * MaterialTransparencyMode: Alpha Test mode, pixel are discarded below a certain threshold defined by the alpha cutoff value.\r\n     */\r\n    public static readonly MATERIAL_ALPHATEST = 1;\r\n\r\n    /**\r\n     * MaterialTransparencyMode: Pixels are blended (according to the alpha mode) with the already drawn pixels in the current frame buffer.\r\n     */\r\n    public static readonly MATERIAL_ALPHABLEND = 2;\r\n\r\n    /**\r\n     * MaterialTransparencyMode: Pixels are blended (according to the alpha mode) with the already drawn pixels in the current frame buffer.\r\n     * They are also discarded below the alpha cutoff threshold to improve performances.\r\n     */\r\n    public static readonly MATERIAL_ALPHATESTANDBLEND = 3;\r\n\r\n    /**\r\n     * The Whiteout method is used to blend normals.\r\n     * Details of the algorithm can be found here: https://blog.selfshadow.com/publications/blending-in-detail/\r\n     */\r\n    public static readonly MATERIAL_NORMALBLENDMETHOD_WHITEOUT = 0;\r\n\r\n    /**\r\n     * The Reoriented Normal Mapping method is used to blend normals.\r\n     * Details of the algorithm can be found here: https://blog.selfshadow.com/publications/blending-in-detail/\r\n     */\r\n    public static readonly MATERIAL_NORMALBLENDMETHOD_RNM = 1;\r\n\r\n    /**\r\n     * Event observable which raises global events common to all materials (like MaterialPluginEvent.Created)\r\n     */\r\n    public static OnEventObservable = new Observable<Material>();\r\n\r\n    /**\r\n     * Custom callback helping to override the default shader used in the material.\r\n     */\r\n    public customShaderNameResolve: (\r\n        shaderName: string,\r\n        uniforms: string[],\r\n        uniformBuffers: string[],\r\n        samplers: string[],\r\n        defines: MaterialDefines | string[],\r\n        attributes?: string[],\r\n        options?: ICustomShaderNameResolveOptions\r\n    ) => string;\r\n\r\n    /**\r\n     * Custom shadow depth material to use for shadow rendering instead of the in-built one\r\n     */\r\n    public shadowDepthWrapper: Nullable<ShadowDepthWrapper> = null;\r\n\r\n    /**\r\n     * Gets or sets a boolean indicating that the material is allowed (if supported) to do shader hot swapping.\r\n     * This means that the material can keep using a previous shader while a new one is being compiled.\r\n     * This is mostly used when shader parallel compilation is supported (true by default)\r\n     */\r\n    public allowShaderHotSwapping = true;\r\n\r\n    /**\r\n     * The ID of the material\r\n     */\r\n    @serialize()\r\n    public id: string;\r\n\r\n    /**\r\n     * Gets or sets the unique id of the material\r\n     */\r\n    @serialize()\r\n    public uniqueId: number;\r\n\r\n    /** @internal */\r\n    public _loadedUniqueId: string;\r\n\r\n    /**\r\n     * The name of the material\r\n     */\r\n    @serialize()\r\n    public name: string;\r\n\r\n    /**\r\n     * Gets or sets user defined metadata\r\n     */\r\n    @serialize()\r\n    public metadata: any = null;\r\n\r\n    /** @internal */\r\n    public _internalMetadata: any;\r\n\r\n    /**\r\n     * For internal use only. Please do not use.\r\n     */\r\n    public reservedDataStore: any = null;\r\n\r\n    /**\r\n     * Specifies if the ready state should be checked on each call\r\n     */\r\n    @serialize()\r\n    public checkReadyOnEveryCall = false;\r\n\r\n    /**\r\n     * Specifies if the ready state should be checked once\r\n     */\r\n    @serialize()\r\n    public checkReadyOnlyOnce = false;\r\n\r\n    /**\r\n     * The state of the material\r\n     */\r\n    @serialize()\r\n    public state = \"\";\r\n\r\n    /**\r\n     * If the material can be rendered to several textures with MRT extension\r\n     */\r\n    public get canRenderToMRT(): boolean {\r\n        // By default, shaders are not compatible with MRTs\r\n        // Base classes should override that if their shader supports MRT\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * The alpha value of the material\r\n     */\r\n    @serialize(\"alpha\")\r\n    protected _alpha = 1.0;\r\n\r\n    /**\r\n     * List of inspectable custom properties (used by the Inspector)\r\n     * @see https://doc.babylonjs.com/toolsAndResources/inspector#extensibility\r\n     */\r\n    public inspectableCustomProperties: IInspectable[];\r\n\r\n    /**\r\n     * Sets the alpha value of the material\r\n     */\r\n    public set alpha(value: number) {\r\n        if (this._alpha === value) {\r\n            return;\r\n        }\r\n\r\n        const oldValue = this._alpha;\r\n        this._alpha = value;\r\n\r\n        // Only call dirty when there is a state change (no alpha / alpha)\r\n        if (oldValue === 1 || value === 1) {\r\n            this.markAsDirty(Material.MiscDirtyFlag + Material.PrePassDirtyFlag);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the alpha value of the material\r\n     */\r\n    public get alpha(): number {\r\n        return this._alpha;\r\n    }\r\n\r\n    /**\r\n     * Specifies if back face culling is enabled\r\n     */\r\n    @serialize(\"backFaceCulling\")\r\n    protected _backFaceCulling = true;\r\n\r\n    /**\r\n     * Sets the culling state (true to enable culling, false to disable)\r\n     */\r\n    public set backFaceCulling(value: boolean) {\r\n        if (this._backFaceCulling === value) {\r\n            return;\r\n        }\r\n        this._backFaceCulling = value;\r\n        this.markAsDirty(Material.TextureDirtyFlag);\r\n    }\r\n\r\n    /**\r\n     * Gets the culling state\r\n     */\r\n    public get backFaceCulling(): boolean {\r\n        return this._backFaceCulling;\r\n    }\r\n\r\n    /**\r\n     * Specifies if back or front faces should be culled (when culling is enabled)\r\n     */\r\n    @serialize(\"cullBackFaces\")\r\n    protected _cullBackFaces = true;\r\n\r\n    /**\r\n     * Sets the type of faces that should be culled (true for back faces, false for front faces)\r\n     */\r\n    public set cullBackFaces(value: boolean) {\r\n        if (this._cullBackFaces === value) {\r\n            return;\r\n        }\r\n        this._cullBackFaces = value;\r\n        this.markAsDirty(Material.TextureDirtyFlag);\r\n    }\r\n\r\n    /**\r\n     * Gets the type of faces that should be culled\r\n     */\r\n    public get cullBackFaces(): boolean {\r\n        return this._cullBackFaces;\r\n    }\r\n\r\n    private _blockDirtyMechanism = false;\r\n\r\n    /**\r\n     * Block the dirty-mechanism for this specific material\r\n     * When set to false after being true the material will be marked as dirty.\r\n     */\r\n    public get blockDirtyMechanism(): boolean {\r\n        return this._blockDirtyMechanism;\r\n    }\r\n\r\n    public set blockDirtyMechanism(value: boolean) {\r\n        if (this._blockDirtyMechanism === value) {\r\n            return;\r\n        }\r\n\r\n        this._blockDirtyMechanism = value;\r\n\r\n        if (!value) {\r\n            this.markDirty();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * This allows you to modify the material without marking it as dirty after every change.\r\n     * This function should be used if you need to make more than one dirty-enabling change to the material - adding a texture, setting a new fill mode and so on.\r\n     * The callback will pass the material as an argument, so you can make your changes to it.\r\n     * @param callback the callback to be executed that will update the material\r\n     */\r\n    public atomicMaterialsUpdate(callback: (material: this) => void): void {\r\n        this.blockDirtyMechanism = true;\r\n        try {\r\n            callback(this);\r\n        } finally {\r\n            this.blockDirtyMechanism = false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Stores the value for side orientation\r\n     */\r\n    @serialize()\r\n    public sideOrientation: number;\r\n\r\n    /**\r\n     * Callback triggered when the material is compiled\r\n     */\r\n    public onCompiled: Nullable<(effect: Effect) => void> = null;\r\n\r\n    /**\r\n     * Callback triggered when an error occurs\r\n     */\r\n    public onError: Nullable<(effect: Effect, errors: string) => void> = null;\r\n\r\n    /**\r\n     * Callback triggered to get the render target textures\r\n     */\r\n    public getRenderTargetTextures: Nullable<() => SmartArray<RenderTargetTexture>> = null;\r\n\r\n    /**\r\n     * Gets a boolean indicating that current material needs to register RTT\r\n     */\r\n    public get hasRenderTargetTextures(): boolean {\r\n        this._eventInfo.hasRenderTargetTextures = false;\r\n        this._callbackPluginEventHasRenderTargetTextures(this._eventInfo);\r\n        return this._eventInfo.hasRenderTargetTextures;\r\n    }\r\n\r\n    /**\r\n     * Specifies if the material should be serialized\r\n     */\r\n    public doNotSerialize = false;\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _storeEffectOnSubMeshes = false;\r\n\r\n    /**\r\n     * Stores the animations for the material\r\n     */\r\n    public animations: Nullable<Array<Animation>> = null;\r\n\r\n    /**\r\n     * An event triggered when the material is disposed\r\n     */\r\n    public onDisposeObservable = new Observable<Material>();\r\n\r\n    /**\r\n     * An observer which watches for dispose events\r\n     */\r\n    private _onDisposeObserver: Nullable<Observer<Material>> = null;\r\n    private _onUnBindObservable: Nullable<Observable<Material>> = null;\r\n\r\n    /**\r\n     * Called during a dispose event\r\n     */\r\n    public set onDispose(callback: () => void) {\r\n        if (this._onDisposeObserver) {\r\n            this.onDisposeObservable.remove(this._onDisposeObserver);\r\n        }\r\n        this._onDisposeObserver = this.onDisposeObservable.add(callback);\r\n    }\r\n\r\n    private _onBindObservable: Nullable<Observable<AbstractMesh>>;\r\n\r\n    /**\r\n     * An event triggered when the material is bound\r\n     */\r\n    public get onBindObservable(): Observable<AbstractMesh> {\r\n        if (!this._onBindObservable) {\r\n            this._onBindObservable = new Observable<AbstractMesh>();\r\n        }\r\n\r\n        return this._onBindObservable;\r\n    }\r\n\r\n    /**\r\n     * An observer which watches for bind events\r\n     */\r\n    private _onBindObserver: Nullable<Observer<AbstractMesh>> = null;\r\n\r\n    /**\r\n     * Called during a bind event\r\n     */\r\n    public set onBind(callback: (Mesh: AbstractMesh) => void) {\r\n        if (this._onBindObserver) {\r\n            this.onBindObservable.remove(this._onBindObserver);\r\n        }\r\n        this._onBindObserver = this.onBindObservable.add(callback);\r\n    }\r\n\r\n    /**\r\n     * An event triggered when the material is unbound\r\n     */\r\n    public get onUnBindObservable(): Observable<Material> {\r\n        if (!this._onUnBindObservable) {\r\n            this._onUnBindObservable = new Observable<Material>();\r\n        }\r\n\r\n        return this._onUnBindObservable;\r\n    }\r\n\r\n    protected _onEffectCreatedObservable: Nullable<Observable<{ effect: Effect; subMesh: Nullable<SubMesh> }>>;\r\n\r\n    /**\r\n     * An event triggered when the effect is (re)created\r\n     */\r\n    public get onEffectCreatedObservable(): Observable<{ effect: Effect; subMesh: Nullable<SubMesh> }> {\r\n        if (!this._onEffectCreatedObservable) {\r\n            this._onEffectCreatedObservable = new Observable<{ effect: Effect; subMesh: Nullable<SubMesh> }>();\r\n        }\r\n\r\n        return this._onEffectCreatedObservable;\r\n    }\r\n\r\n    /**\r\n     * Stores the value of the alpha mode\r\n     */\r\n    @serialize(\"alphaMode\")\r\n    private _alphaMode: number = Constants.ALPHA_COMBINE;\r\n\r\n    /**\r\n     * Sets the value of the alpha mode.\r\n     *\r\n     * | Value | Type | Description |\r\n     * | --- | --- | --- |\r\n     * | 0 | ALPHA_DISABLE |   |\r\n     * | 1 | ALPHA_ADD |   |\r\n     * | 2 | ALPHA_COMBINE |   |\r\n     * | 3 | ALPHA_SUBTRACT |   |\r\n     * | 4 | ALPHA_MULTIPLY |   |\r\n     * | 5 | ALPHA_MAXIMIZED |   |\r\n     * | 6 | ALPHA_ONEONE |   |\r\n     * | 7 | ALPHA_PREMULTIPLIED |   |\r\n     * | 8 | ALPHA_PREMULTIPLIED_PORTERDUFF |   |\r\n     * | 9 | ALPHA_INTERPOLATE |   |\r\n     * | 10 | ALPHA_SCREENMODE |   |\r\n     *\r\n     */\r\n    public set alphaMode(value: number) {\r\n        if (this._alphaMode === value) {\r\n            return;\r\n        }\r\n        this._alphaMode = value;\r\n        this.markAsDirty(Material.TextureDirtyFlag);\r\n    }\r\n\r\n    /**\r\n     * Gets the value of the alpha mode\r\n     */\r\n    public get alphaMode(): number {\r\n        return this._alphaMode;\r\n    }\r\n\r\n    /**\r\n     * Stores the state of the need depth pre-pass value\r\n     */\r\n    @serialize()\r\n    private _needDepthPrePass = false;\r\n\r\n    /**\r\n     * Sets the need depth pre-pass value\r\n     */\r\n    public set needDepthPrePass(value: boolean) {\r\n        if (this._needDepthPrePass === value) {\r\n            return;\r\n        }\r\n        this._needDepthPrePass = value;\r\n        if (this._needDepthPrePass) {\r\n            this.checkReadyOnEveryCall = true;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the depth pre-pass value\r\n     */\r\n    public get needDepthPrePass(): boolean {\r\n        return this._needDepthPrePass;\r\n    }\r\n\r\n    /**\r\n     * Can this material render to prepass\r\n     */\r\n    public get isPrePassCapable(): boolean {\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Specifies if depth writing should be disabled\r\n     */\r\n    @serialize()\r\n    public disableDepthWrite = false;\r\n\r\n    /**\r\n     * Specifies if color writing should be disabled\r\n     */\r\n    @serialize()\r\n    public disableColorWrite = false;\r\n\r\n    /**\r\n     * Specifies if depth writing should be forced\r\n     */\r\n    @serialize()\r\n    public forceDepthWrite = false;\r\n\r\n    /**\r\n     * Specifies the depth function that should be used. 0 means the default engine function\r\n     */\r\n    @serialize()\r\n    public depthFunction = 0;\r\n\r\n    /**\r\n     * Specifies if there should be a separate pass for culling\r\n     */\r\n    @serialize()\r\n    public separateCullingPass = false;\r\n\r\n    /**\r\n     * Stores the state specifying if fog should be enabled\r\n     */\r\n    @serialize(\"fogEnabled\")\r\n    private _fogEnabled = true;\r\n\r\n    /**\r\n     * Sets the state for enabling fog\r\n     */\r\n    public set fogEnabled(value: boolean) {\r\n        if (this._fogEnabled === value) {\r\n            return;\r\n        }\r\n        this._fogEnabled = value;\r\n        this.markAsDirty(Material.MiscDirtyFlag);\r\n    }\r\n\r\n    /**\r\n     * Gets the value of the fog enabled state\r\n     */\r\n    public get fogEnabled(): boolean {\r\n        return this._fogEnabled;\r\n    }\r\n\r\n    /**\r\n     * Stores the size of points\r\n     */\r\n    @serialize()\r\n    public pointSize = 1.0;\r\n\r\n    /**\r\n     * Stores the z offset Factor value\r\n     */\r\n    @serialize()\r\n    public zOffset = 0;\r\n\r\n    /**\r\n     * Stores the z offset Units value\r\n     */\r\n    @serialize()\r\n    public zOffsetUnits = 0;\r\n\r\n    public get wireframe(): boolean {\r\n        switch (this._fillMode) {\r\n            case Material.WireFrameFillMode:\r\n            case Material.LineListDrawMode:\r\n            case Material.LineLoopDrawMode:\r\n            case Material.LineStripDrawMode:\r\n                return true;\r\n        }\r\n\r\n        return this._scene.forceWireframe;\r\n    }\r\n\r\n    /**\r\n     * Sets the state of wireframe mode\r\n     */\r\n    public set wireframe(value: boolean) {\r\n        this.fillMode = value ? Material.WireFrameFillMode : Material.TriangleFillMode;\r\n    }\r\n\r\n    /**\r\n     * Gets the value specifying if point clouds are enabled\r\n     */\r\n    @serialize()\r\n    public get pointsCloud(): boolean {\r\n        switch (this._fillMode) {\r\n            case Material.PointFillMode:\r\n            case Material.PointListDrawMode:\r\n                return true;\r\n        }\r\n\r\n        return this._scene.forcePointsCloud;\r\n    }\r\n\r\n    /**\r\n     * Sets the state of point cloud mode\r\n     */\r\n    public set pointsCloud(value: boolean) {\r\n        this.fillMode = value ? Material.PointFillMode : Material.TriangleFillMode;\r\n    }\r\n\r\n    /**\r\n     * Gets the material fill mode\r\n     */\r\n    @serialize()\r\n    public get fillMode(): number {\r\n        return this._fillMode;\r\n    }\r\n\r\n    /**\r\n     * Sets the material fill mode\r\n     */\r\n    public set fillMode(value: number) {\r\n        if (this._fillMode === value) {\r\n            return;\r\n        }\r\n\r\n        this._fillMode = value;\r\n        this.markAsDirty(Material.MiscDirtyFlag);\r\n    }\r\n\r\n    /**\r\n     * Gets or sets the active clipplane 1\r\n     */\r\n    public clipPlane: Nullable<Plane>;\r\n\r\n    /**\r\n     * Gets or sets the active clipplane 2\r\n     */\r\n    public clipPlane2: Nullable<Plane>;\r\n\r\n    /**\r\n     * Gets or sets the active clipplane 3\r\n     */\r\n    public clipPlane3: Nullable<Plane>;\r\n\r\n    /**\r\n     * Gets or sets the active clipplane 4\r\n     */\r\n    public clipPlane4: Nullable<Plane>;\r\n\r\n    /**\r\n     * Gets or sets the active clipplane 5\r\n     */\r\n    public clipPlane5: Nullable<Plane>;\r\n\r\n    /**\r\n     * Gets or sets the active clipplane 6\r\n     */\r\n    public clipPlane6: Nullable<Plane>;\r\n\r\n    /**\r\n     * Gives access to the stencil properties of the material\r\n     */\r\n    public readonly stencil = new MaterialStencilState();\r\n\r\n    protected _useLogarithmicDepth: boolean;\r\n\r\n    /**\r\n     * In case the depth buffer does not allow enough depth precision for your scene (might be the case in large scenes)\r\n     * You can try switching to logarithmic depth.\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/materials/advanced/logarithmicDepthBuffer\r\n     */\r\n    @serialize()\r\n    public get useLogarithmicDepth(): boolean {\r\n        return this._useLogarithmicDepth;\r\n    }\r\n\r\n    public set useLogarithmicDepth(value: boolean) {\r\n        const fragmentDepthSupported = this.getScene().getEngine().getCaps().fragmentDepthSupported;\r\n\r\n        if (value && !fragmentDepthSupported) {\r\n            Logger.Warn(\"Logarithmic depth has been requested for a material on a device that doesn't support it.\");\r\n        }\r\n\r\n        this._useLogarithmicDepth = value && fragmentDepthSupported;\r\n\r\n        this._markAllSubMeshesAsMiscDirty();\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     * Stores the effects for the material\r\n     */\r\n    public _materialContext: IMaterialContext | undefined;\r\n\r\n    protected _drawWrapper: DrawWrapper;\r\n    /** @internal */\r\n    public _getDrawWrapper(): DrawWrapper {\r\n        return this._drawWrapper;\r\n    }\r\n    /**\r\n     * @internal\r\n     */\r\n    public _setDrawWrapper(drawWrapper: DrawWrapper) {\r\n        this._drawWrapper = drawWrapper;\r\n    }\r\n\r\n    /**\r\n     * Specifies if uniform buffers should be used\r\n     */\r\n    private _useUBO: boolean = false;\r\n\r\n    /**\r\n     * Stores a reference to the scene\r\n     */\r\n    private _scene: Scene;\r\n    protected _needToBindSceneUbo: boolean;\r\n\r\n    /**\r\n     * Stores the fill mode state\r\n     */\r\n    private _fillMode = Material.TriangleFillMode;\r\n\r\n    /**\r\n     * Specifies if the depth write state should be cached\r\n     */\r\n    private _cachedDepthWriteState: boolean = false;\r\n\r\n    /**\r\n     * Specifies if the color write state should be cached\r\n     */\r\n    private _cachedColorWriteState: boolean = false;\r\n\r\n    /**\r\n     * Specifies if the depth function state should be cached\r\n     */\r\n    private _cachedDepthFunctionState: number = 0;\r\n\r\n    /**\r\n     * Stores the uniform buffer\r\n     * @internal\r\n     */\r\n    public _uniformBuffer: UniformBuffer;\r\n\r\n    /** @internal */\r\n    public _indexInSceneMaterialArray = -1;\r\n\r\n    /** @internal */\r\n    public meshMap: Nullable<{ [id: string]: AbstractMesh | undefined }> = null;\r\n\r\n    /** @internal */\r\n    public _parentContainer: Nullable<AbstractScene> = null;\r\n\r\n    /** @internal */\r\n    public _dirtyCallbacks: { [code: number]: () => void };\r\n\r\n    /** @internal */\r\n    public _uniformBufferLayoutBuilt = false;\r\n\r\n    protected _eventInfo: MaterialPluginCreated &\r\n        MaterialPluginDisposed &\r\n        MaterialPluginHasTexture &\r\n        MaterialPluginIsReadyForSubMesh &\r\n        MaterialPluginGetDefineNames &\r\n        MaterialPluginPrepareEffect &\r\n        MaterialPluginPrepareDefines &\r\n        MaterialPluginPrepareUniformBuffer &\r\n        MaterialPluginBindForSubMesh &\r\n        MaterialPluginGetAnimatables &\r\n        MaterialPluginGetActiveTextures &\r\n        MaterialPluginFillRenderTargetTextures &\r\n        MaterialPluginHasRenderTargetTextures &\r\n        MaterialPluginHardBindForSubMesh = {} as any; // will be initialized before each event notification\r\n\r\n    /** @internal */\r\n    public _callbackPluginEventGeneric: (\r\n        id: number,\r\n        info:\r\n            | MaterialPluginGetActiveTextures\r\n            | MaterialPluginGetAnimatables\r\n            | MaterialPluginHasTexture\r\n            | MaterialPluginDisposed\r\n            | MaterialPluginGetDefineNames\r\n            | MaterialPluginPrepareEffect\r\n            | MaterialPluginPrepareUniformBuffer\r\n    ) => void = () => void 0;\r\n    /** @internal */\r\n    public _callbackPluginEventIsReadyForSubMesh: (eventData: MaterialPluginIsReadyForSubMesh) => void = () => void 0;\r\n    /** @internal */\r\n    public _callbackPluginEventPrepareDefines: (eventData: MaterialPluginPrepareDefines) => void = () => void 0;\r\n    /** @internal */\r\n    public _callbackPluginEventPrepareDefinesBeforeAttributes: (eventData: MaterialPluginPrepareDefines) => void = () => void 0;\r\n    /** @internal */\r\n    public _callbackPluginEventHardBindForSubMesh: (eventData: MaterialPluginHardBindForSubMesh) => void = () => void 0;\r\n    /** @internal */\r\n    public _callbackPluginEventBindForSubMesh: (eventData: MaterialPluginBindForSubMesh) => void = () => void 0;\r\n    /** @internal */\r\n    public _callbackPluginEventHasRenderTargetTextures: (eventData: MaterialPluginHasRenderTargetTextures) => void = () => void 0;\r\n    /** @internal */\r\n    public _callbackPluginEventFillRenderTargetTextures: (eventData: MaterialPluginFillRenderTargetTextures) => void = () => void 0;\r\n\r\n    /**\r\n     * Creates a material instance\r\n     * @param name defines the name of the material\r\n     * @param scene defines the scene to reference\r\n     * @param doNotAdd specifies if the material should be added to the scene\r\n     */\r\n    constructor(name: string, scene?: Nullable<Scene>, doNotAdd?: boolean) {\r\n        this.name = name;\r\n        const setScene = scene || EngineStore.LastCreatedScene;\r\n        if (!setScene) {\r\n            return;\r\n        }\r\n        this._scene = setScene;\r\n        this._dirtyCallbacks = {};\r\n\r\n        this._dirtyCallbacks[Constants.MATERIAL_TextureDirtyFlag] = this._markAllSubMeshesAsTexturesDirty.bind(this);\r\n        this._dirtyCallbacks[Constants.MATERIAL_LightDirtyFlag] = this._markAllSubMeshesAsLightsDirty.bind(this);\r\n        this._dirtyCallbacks[Constants.MATERIAL_FresnelDirtyFlag] = this._markAllSubMeshesAsFresnelDirty.bind(this);\r\n        this._dirtyCallbacks[Constants.MATERIAL_AttributesDirtyFlag] = this._markAllSubMeshesAsAttributesDirty.bind(this);\r\n        this._dirtyCallbacks[Constants.MATERIAL_MiscDirtyFlag] = this._markAllSubMeshesAsMiscDirty.bind(this);\r\n        this._dirtyCallbacks[Constants.MATERIAL_PrePassDirtyFlag] = this._markAllSubMeshesAsPrePassDirty.bind(this);\r\n        this._dirtyCallbacks[Constants.MATERIAL_AllDirtyFlag] = this._markAllSubMeshesAsAllDirty.bind(this);\r\n\r\n        this.id = name || Tools.RandomId();\r\n        this.uniqueId = this._scene.getUniqueId();\r\n        this._materialContext = this._scene.getEngine().createMaterialContext();\r\n        this._drawWrapper = new DrawWrapper(this._scene.getEngine(), false);\r\n        this._drawWrapper.materialContext = this._materialContext;\r\n\r\n        if (this._scene.useRightHandedSystem) {\r\n            this.sideOrientation = Material.ClockWiseSideOrientation;\r\n        } else {\r\n            this.sideOrientation = Material.CounterClockWiseSideOrientation;\r\n        }\r\n\r\n        this._uniformBuffer = new UniformBuffer(this._scene.getEngine(), undefined, undefined, name);\r\n        this._useUBO = this.getScene().getEngine().supportsUniformBuffers;\r\n\r\n        if (!doNotAdd) {\r\n            this._scene.addMaterial(this);\r\n        }\r\n\r\n        if (this._scene.useMaterialMeshMap) {\r\n            this.meshMap = {};\r\n        }\r\n\r\n        Material.OnEventObservable.notifyObservers(this, MaterialPluginEvent.Created);\r\n    }\r\n\r\n    /**\r\n     * Returns a string representation of the current material\r\n     * @param fullDetails defines a boolean indicating which levels of logging is desired\r\n     * @returns a string with material information\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    public toString(fullDetails?: boolean): string {\r\n        const ret = \"Name: \" + this.name;\r\n        return ret;\r\n    }\r\n\r\n    /**\r\n     * Gets the class name of the material\r\n     * @returns a string with the class name of the material\r\n     */\r\n    public getClassName(): string {\r\n        return \"Material\";\r\n    }\r\n\r\n    /** @internal */\r\n    public get _isMaterial() {\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Specifies if updates for the material been locked\r\n     */\r\n    public get isFrozen(): boolean {\r\n        return this.checkReadyOnlyOnce;\r\n    }\r\n\r\n    /**\r\n     * Locks updates for the material\r\n     */\r\n    public freeze(): void {\r\n        this.markDirty();\r\n        this.checkReadyOnlyOnce = true;\r\n    }\r\n\r\n    /**\r\n     * Unlocks updates for the material\r\n     */\r\n    public unfreeze(): void {\r\n        this.markDirty();\r\n        this.checkReadyOnlyOnce = false;\r\n    }\r\n\r\n    /**\r\n     * Specifies if the material is ready to be used\r\n     * @param mesh defines the mesh to check\r\n     * @param useInstances specifies if instances should be used\r\n     * @returns a boolean indicating if the material is ready to be used\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    public isReady(mesh?: AbstractMesh, useInstances?: boolean): boolean {\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Specifies that the submesh is ready to be used\r\n     * @param mesh defines the mesh to check\r\n     * @param subMesh defines which submesh to check\r\n     * @param useInstances specifies that instances should be used\r\n     * @returns a boolean indicating that the submesh is ready or not\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    public isReadyForSubMesh(mesh: AbstractMesh, subMesh: SubMesh, useInstances?: boolean): boolean {\r\n        const defines = subMesh.materialDefines;\r\n        if (!defines) {\r\n            return false;\r\n        }\r\n\r\n        this._eventInfo.isReadyForSubMesh = true;\r\n        this._eventInfo.defines = defines;\r\n        this._callbackPluginEventIsReadyForSubMesh(this._eventInfo);\r\n\r\n        return this._eventInfo.isReadyForSubMesh;\r\n    }\r\n\r\n    /**\r\n     * Returns the material effect\r\n     * @returns the effect associated with the material\r\n     */\r\n    public getEffect(): Nullable<Effect> {\r\n        return this._drawWrapper.effect;\r\n    }\r\n\r\n    /**\r\n     * Returns the current scene\r\n     * @returns a Scene\r\n     */\r\n    public getScene(): Scene {\r\n        return this._scene;\r\n    }\r\n\r\n    /**\r\n     * Enforces alpha test in opaque or blend mode in order to improve the performances of some situations.\r\n     */\r\n    protected _forceAlphaTest = false;\r\n\r\n    /**\r\n     * The transparency mode of the material.\r\n     */\r\n    protected _transparencyMode: Nullable<number> = null;\r\n\r\n    /**\r\n     * Gets the current transparency mode.\r\n     */\r\n    @serialize()\r\n    public get transparencyMode(): Nullable<number> {\r\n        return this._transparencyMode;\r\n    }\r\n\r\n    /**\r\n     * Sets the transparency mode of the material.\r\n     *\r\n     * | Value | Type                                | Description |\r\n     * | ----- | ----------------------------------- | ----------- |\r\n     * | 0     | OPAQUE                              |             |\r\n     * | 1     | ALPHATEST                           |             |\r\n     * | 2     | ALPHABLEND                          |             |\r\n     * | 3     | ALPHATESTANDBLEND                   |             |\r\n     *\r\n     */\r\n    public set transparencyMode(value: Nullable<number>) {\r\n        if (this._transparencyMode === value) {\r\n            return;\r\n        }\r\n\r\n        this._transparencyMode = value;\r\n\r\n        this._forceAlphaTest = value === Material.MATERIAL_ALPHATESTANDBLEND;\r\n\r\n        this._markAllSubMeshesAsTexturesAndMiscDirty();\r\n    }\r\n\r\n    /**\r\n     * Returns true if alpha blending should be disabled.\r\n     */\r\n    protected get _disableAlphaBlending(): boolean {\r\n        return this._transparencyMode === Material.MATERIAL_OPAQUE || this._transparencyMode === Material.MATERIAL_ALPHATEST;\r\n    }\r\n\r\n    /**\r\n     * Specifies whether or not this material should be rendered in alpha blend mode.\r\n     * @returns a boolean specifying if alpha blending is needed\r\n     */\r\n    public needAlphaBlending(): boolean {\r\n        if (this._disableAlphaBlending) {\r\n            return false;\r\n        }\r\n\r\n        return this.alpha < 1.0;\r\n    }\r\n\r\n    /**\r\n     * Specifies if the mesh will require alpha blending\r\n     * @param mesh defines the mesh to check\r\n     * @returns a boolean specifying if alpha blending is needed for the mesh\r\n     */\r\n    public needAlphaBlendingForMesh(mesh: AbstractMesh): boolean {\r\n        if (mesh.visibility < 1.0) {\r\n            return true;\r\n        }\r\n\r\n        if (this._disableAlphaBlending) {\r\n            return false;\r\n        }\r\n\r\n        return mesh.hasVertexAlpha || this.needAlphaBlending();\r\n    }\r\n\r\n    /**\r\n     * Specifies whether or not this material should be rendered in alpha test mode.\r\n     * @returns a boolean specifying if an alpha test is needed.\r\n     */\r\n    public needAlphaTesting(): boolean {\r\n        if (this._forceAlphaTest) {\r\n            return true;\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Specifies if material alpha testing should be turned on for the mesh\r\n     * @param mesh defines the mesh to check\r\n     * @returns a boolean specifying if alpha testing should be turned on for the mesh\r\n     */\r\n    protected _shouldTurnAlphaTestOn(mesh: AbstractMesh): boolean {\r\n        return !this.needAlphaBlendingForMesh(mesh) && this.needAlphaTesting();\r\n    }\r\n\r\n    /**\r\n     * Gets the texture used for the alpha test\r\n     * @returns the texture to use for alpha testing\r\n     */\r\n    public getAlphaTestTexture(): Nullable<BaseTexture> {\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Marks the material to indicate that it needs to be re-calculated\r\n     * @param forceMaterialDirty - Forces the material to be marked as dirty for all components (same as this.markAsDirty(Material.AllDirtyFlag)). You should use this flag if the material is frozen and you want to force a recompilation.\r\n     */\r\n    public markDirty(forceMaterialDirty = false): void {\r\n        const meshes = this.getScene().meshes;\r\n        for (const mesh of meshes) {\r\n            if (!mesh.subMeshes) {\r\n                continue;\r\n            }\r\n            for (const subMesh of mesh.subMeshes) {\r\n                if (subMesh.getMaterial() !== this) {\r\n                    continue;\r\n                }\r\n\r\n                for (const drawWrapper of subMesh._drawWrappers) {\r\n                    if (!drawWrapper) {\r\n                        continue;\r\n                    }\r\n                    if (this._materialContext === drawWrapper.materialContext) {\r\n                        drawWrapper._wasPreviouslyReady = false;\r\n                        drawWrapper._wasPreviouslyUsingInstances = null;\r\n                        drawWrapper._forceRebindOnNextCall = forceMaterialDirty;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        if (forceMaterialDirty) {\r\n            this.markAsDirty(Material.AllDirtyFlag);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _preBind(effect?: Effect | DrawWrapper, overrideOrientation: Nullable<number> = null): boolean {\r\n        const engine = this._scene.getEngine();\r\n\r\n        const orientation = overrideOrientation == null ? this.sideOrientation : overrideOrientation;\r\n        const reverse = orientation === Material.ClockWiseSideOrientation;\r\n\r\n        engine.enableEffect(effect ? effect : this._getDrawWrapper());\r\n        engine.setState(\r\n            this.backFaceCulling,\r\n            this.zOffset,\r\n            false,\r\n            reverse,\r\n            this._scene._mirroredCameraPosition ? !this.cullBackFaces : this.cullBackFaces,\r\n            this.stencil,\r\n            this.zOffsetUnits\r\n        );\r\n\r\n        return reverse;\r\n    }\r\n\r\n    /**\r\n     * Binds the material to the mesh\r\n     * @param world defines the world transformation matrix\r\n     * @param mesh defines the mesh to bind the material to\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    public bind(world: Matrix, mesh?: Mesh): void {}\r\n\r\n    /**\r\n     * Initializes the uniform buffer layout for the shader.\r\n     */\r\n    public buildUniformLayout(): void {\r\n        const ubo = this._uniformBuffer;\r\n\r\n        this._eventInfo.ubo = ubo;\r\n        this._callbackPluginEventGeneric(MaterialPluginEvent.PrepareUniformBuffer, this._eventInfo);\r\n\r\n        ubo.create();\r\n\r\n        this._uniformBufferLayoutBuilt = true;\r\n    }\r\n\r\n    /**\r\n     * Binds the submesh to the material\r\n     * @param world defines the world transformation matrix\r\n     * @param mesh defines the mesh containing the submesh\r\n     * @param subMesh defines the submesh to bind the material to\r\n     */\r\n    public bindForSubMesh(world: Matrix, mesh: Mesh, subMesh: SubMesh): void {\r\n        const drawWrapper = subMesh._drawWrapper;\r\n\r\n        this._eventInfo.subMesh = subMesh;\r\n        this._callbackPluginEventBindForSubMesh(this._eventInfo);\r\n        drawWrapper._forceRebindOnNextCall = false;\r\n    }\r\n\r\n    /**\r\n     * Binds the world matrix to the material\r\n     * @param world defines the world transformation matrix\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    public bindOnlyWorldMatrix(world: Matrix): void {}\r\n\r\n    /**\r\n     * Binds the view matrix to the effect\r\n     * @param effect defines the effect to bind the view matrix to\r\n     */\r\n    public bindView(effect: Effect): void {\r\n        if (!this._useUBO) {\r\n            effect.setMatrix(\"view\", this.getScene().getViewMatrix());\r\n        } else {\r\n            this._needToBindSceneUbo = true;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Binds the view projection and projection matrices to the effect\r\n     * @param effect defines the effect to bind the view projection and projection matrices to\r\n     */\r\n    public bindViewProjection(effect: Effect): void {\r\n        if (!this._useUBO) {\r\n            effect.setMatrix(\"viewProjection\", this.getScene().getTransformMatrix());\r\n            effect.setMatrix(\"projection\", this.getScene().getProjectionMatrix());\r\n        } else {\r\n            this._needToBindSceneUbo = true;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Binds the view matrix to the effect\r\n     * @param effect defines the effect to bind the view matrix to\r\n     * @param variableName name of the shader variable that will hold the eye position\r\n     */\r\n    public bindEyePosition(effect: Effect, variableName?: string): void {\r\n        if (!this._useUBO) {\r\n            this._scene.bindEyePosition(effect, variableName);\r\n        } else {\r\n            this._needToBindSceneUbo = true;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Processes to execute after binding the material to a mesh\r\n     * @param mesh defines the rendered mesh\r\n     * @param effect defines the effect used to bind the material\r\n     * @param _subMesh defines the subMesh that the material has been bound for\r\n     */\r\n    protected _afterBind(mesh?: Mesh, effect: Nullable<Effect> = null, _subMesh?: SubMesh): void {\r\n        this._scene._cachedMaterial = this;\r\n        if (this._needToBindSceneUbo) {\r\n            if (effect) {\r\n                this._needToBindSceneUbo = false;\r\n                BindSceneUniformBuffer(effect, this.getScene().getSceneUniformBuffer());\r\n                this._scene.finalizeSceneUbo();\r\n            }\r\n        }\r\n        if (mesh) {\r\n            this._scene._cachedVisibility = mesh.visibility;\r\n        } else {\r\n            this._scene._cachedVisibility = 1;\r\n        }\r\n\r\n        if (this._onBindObservable && mesh) {\r\n            this._onBindObservable.notifyObservers(mesh);\r\n        }\r\n\r\n        if (this.disableDepthWrite) {\r\n            const engine = this._scene.getEngine();\r\n            this._cachedDepthWriteState = engine.getDepthWrite();\r\n            engine.setDepthWrite(false);\r\n        }\r\n\r\n        if (this.disableColorWrite) {\r\n            const engine = this._scene.getEngine();\r\n            this._cachedColorWriteState = engine.getColorWrite();\r\n            engine.setColorWrite(false);\r\n        }\r\n\r\n        if (this.depthFunction !== 0) {\r\n            const engine = this._scene.getEngine();\r\n            this._cachedDepthFunctionState = engine.getDepthFunction() || 0;\r\n            engine.setDepthFunction(this.depthFunction);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Unbinds the material from the mesh\r\n     */\r\n    public unbind(): void {\r\n        if (this._onUnBindObservable) {\r\n            this._onUnBindObservable.notifyObservers(this);\r\n        }\r\n\r\n        if (this.depthFunction !== 0) {\r\n            const engine = this._scene.getEngine();\r\n            engine.setDepthFunction(this._cachedDepthFunctionState);\r\n        }\r\n\r\n        if (this.disableDepthWrite) {\r\n            const engine = this._scene.getEngine();\r\n            engine.setDepthWrite(this._cachedDepthWriteState);\r\n        }\r\n\r\n        if (this.disableColorWrite) {\r\n            const engine = this._scene.getEngine();\r\n            engine.setColorWrite(this._cachedColorWriteState);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Returns the animatable textures.\r\n     * @returns - Array of animatable textures.\r\n     */\r\n    public getAnimatables(): IAnimatable[] {\r\n        this._eventInfo.animatables = [];\r\n        this._callbackPluginEventGeneric(MaterialPluginEvent.GetAnimatables, this._eventInfo);\r\n        return this._eventInfo.animatables;\r\n    }\r\n\r\n    /**\r\n     * Gets the active textures from the material\r\n     * @returns an array of textures\r\n     */\r\n    public getActiveTextures(): BaseTexture[] {\r\n        this._eventInfo.activeTextures = [];\r\n        this._callbackPluginEventGeneric(MaterialPluginEvent.GetActiveTextures, this._eventInfo);\r\n        return this._eventInfo.activeTextures;\r\n    }\r\n\r\n    /**\r\n     * Specifies if the material uses a texture\r\n     * @param texture defines the texture to check against the material\r\n     * @returns a boolean specifying if the material uses the texture\r\n     */\r\n    public hasTexture(texture: BaseTexture): boolean {\r\n        this._eventInfo.hasTexture = false;\r\n        this._eventInfo.texture = texture;\r\n        this._callbackPluginEventGeneric(MaterialPluginEvent.HasTexture, this._eventInfo);\r\n        return this._eventInfo.hasTexture;\r\n    }\r\n\r\n    /**\r\n     * Makes a duplicate of the material, and gives it a new name\r\n     * @param name defines the new name for the duplicated material\r\n     * @returns the cloned material\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    public clone(name: string): Nullable<Material> {\r\n        return null;\r\n    }\r\n\r\n    protected _clonePlugins(targetMaterial: Material, rootUrl: string) {\r\n        const serializationObject: any = {};\r\n\r\n        // Create plugins in targetMaterial in case they don't exist\r\n        this._serializePlugins(serializationObject);\r\n\r\n        Material._ParsePlugins(serializationObject, targetMaterial, this._scene, rootUrl);\r\n\r\n        // Copy the properties of the current plugins to the cloned material's plugins\r\n        if (this.pluginManager) {\r\n            for (const plugin of this.pluginManager._plugins) {\r\n                const targetPlugin = targetMaterial.pluginManager!.getPlugin(plugin.name);\r\n                if (targetPlugin) {\r\n                    plugin.copyTo(targetPlugin);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the meshes bound to the material\r\n     * @returns an array of meshes bound to the material\r\n     */\r\n    public getBindedMeshes(): AbstractMesh[] {\r\n        if (this.meshMap) {\r\n            const result: AbstractMesh[] = [];\r\n            for (const meshId in this.meshMap) {\r\n                const mesh = this.meshMap[meshId];\r\n                if (mesh) {\r\n                    result.push(mesh);\r\n                }\r\n            }\r\n            return result;\r\n        } else {\r\n            const meshes = this._scene.meshes;\r\n            return meshes.filter((mesh) => mesh.material === this);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Force shader compilation\r\n     * @param mesh defines the mesh associated with this material\r\n     * @param onCompiled defines a function to execute once the material is compiled\r\n     * @param options defines the options to configure the compilation\r\n     * @param onError defines a function to execute if the material fails compiling\r\n     */\r\n    public forceCompilation(\r\n        mesh: AbstractMesh,\r\n        onCompiled?: (material: Material) => void,\r\n        options?: Partial<IMaterialCompilationOptions>,\r\n        onError?: (reason: string) => void\r\n    ): void {\r\n        const localOptions = {\r\n            clipPlane: false,\r\n            useInstances: false,\r\n            ...options,\r\n        };\r\n\r\n        const scene = this.getScene();\r\n        const currentHotSwapingState = this.allowShaderHotSwapping;\r\n        this.allowShaderHotSwapping = false; // Turned off to let us evaluate the real compilation state\r\n\r\n        const checkReady = () => {\r\n            if (!this._scene || !this._scene.getEngine()) {\r\n                return;\r\n            }\r\n\r\n            const clipPlaneState = scene.clipPlane;\r\n\r\n            if (localOptions.clipPlane) {\r\n                scene.clipPlane = new Plane(0, 0, 0, 1);\r\n            }\r\n\r\n            if (this._storeEffectOnSubMeshes) {\r\n                let allDone = true,\r\n                    lastError = null;\r\n                if (mesh.subMeshes) {\r\n                    const tempSubMesh = new SubMesh(0, 0, 0, 0, 0, mesh, undefined, false, false);\r\n                    if (tempSubMesh.materialDefines) {\r\n                        tempSubMesh.materialDefines._renderId = -1;\r\n                    }\r\n                    if (!this.isReadyForSubMesh(mesh, tempSubMesh, localOptions.useInstances)) {\r\n                        if (tempSubMesh.effect && tempSubMesh.effect.getCompilationError() && tempSubMesh.effect.allFallbacksProcessed()) {\r\n                            lastError = tempSubMesh.effect.getCompilationError();\r\n                        } else {\r\n                            allDone = false;\r\n                            setTimeout(checkReady, 16);\r\n                        }\r\n                    }\r\n                }\r\n                if (allDone) {\r\n                    this.allowShaderHotSwapping = currentHotSwapingState;\r\n                    if (lastError) {\r\n                        if (onError) {\r\n                            onError(lastError);\r\n                        }\r\n                    }\r\n                    if (onCompiled) {\r\n                        onCompiled(this);\r\n                    }\r\n                }\r\n            } else {\r\n                if (this.isReady()) {\r\n                    this.allowShaderHotSwapping = currentHotSwapingState;\r\n                    if (onCompiled) {\r\n                        onCompiled(this);\r\n                    }\r\n                } else {\r\n                    setTimeout(checkReady, 16);\r\n                }\r\n            }\r\n\r\n            if (localOptions.clipPlane) {\r\n                scene.clipPlane = clipPlaneState;\r\n            }\r\n        };\r\n\r\n        checkReady();\r\n    }\r\n\r\n    /**\r\n     * Force shader compilation\r\n     * @param mesh defines the mesh that will use this material\r\n     * @param options defines additional options for compiling the shaders\r\n     * @returns a promise that resolves when the compilation completes\r\n     */\r\n    public forceCompilationAsync(mesh: AbstractMesh, options?: Partial<IMaterialCompilationOptions>): Promise<void> {\r\n        return new Promise((resolve, reject) => {\r\n            this.forceCompilation(\r\n                mesh,\r\n                () => {\r\n                    resolve();\r\n                },\r\n                options,\r\n                (reason) => {\r\n                    reject(reason);\r\n                }\r\n            );\r\n        });\r\n    }\r\n\r\n    private static readonly _AllDirtyCallBack = (defines: MaterialDefines) => defines.markAllAsDirty();\r\n    private static readonly _ImageProcessingDirtyCallBack = (defines: MaterialDefines) => defines.markAsImageProcessingDirty();\r\n    private static readonly _TextureDirtyCallBack = (defines: MaterialDefines) => defines.markAsTexturesDirty();\r\n    private static readonly _FresnelDirtyCallBack = (defines: MaterialDefines) => defines.markAsFresnelDirty();\r\n    private static readonly _MiscDirtyCallBack = (defines: MaterialDefines) => defines.markAsMiscDirty();\r\n    private static readonly _PrePassDirtyCallBack = (defines: MaterialDefines) => defines.markAsPrePassDirty();\r\n    private static readonly _LightsDirtyCallBack = (defines: MaterialDefines) => defines.markAsLightDirty();\r\n    private static readonly _AttributeDirtyCallBack = (defines: MaterialDefines) => defines.markAsAttributesDirty();\r\n\r\n    private static _FresnelAndMiscDirtyCallBack = (defines: MaterialDefines) => {\r\n        Material._FresnelDirtyCallBack(defines);\r\n        Material._MiscDirtyCallBack(defines);\r\n    };\r\n\r\n    private static _TextureAndMiscDirtyCallBack = (defines: MaterialDefines) => {\r\n        Material._TextureDirtyCallBack(defines);\r\n        Material._MiscDirtyCallBack(defines);\r\n    };\r\n\r\n    private static readonly _DirtyCallbackArray: Array<(defines: MaterialDefines) => void> = [];\r\n    private static readonly _RunDirtyCallBacks = (defines: MaterialDefines) => {\r\n        for (const cb of Material._DirtyCallbackArray) {\r\n            cb(defines);\r\n        }\r\n    };\r\n\r\n    /**\r\n     * Marks a define in the material to indicate that it needs to be re-computed\r\n     * @param flag defines a flag used to determine which parts of the material have to be marked as dirty\r\n     */\r\n    public markAsDirty(flag: number): void {\r\n        if (this.getScene().blockMaterialDirtyMechanism || this._blockDirtyMechanism) {\r\n            return;\r\n        }\r\n\r\n        Material._DirtyCallbackArray.length = 0;\r\n\r\n        if (flag & Material.TextureDirtyFlag) {\r\n            Material._DirtyCallbackArray.push(Material._TextureDirtyCallBack);\r\n        }\r\n\r\n        if (flag & Material.LightDirtyFlag) {\r\n            Material._DirtyCallbackArray.push(Material._LightsDirtyCallBack);\r\n        }\r\n\r\n        if (flag & Material.FresnelDirtyFlag) {\r\n            Material._DirtyCallbackArray.push(Material._FresnelDirtyCallBack);\r\n        }\r\n\r\n        if (flag & Material.AttributesDirtyFlag) {\r\n            Material._DirtyCallbackArray.push(Material._AttributeDirtyCallBack);\r\n        }\r\n\r\n        if (flag & Material.MiscDirtyFlag) {\r\n            Material._DirtyCallbackArray.push(Material._MiscDirtyCallBack);\r\n        }\r\n\r\n        if (flag & Material.PrePassDirtyFlag) {\r\n            Material._DirtyCallbackArray.push(Material._PrePassDirtyCallBack);\r\n        }\r\n\r\n        if (Material._DirtyCallbackArray.length) {\r\n            this._markAllSubMeshesAsDirty(Material._RunDirtyCallBacks);\r\n        }\r\n\r\n        this.getScene().resetCachedMaterial();\r\n    }\r\n\r\n    /**\r\n     * Resets the draw wrappers cache for all submeshes that are using this material\r\n     */\r\n    public resetDrawCache(): void {\r\n        const meshes = this.getScene().meshes;\r\n        for (const mesh of meshes) {\r\n            if (!mesh.subMeshes) {\r\n                continue;\r\n            }\r\n            for (const subMesh of mesh.subMeshes) {\r\n                if (subMesh.getMaterial() !== this) {\r\n                    continue;\r\n                }\r\n\r\n                subMesh.resetDrawCache();\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Marks all submeshes of a material to indicate that their material defines need to be re-calculated\r\n     * @param func defines a function which checks material defines against the submeshes\r\n     */\r\n    protected _markAllSubMeshesAsDirty(func: (defines: MaterialDefines) => void) {\r\n        if (this.getScene().blockMaterialDirtyMechanism || this._blockDirtyMechanism) {\r\n            return;\r\n        }\r\n\r\n        const meshes = this.getScene().meshes;\r\n        for (const mesh of meshes) {\r\n            if (!mesh.subMeshes) {\r\n                continue;\r\n            }\r\n            for (const subMesh of mesh.subMeshes) {\r\n                // We want to skip the submeshes which are not using this material or which have not yet rendered at least once\r\n                if (subMesh.getMaterial(false) !== this) {\r\n                    continue;\r\n                }\r\n\r\n                for (const drawWrapper of subMesh._drawWrappers) {\r\n                    if (!drawWrapper || !drawWrapper.defines || !(drawWrapper.defines as MaterialDefines).markAllAsDirty) {\r\n                        continue;\r\n                    }\r\n                    if (this._materialContext === drawWrapper.materialContext) {\r\n                        func(drawWrapper.defines as MaterialDefines);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Indicates that the scene should check if the rendering now needs a prepass\r\n     */\r\n    protected _markScenePrePassDirty() {\r\n        if (this.getScene().blockMaterialDirtyMechanism || this._blockDirtyMechanism) {\r\n            return;\r\n        }\r\n\r\n        const prePassRenderer = this.getScene().enablePrePassRenderer();\r\n        if (prePassRenderer) {\r\n            prePassRenderer.markAsDirty();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Indicates that we need to re-calculated for all submeshes\r\n     */\r\n    protected _markAllSubMeshesAsAllDirty() {\r\n        this._markAllSubMeshesAsDirty(Material._AllDirtyCallBack);\r\n    }\r\n\r\n    /**\r\n     * Indicates that image processing needs to be re-calculated for all submeshes\r\n     */\r\n    protected _markAllSubMeshesAsImageProcessingDirty() {\r\n        this._markAllSubMeshesAsDirty(Material._ImageProcessingDirtyCallBack);\r\n    }\r\n\r\n    /**\r\n     * Indicates that textures need to be re-calculated for all submeshes\r\n     */\r\n    protected _markAllSubMeshesAsTexturesDirty() {\r\n        this._markAllSubMeshesAsDirty(Material._TextureDirtyCallBack);\r\n    }\r\n\r\n    /**\r\n     * Indicates that fresnel needs to be re-calculated for all submeshes\r\n     */\r\n    protected _markAllSubMeshesAsFresnelDirty() {\r\n        this._markAllSubMeshesAsDirty(Material._FresnelDirtyCallBack);\r\n    }\r\n\r\n    /**\r\n     * Indicates that fresnel and misc need to be re-calculated for all submeshes\r\n     */\r\n    protected _markAllSubMeshesAsFresnelAndMiscDirty() {\r\n        this._markAllSubMeshesAsDirty(Material._FresnelAndMiscDirtyCallBack);\r\n    }\r\n\r\n    /**\r\n     * Indicates that lights need to be re-calculated for all submeshes\r\n     */\r\n    protected _markAllSubMeshesAsLightsDirty() {\r\n        this._markAllSubMeshesAsDirty(Material._LightsDirtyCallBack);\r\n    }\r\n\r\n    /**\r\n     * Indicates that attributes need to be re-calculated for all submeshes\r\n     */\r\n    protected _markAllSubMeshesAsAttributesDirty() {\r\n        this._markAllSubMeshesAsDirty(Material._AttributeDirtyCallBack);\r\n    }\r\n\r\n    /**\r\n     * Indicates that misc needs to be re-calculated for all submeshes\r\n     */\r\n    protected _markAllSubMeshesAsMiscDirty() {\r\n        this._markAllSubMeshesAsDirty(Material._MiscDirtyCallBack);\r\n    }\r\n\r\n    /**\r\n     * Indicates that prepass needs to be re-calculated for all submeshes\r\n     */\r\n    protected _markAllSubMeshesAsPrePassDirty() {\r\n        this._markAllSubMeshesAsDirty(Material._MiscDirtyCallBack);\r\n    }\r\n\r\n    /**\r\n     * Indicates that textures and misc need to be re-calculated for all submeshes\r\n     */\r\n    protected _markAllSubMeshesAsTexturesAndMiscDirty() {\r\n        this._markAllSubMeshesAsDirty(Material._TextureAndMiscDirtyCallBack);\r\n    }\r\n\r\n    protected _checkScenePerformancePriority() {\r\n        if (this._scene.performancePriority !== ScenePerformancePriority.BackwardCompatible) {\r\n            this.checkReadyOnlyOnce = true;\r\n            // re-set the flag when the perf priority changes\r\n            const observer = this._scene.onScenePerformancePriorityChangedObservable.addOnce(() => {\r\n                this.checkReadyOnlyOnce = false;\r\n            });\r\n            // if this material is disposed before the scene is disposed, cleanup the observer\r\n            this.onDisposeObservable.add(() => {\r\n                this._scene.onScenePerformancePriorityChangedObservable.remove(observer);\r\n            });\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Sets the required values to the prepass renderer.\r\n     * @param prePassRenderer defines the prepass renderer to setup.\r\n     * @returns true if the pre pass is needed.\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    public setPrePassRenderer(prePassRenderer: PrePassRenderer): boolean {\r\n        // Do Nothing by default\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Disposes the material\r\n     * @param forceDisposeEffect specifies if effects should be forcefully disposed\r\n     * @param forceDisposeTextures specifies if textures should be forcefully disposed\r\n     * @param notBoundToMesh specifies if the material that is being disposed is known to be not bound to any mesh\r\n     */\r\n    public dispose(forceDisposeEffect?: boolean, forceDisposeTextures?: boolean, notBoundToMesh?: boolean): void {\r\n        const scene = this.getScene();\r\n        // Animations\r\n        scene.stopAnimation(this);\r\n        scene.freeProcessedMaterials();\r\n\r\n        // Remove from scene\r\n        scene.removeMaterial(this);\r\n\r\n        this._eventInfo.forceDisposeTextures = forceDisposeTextures;\r\n        this._callbackPluginEventGeneric(MaterialPluginEvent.Disposed, this._eventInfo);\r\n\r\n        if (this._parentContainer) {\r\n            const index = this._parentContainer.materials.indexOf(this);\r\n            if (index > -1) {\r\n                this._parentContainer.materials.splice(index, 1);\r\n            }\r\n            this._parentContainer = null;\r\n        }\r\n\r\n        if (notBoundToMesh !== true) {\r\n            // Remove from meshes\r\n            if (this.meshMap) {\r\n                for (const meshId in this.meshMap) {\r\n                    const mesh = this.meshMap[meshId];\r\n                    if (mesh) {\r\n                        mesh.material = null; // will set the entry in the map to undefined\r\n                        this.releaseVertexArrayObject(mesh, forceDisposeEffect);\r\n                    }\r\n                }\r\n            } else {\r\n                const meshes = scene.meshes;\r\n                for (const mesh of meshes) {\r\n                    if (mesh.material === this && !(mesh as InstancedMesh).sourceMesh) {\r\n                        mesh.material = null;\r\n                        this.releaseVertexArrayObject(mesh, forceDisposeEffect);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        this._uniformBuffer.dispose();\r\n\r\n        // Shader are kept in cache for further use but we can get rid of this by using forceDisposeEffect\r\n        if (forceDisposeEffect && this._drawWrapper.effect) {\r\n            if (!this._storeEffectOnSubMeshes) {\r\n                this._drawWrapper.effect.dispose();\r\n            }\r\n\r\n            this._drawWrapper.effect = null;\r\n        }\r\n\r\n        this.metadata = null;\r\n\r\n        // Callback\r\n        this.onDisposeObservable.notifyObservers(this);\r\n\r\n        this.onDisposeObservable.clear();\r\n        if (this._onBindObservable) {\r\n            this._onBindObservable.clear();\r\n        }\r\n\r\n        if (this._onUnBindObservable) {\r\n            this._onUnBindObservable.clear();\r\n        }\r\n\r\n        if (this._onEffectCreatedObservable) {\r\n            this._onEffectCreatedObservable.clear();\r\n        }\r\n\r\n        if (this._eventInfo) {\r\n            this._eventInfo = {} as any;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    private releaseVertexArrayObject(mesh: AbstractMesh, forceDisposeEffect?: boolean) {\r\n        const geometry = (<Mesh>mesh).geometry;\r\n        if (geometry) {\r\n            if (this._storeEffectOnSubMeshes) {\r\n                if (mesh.subMeshes) {\r\n                    for (const subMesh of mesh.subMeshes) {\r\n                        geometry._releaseVertexArrayObject(subMesh.effect);\r\n                        if (forceDisposeEffect && subMesh.effect) {\r\n                            subMesh.effect.dispose();\r\n                        }\r\n                    }\r\n                }\r\n            } else {\r\n                geometry._releaseVertexArrayObject(this._drawWrapper.effect);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Serializes this material\r\n     * @returns the serialized material object\r\n     */\r\n    public serialize(): any {\r\n        const serializationObject = SerializationHelper.Serialize(this);\r\n\r\n        serializationObject.stencil = this.stencil.serialize();\r\n        serializationObject.uniqueId = this.uniqueId;\r\n\r\n        this._serializePlugins(serializationObject);\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    protected _serializePlugins(serializationObject: any) {\r\n        serializationObject.plugins = {};\r\n\r\n        if (this.pluginManager) {\r\n            for (const plugin of this.pluginManager._plugins) {\r\n                serializationObject.plugins[plugin.getClassName()] = plugin.serialize();\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Creates a material from parsed material data\r\n     * @param parsedMaterial defines parsed material data\r\n     * @param scene defines the hosting scene\r\n     * @param rootUrl defines the root URL to use to load textures\r\n     * @returns a new material\r\n     */\r\n    public static Parse(parsedMaterial: any, scene: Scene, rootUrl: string): Nullable<Material> {\r\n        if (!parsedMaterial.customType) {\r\n            parsedMaterial.customType = \"BABYLON.StandardMaterial\";\r\n        } else if (parsedMaterial.customType === \"BABYLON.PBRMaterial\" && parsedMaterial.overloadedAlbedo) {\r\n            parsedMaterial.customType = \"BABYLON.LegacyPBRMaterial\";\r\n            if (!BABYLON.LegacyPBRMaterial) {\r\n                Logger.Error(\"Your scene is trying to load a legacy version of the PBRMaterial, please, include it from the materials library.\");\r\n                return null;\r\n            }\r\n        }\r\n\r\n        const materialType = Tools.Instantiate(parsedMaterial.customType);\r\n        const material = materialType.Parse(parsedMaterial, scene, rootUrl);\r\n        material._loadedUniqueId = parsedMaterial.uniqueId;\r\n\r\n        return material;\r\n    }\r\n\r\n    protected static _ParsePlugins(serializationObject: any, material: Material, scene: Scene, rootUrl: string) {\r\n        if (!serializationObject.plugins) {\r\n            return;\r\n        }\r\n\r\n        for (const pluginClassName in serializationObject.plugins) {\r\n            const pluginData = serializationObject.plugins[pluginClassName];\r\n\r\n            let plugin = material.pluginManager?.getPlugin(pluginData.name);\r\n\r\n            if (!plugin) {\r\n                const pluginClassType = Tools.Instantiate(\"BABYLON.\" + pluginClassName);\r\n                if (pluginClassType) {\r\n                    plugin = new pluginClassType(material);\r\n                }\r\n            }\r\n\r\n            plugin?.parse(pluginData, scene, rootUrl);\r\n        }\r\n    }\r\n}\r\n", "import type { Nullable } from \"../types\";\r\nimport type { Scene } from \"../scene\";\r\nimport { Matrix } from \"../Maths/math.vector\";\r\nimport type { AbstractMesh } from \"../Meshes/abstractMesh\";\r\nimport type { Mesh } from \"../Meshes/mesh\";\r\nimport { Material } from \"../Materials/material\";\r\nimport type { Effect } from \"../Materials/effect\";\r\nimport type { SubMesh } from \"../Meshes/subMesh\";\r\n/**\r\n * Base class of materials working in push mode in babylon JS\r\n * @internal\r\n */\r\nexport class PushMaterial extends Material {\r\n    protected _activeEffect?: Effect;\r\n\r\n    protected _normalMatrix: Matrix = new Matrix();\r\n\r\n    constructor(name: string, scene?: Scene, storeEffectOnSubMeshes = true) {\r\n        super(name, scene);\r\n        this._storeEffectOnSubMeshes = storeEffectOnSubMeshes;\r\n    }\r\n\r\n    public getEffect(): Effect {\r\n        return this._storeEffectOnSubMeshes ? this._activeEffect! : super.getEffect()!;\r\n    }\r\n\r\n    public isReady(mesh?: AbstractMesh, useInstances?: boolean): boolean {\r\n        if (!mesh) {\r\n            return false;\r\n        }\r\n\r\n        if (!this._storeEffectOnSubMeshes) {\r\n            return true;\r\n        }\r\n\r\n        if (!mesh.subMeshes || mesh.subMeshes.length === 0) {\r\n            return true;\r\n        }\r\n\r\n        return this.isReadyForSubMesh(mesh, mesh.subMeshes[0], useInstances);\r\n    }\r\n\r\n    protected _isReadyForSubMesh(subMesh: SubMesh) {\r\n        const defines = subMesh.materialDefines;\r\n        if (!this.checkReadyOnEveryCall && subMesh.effect && defines) {\r\n            if (defines._renderId === this.getScene().getRenderId()) {\r\n                return true;\r\n            }\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Binds the given world matrix to the active effect\r\n     *\r\n     * @param world the matrix to bind\r\n     */\r\n    public bindOnlyWorldMatrix(world: Matrix): void {\r\n        this._activeEffect!.setMatrix(\"world\", world);\r\n    }\r\n\r\n    /**\r\n     * Binds the given normal matrix to the active effect\r\n     *\r\n     * @param normalMatrix the matrix to bind\r\n     */\r\n    public bindOnlyNormalMatrix(normalMatrix: Matrix): void {\r\n        this._activeEffect!.setMatrix(\"normalMatrix\", normalMatrix);\r\n    }\r\n\r\n    public bind(world: Matrix, mesh?: Mesh): void {\r\n        if (!mesh) {\r\n            return;\r\n        }\r\n\r\n        this.bindForSubMesh(world, mesh, mesh.subMeshes[0]);\r\n    }\r\n\r\n    protected _afterBind(mesh?: Mesh, effect: Nullable<Effect> = null, subMesh?: SubMesh): void {\r\n        super._afterBind(mesh, effect, subMesh);\r\n        this.getScene()._cachedEffect = effect;\r\n        if (subMesh) {\r\n            subMesh._drawWrapper._forceRebindOnNextCall = false;\r\n        } else {\r\n            this._drawWrapper._forceRebindOnNextCall = false;\r\n        }\r\n    }\r\n\r\n    protected _mustRebind(scene: Scene, effect: Effect, subMesh: SubMesh, visibility = 1): boolean {\r\n        return subMesh._drawWrapper._forceRebindOnNextCall || scene.isCachedMaterialInvalid(this, effect, visibility);\r\n    }\r\n\r\n    public dispose(forceDisposeEffect?: boolean, forceDisposeTextures?: boolean, notBoundToMesh?: boolean) {\r\n        this._activeEffect = undefined;\r\n        super.dispose(forceDisposeEffect, forceDisposeTextures, notBoundToMesh);\r\n    }\r\n}\r\n", "import type { Nullable } from \"../types\";\r\nimport type { IEffectFallbacks } from \"./iEffectFallbacks\";\r\n\r\nimport type { Effect } from \"./effect\";\r\nimport type { AbstractMesh } from \"../Meshes/abstractMesh\";\r\n\r\n/**\r\n * EffectFallbacks can be used to add fallbacks (properties to disable) to certain properties when desired to improve performance.\r\n * (Eg. Start at high quality with reflection and fog, if fps is low, remove reflection, if still low remove fog)\r\n */\r\nexport class EffectFallbacks implements IEffectFallbacks {\r\n    private _defines: { [key: string]: Array<String> } = {};\r\n\r\n    private _currentRank = 32;\r\n    private _maxRank = -1;\r\n\r\n    private _mesh: Nullable<AbstractMesh> = null;\r\n\r\n    /**\r\n     * Removes the fallback from the bound mesh.\r\n     */\r\n    public unBindMesh() {\r\n        this._mesh = null;\r\n    }\r\n\r\n    /**\r\n     * Adds a fallback on the specified property.\r\n     * @param rank The rank of the fallback (Lower ranks will be fallbacked to first)\r\n     * @param define The name of the define in the shader\r\n     */\r\n    public addFallback(rank: number, define: string): void {\r\n        if (!this._defines[rank]) {\r\n            if (rank < this._currentRank) {\r\n                this._currentRank = rank;\r\n            }\r\n\r\n            if (rank > this._maxRank) {\r\n                this._maxRank = rank;\r\n            }\r\n\r\n            this._defines[rank] = new Array<String>();\r\n        }\r\n\r\n        this._defines[rank].push(define);\r\n    }\r\n\r\n    /**\r\n     * Sets the mesh to use CPU skinning when needing to fallback.\r\n     * @param rank The rank of the fallback (Lower ranks will be fallbacked to first)\r\n     * @param mesh The mesh to use the fallbacks.\r\n     */\r\n    public addCPUSkinningFallback(rank: number, mesh: AbstractMesh) {\r\n        this._mesh = mesh;\r\n\r\n        if (rank < this._currentRank) {\r\n            this._currentRank = rank;\r\n        }\r\n        if (rank > this._maxRank) {\r\n            this._maxRank = rank;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Checks to see if more fallbacks are still available.\r\n     */\r\n    public get hasMoreFallbacks(): boolean {\r\n        return this._currentRank <= this._maxRank;\r\n    }\r\n\r\n    /**\r\n     * Removes the defines that should be removed when falling back.\r\n     * @param currentDefines defines the current define statements for the shader.\r\n     * @param effect defines the current effect we try to compile\r\n     * @returns The resulting defines with defines of the current rank removed.\r\n     */\r\n    public reduce(currentDefines: string, effect: Effect): string {\r\n        // First we try to switch to CPU skinning\r\n        if (this._mesh && this._mesh.computeBonesUsingShaders && this._mesh.numBoneInfluencers > 0) {\r\n            this._mesh.computeBonesUsingShaders = false;\r\n            currentDefines = currentDefines.replace(\"#define NUM_BONE_INFLUENCERS \" + this._mesh.numBoneInfluencers, \"#define NUM_BONE_INFLUENCERS 0\");\r\n            effect._bonesComputationForcedToCPU = true;\r\n\r\n            const scene = this._mesh.getScene();\r\n            for (let index = 0; index < scene.meshes.length; index++) {\r\n                const otherMesh = scene.meshes[index];\r\n\r\n                if (!otherMesh.material) {\r\n                    if (!this._mesh.material && otherMesh.computeBonesUsingShaders && otherMesh.numBoneInfluencers > 0) {\r\n                        otherMesh.computeBonesUsingShaders = false;\r\n                    }\r\n                    continue;\r\n                }\r\n\r\n                if (!otherMesh.computeBonesUsingShaders || otherMesh.numBoneInfluencers === 0) {\r\n                    continue;\r\n                }\r\n\r\n                if (otherMesh.material.getEffect() === effect) {\r\n                    otherMesh.computeBonesUsingShaders = false;\r\n                } else if (otherMesh.subMeshes) {\r\n                    for (const subMesh of otherMesh.subMeshes) {\r\n                        const subMeshEffect = subMesh.effect;\r\n\r\n                        if (subMeshEffect === effect) {\r\n                            otherMesh.computeBonesUsingShaders = false;\r\n                            break;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        } else {\r\n            const currentFallbacks = this._defines[this._currentRank];\r\n            if (currentFallbacks) {\r\n                for (let index = 0; index < currentFallbacks.length; index++) {\r\n                    currentDefines = currentDefines.replace(\"#define \" + currentFallbacks[index], \"\");\r\n                }\r\n            }\r\n\r\n            this._currentRank++;\r\n        }\r\n\r\n        return currentDefines;\r\n    }\r\n}\r\n", "// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore\";\n\nconst name = \"lightFragmentDeclaration\";\nconst shader = `#ifdef LIGHT{X}\nuniform vec4 vLightData{X};uniform vec4 vLightDiffuse{X};\n#ifdef SPECULARTERM\nuniform vec4 vLightSpecular{X};\n#else\nvec4 vLightSpecular{X}=vec4(0.);\n#endif\n#ifdef SHADOW{X}\n#ifdef SHADOWCSM{X}\nuniform mat4 lightMatrix{X}[SHADOWCSMNUM_CASCADES{X}];uniform float viewFrustumZ{X}[SHADOWCSMNUM_CASCADES{X}];uniform float frustumLengths{X}[SHADOWCSMNUM_CASCADES{X}];uniform float cascadeBlendFactor{X};varying vec4 vPositionFromLight{X}[SHADOWCSMNUM_CASCADES{X}];varying float vDepthMetric{X}[SHADOWCSMNUM_CASCADES{X}];varying vec4 vPositionFromCamera{X};\n#if defined(SHADOWPCSS{X})\nuniform highp sampler2DArrayShadow shadowSampler{X};uniform highp sampler2DArray depthSampler{X};uniform vec2 lightSizeUVCorrection{X}[SHADOWCSMNUM_CASCADES{X}];uniform float depthCorrection{X}[SHADOWCSMNUM_CASCADES{X}];uniform float penumbraDarkness{X};\n#elif defined(SHADOWPCF{X})\nuniform highp sampler2DArrayShadow shadowSampler{X};\n#else\nuniform highp sampler2DArray shadowSampler{X};\n#endif\n#ifdef SHADOWCSMDEBUG{X}\nconst vec3 vCascadeColorsMultiplier{X}[8]=vec3[8]\n(\nvec3 ( 1.5,0.0,0.0 ),\nvec3 ( 0.0,1.5,0.0 ),\nvec3 ( 0.0,0.0,5.5 ),\nvec3 ( 1.5,0.0,5.5 ),\nvec3 ( 1.5,1.5,0.0 ),\nvec3 ( 1.0,1.0,1.0 ),\nvec3 ( 0.0,1.0,5.5 ),\nvec3 ( 0.5,3.5,0.75 )\n);vec3 shadowDebug{X};\n#endif\n#ifdef SHADOWCSMUSESHADOWMAXZ{X}\nint index{X}=-1;\n#else\nint index{X}=SHADOWCSMNUM_CASCADES{X}-1;\n#endif\nfloat diff{X}=0.;\n#elif defined(SHADOWCUBE{X})\nuniform samplerCube shadowSampler{X};\n#else\nvarying vec4 vPositionFromLight{X};varying float vDepthMetric{X};\n#if defined(SHADOWPCSS{X})\nuniform highp sampler2DShadow shadowSampler{X};uniform highp sampler2D depthSampler{X};\n#elif defined(SHADOWPCF{X})\nuniform highp sampler2DShadow shadowSampler{X};\n#else\nuniform sampler2D shadowSampler{X};\n#endif\nuniform mat4 lightMatrix{X};\n#endif\nuniform vec4 shadowsInfo{X};uniform vec2 depthValues{X};\n#endif\n#ifdef SPOTLIGHT{X}\nuniform vec4 vLightDirection{X};uniform vec4 vLightFalloff{X};\n#elif defined(POINTLIGHT{X})\nuniform vec4 vLightFalloff{X};\n#elif defined(HEMILIGHT{X})\nuniform vec3 vLightGround{X};\n#endif\n#ifdef PROJECTEDLIGHTTEXTURE{X}\nuniform mat4 textureProjectionMatrix{X};uniform sampler2D projectionLightSampler{X};\n#endif\n#endif\n`;\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @internal */\nexport const lightFragmentDeclaration = { name, shader };\n", "// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore\";\n\nconst name = \"lightUboDeclaration\";\nconst shader = `#ifdef LIGHT{X}\nuniform Light{X}\n{vec4 vLightData;vec4 vLightDiffuse;vec4 vLightSpecular;\n#ifdef SPOTLIGHT{X}\nvec4 vLightDirection;vec4 vLightFalloff;\n#elif defined(POINTLIGHT{X})\nvec4 vLightFalloff;\n#elif defined(HEMILIGHT{X})\nvec3 vLightGround;\n#endif\nvec4 shadowsInfo;vec2 depthValues;} light{X};\n#ifdef PROJECTEDLIGHTTEXTURE{X}\nuniform mat4 textureProjectionMatrix{X};uniform sampler2D projectionLightSampler{X};\n#endif\n#ifdef SHADOW{X}\n#ifdef SHADOWCSM{X}\nuniform mat4 lightMatrix{X}[SHADOWCSMNUM_CASCADES{X}];uniform float viewFrustumZ{X}[SHADOWCSMNUM_CASCADES{X}];uniform float frustumLengths{X}[SHADOWCSMNUM_CASCADES{X}];uniform float cascadeBlendFactor{X};varying vec4 vPositionFromLight{X}[SHADOWCSMNUM_CASCADES{X}];varying float vDepthMetric{X}[SHADOWCSMNUM_CASCADES{X}];varying vec4 vPositionFromCamera{X};\n#if defined(SHADOWPCSS{X})\nuniform highp sampler2DArrayShadow shadowSampler{X};uniform highp sampler2DArray depthSampler{X};uniform vec2 lightSizeUVCorrection{X}[SHADOWCSMNUM_CASCADES{X}];uniform float depthCorrection{X}[SHADOWCSMNUM_CASCADES{X}];uniform float penumbraDarkness{X};\n#elif defined(SHADOWPCF{X})\nuniform highp sampler2DArrayShadow shadowSampler{X};\n#else\nuniform highp sampler2DArray shadowSampler{X};\n#endif\n#ifdef SHADOWCSMDEBUG{X}\nconst vec3 vCascadeColorsMultiplier{X}[8]=vec3[8]\n(\nvec3 ( 1.5,0.0,0.0 ),\nvec3 ( 0.0,1.5,0.0 ),\nvec3 ( 0.0,0.0,5.5 ),\nvec3 ( 1.5,0.0,5.5 ),\nvec3 ( 1.5,1.5,0.0 ),\nvec3 ( 1.0,1.0,1.0 ),\nvec3 ( 0.0,1.0,5.5 ),\nvec3 ( 0.5,3.5,0.75 )\n);vec3 shadowDebug{X};\n#endif\n#ifdef SHADOWCSMUSESHADOWMAXZ{X}\nint index{X}=-1;\n#else\nint index{X}=SHADOWCSMNUM_CASCADES{X}-1;\n#endif\nfloat diff{X}=0.;\n#elif defined(SHADOWCUBE{X})\nuniform samplerCube shadowSampler{X}; \n#else\nvarying vec4 vPositionFromLight{X};varying float vDepthMetric{X};\n#if defined(SHADOWPCSS{X})\nuniform highp sampler2DShadow shadowSampler{X};uniform highp sampler2D depthSampler{X};\n#elif defined(SHADOWPCF{X})\nuniform highp sampler2DShadow shadowSampler{X};\n#else\nuniform sampler2D shadowSampler{X};\n#endif\nuniform mat4 lightMatrix{X};\n#endif\n#endif\n#endif\n`;\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @internal */\nexport const lightUboDeclaration = { name, shader };\n", "// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore\";\n\nconst name = \"lightsFragmentFunctions\";\nconst shader = `struct lightingInfo\n{vec3 diffuse;\n#ifdef SPECULARTERM\nvec3 specular;\n#endif\n#ifdef NDOTL\nfloat ndl;\n#endif\n};lightingInfo computeLighting(vec3 viewDirectionW,vec3 vNormal,vec4 lightData,vec3 diffuseColor,vec3 specularColor,float range,float glossiness) {lightingInfo result;vec3 lightVectorW;float attenuation=1.0;if (lightData.w==0.)\n{vec3 direction=lightData.xyz-vPositionW;attenuation=max(0.,1.0-length(direction)/range);lightVectorW=normalize(direction);}\nelse\n{lightVectorW=normalize(-lightData.xyz);}\nfloat ndl=max(0.,dot(vNormal,lightVectorW));\n#ifdef NDOTL\nresult.ndl=ndl;\n#endif\nresult.diffuse=ndl*diffuseColor*attenuation;\n#ifdef SPECULARTERM\nvec3 angleW=normalize(viewDirectionW+lightVectorW);float specComp=max(0.,dot(vNormal,angleW));specComp=pow(specComp,max(1.,glossiness));result.specular=specComp*specularColor*attenuation;\n#endif\nreturn result;}\nlightingInfo computeSpotLighting(vec3 viewDirectionW,vec3 vNormal,vec4 lightData,vec4 lightDirection,vec3 diffuseColor,vec3 specularColor,float range,float glossiness) {lightingInfo result;vec3 direction=lightData.xyz-vPositionW;vec3 lightVectorW=normalize(direction);float attenuation=max(0.,1.0-length(direction)/range);float cosAngle=max(0.,dot(lightDirection.xyz,-lightVectorW));if (cosAngle>=lightDirection.w)\n{cosAngle=max(0.,pow(cosAngle,lightData.w));attenuation*=cosAngle;float ndl=max(0.,dot(vNormal,lightVectorW));\n#ifdef NDOTL\nresult.ndl=ndl;\n#endif\nresult.diffuse=ndl*diffuseColor*attenuation;\n#ifdef SPECULARTERM\nvec3 angleW=normalize(viewDirectionW+lightVectorW);float specComp=max(0.,dot(vNormal,angleW));specComp=pow(specComp,max(1.,glossiness));result.specular=specComp*specularColor*attenuation;\n#endif\nreturn result;}\nresult.diffuse=vec3(0.);\n#ifdef SPECULARTERM\nresult.specular=vec3(0.);\n#endif\n#ifdef NDOTL\nresult.ndl=0.;\n#endif\nreturn result;}\nlightingInfo computeHemisphericLighting(vec3 viewDirectionW,vec3 vNormal,vec4 lightData,vec3 diffuseColor,vec3 specularColor,vec3 groundColor,float glossiness) {lightingInfo result;float ndl=dot(vNormal,lightData.xyz)*0.5+0.5;\n#ifdef NDOTL\nresult.ndl=ndl;\n#endif\nresult.diffuse=mix(groundColor,diffuseColor,ndl);\n#ifdef SPECULARTERM\nvec3 angleW=normalize(viewDirectionW+lightData.xyz);float specComp=max(0.,dot(vNormal,angleW));specComp=pow(specComp,max(1.,glossiness));result.specular=specComp*specularColor;\n#endif\nreturn result;}\n#define inline\nvec3 computeProjectionTextureDiffuseLighting(sampler2D projectionLightSampler,mat4 textureProjectionMatrix){vec4 strq=textureProjectionMatrix*vec4(vPositionW,1.0);strq/=strq.w;vec3 textureColor=texture2D(projectionLightSampler,strq.xy).rgb;return textureColor;}`;\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @internal */\nexport const lightsFragmentFunctions = { name, shader };\n", "// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore\";\n\nconst name = \"shadowsFragmentFunctions\";\nconst shader = `#ifdef SHADOWS\n#if defined(WEBGL2) || defined(WEBGPU) || defined(NATIVE)\n#define TEXTUREFUNC(s,c,l) texture2DLodEXT(s,c,l)\n#else\n#define TEXTUREFUNC(s,c,b) texture2D(s,c,b)\n#endif\n#ifndef SHADOWFLOAT\nfloat unpack(vec4 color)\n{const vec4 bit_shift=vec4(1.0/(255.0*255.0*255.0),1.0/(255.0*255.0),1.0/255.0,1.0);return dot(color,bit_shift);}\n#endif\nfloat computeFallOff(float value,vec2 clipSpace,float frustumEdgeFalloff)\n{float mask=smoothstep(1.0-frustumEdgeFalloff,1.00000012,clamp(dot(clipSpace,clipSpace),0.,1.));return mix(value,1.0,mask);}\n#define inline\nfloat computeShadowCube(vec3 worldPos,vec3 lightPosition,samplerCube shadowSampler,float darkness,vec2 depthValues)\n{vec3 directionToLight=worldPos-lightPosition;float depth=length(directionToLight);depth=(depth+depthValues.x)/(depthValues.y);depth=clamp(depth,0.,1.0);directionToLight=normalize(directionToLight);directionToLight.y=-directionToLight.y;\n#ifndef SHADOWFLOAT\nfloat shadow=unpack(textureCube(shadowSampler,directionToLight));\n#else\nfloat shadow=textureCube(shadowSampler,directionToLight).x;\n#endif\nreturn depth>shadow ? darkness : 1.0;}\n#define inline\nfloat computeShadowWithPoissonSamplingCube(vec3 worldPos,vec3 lightPosition,samplerCube shadowSampler,float mapSize,float darkness,vec2 depthValues)\n{vec3 directionToLight=worldPos-lightPosition;float depth=length(directionToLight);depth=(depth+depthValues.x)/(depthValues.y);depth=clamp(depth,0.,1.0);directionToLight=normalize(directionToLight);directionToLight.y=-directionToLight.y;float visibility=1.;vec3 poissonDisk[4];poissonDisk[0]=vec3(-1.0,1.0,-1.0);poissonDisk[1]=vec3(1.0,-1.0,-1.0);poissonDisk[2]=vec3(-1.0,-1.0,-1.0);poissonDisk[3]=vec3(1.0,-1.0,1.0);\n#ifndef SHADOWFLOAT\nif (unpack(textureCube(shadowSampler,directionToLight+poissonDisk[0]*mapSize))<depth) visibility-=0.25;if (unpack(textureCube(shadowSampler,directionToLight+poissonDisk[1]*mapSize))<depth) visibility-=0.25;if (unpack(textureCube(shadowSampler,directionToLight+poissonDisk[2]*mapSize))<depth) visibility-=0.25;if (unpack(textureCube(shadowSampler,directionToLight+poissonDisk[3]*mapSize))<depth) visibility-=0.25;\n#else\nif (textureCube(shadowSampler,directionToLight+poissonDisk[0]*mapSize).x<depth) visibility-=0.25;if (textureCube(shadowSampler,directionToLight+poissonDisk[1]*mapSize).x<depth) visibility-=0.25;if (textureCube(shadowSampler,directionToLight+poissonDisk[2]*mapSize).x<depth) visibility-=0.25;if (textureCube(shadowSampler,directionToLight+poissonDisk[3]*mapSize).x<depth) visibility-=0.25;\n#endif\nreturn min(1.0,visibility+darkness);}\n#define inline\nfloat computeShadowWithESMCube(vec3 worldPos,vec3 lightPosition,samplerCube shadowSampler,float darkness,float depthScale,vec2 depthValues)\n{vec3 directionToLight=worldPos-lightPosition;float depth=length(directionToLight);depth=(depth+depthValues.x)/(depthValues.y);float shadowPixelDepth=clamp(depth,0.,1.0);directionToLight=normalize(directionToLight);directionToLight.y=-directionToLight.y;\n#ifndef SHADOWFLOAT\nfloat shadowMapSample=unpack(textureCube(shadowSampler,directionToLight));\n#else\nfloat shadowMapSample=textureCube(shadowSampler,directionToLight).x;\n#endif\nfloat esm=1.0-clamp(exp(min(87.,depthScale*shadowPixelDepth))*shadowMapSample,0.,1.-darkness);return esm;}\n#define inline\nfloat computeShadowWithCloseESMCube(vec3 worldPos,vec3 lightPosition,samplerCube shadowSampler,float darkness,float depthScale,vec2 depthValues)\n{vec3 directionToLight=worldPos-lightPosition;float depth=length(directionToLight);depth=(depth+depthValues.x)/(depthValues.y);float shadowPixelDepth=clamp(depth,0.,1.0);directionToLight=normalize(directionToLight);directionToLight.y=-directionToLight.y;\n#ifndef SHADOWFLOAT\nfloat shadowMapSample=unpack(textureCube(shadowSampler,directionToLight));\n#else\nfloat shadowMapSample=textureCube(shadowSampler,directionToLight).x;\n#endif\nfloat esm=clamp(exp(min(87.,-depthScale*(shadowPixelDepth-shadowMapSample))),darkness,1.);return esm;}\n#if defined(WEBGL2) || defined(WEBGPU) || defined(NATIVE)\n#define inline\nfloat computeShadowCSM(float layer,vec4 vPositionFromLight,float depthMetric,highp sampler2DArray shadowSampler,float darkness,float frustumEdgeFalloff)\n{vec3 clipSpace=vPositionFromLight.xyz/vPositionFromLight.w;vec2 uv=0.5*clipSpace.xy+vec2(0.5);vec3 uvLayer=vec3(uv.x,uv.y,layer);float shadowPixelDepth=clamp(depthMetric,0.,1.0);\n#ifndef SHADOWFLOAT\nfloat shadow=unpack(texture2D(shadowSampler,uvLayer));\n#else\nfloat shadow=texture2D(shadowSampler,uvLayer).x;\n#endif\nreturn shadowPixelDepth>shadow ? computeFallOff(darkness,clipSpace.xy,frustumEdgeFalloff) : 1.;}\n#endif\n#define inline\nfloat computeShadow(vec4 vPositionFromLight,float depthMetric,sampler2D shadowSampler,float darkness,float frustumEdgeFalloff)\n{vec3 clipSpace=vPositionFromLight.xyz/vPositionFromLight.w;vec2 uv=0.5*clipSpace.xy+vec2(0.5);if (uv.x<0. || uv.x>1.0 || uv.y<0. || uv.y>1.0)\n{return 1.0;}\nelse\n{float shadowPixelDepth=clamp(depthMetric,0.,1.0);\n#ifndef SHADOWFLOAT\nfloat shadow=unpack(TEXTUREFUNC(shadowSampler,uv,0.));\n#else\nfloat shadow=TEXTUREFUNC(shadowSampler,uv,0.).x;\n#endif\nreturn shadowPixelDepth>shadow ? computeFallOff(darkness,clipSpace.xy,frustumEdgeFalloff) : 1.;}}\n#define inline\nfloat computeShadowWithPoissonSampling(vec4 vPositionFromLight,float depthMetric,sampler2D shadowSampler,float mapSize,float darkness,float frustumEdgeFalloff)\n{vec3 clipSpace=vPositionFromLight.xyz/vPositionFromLight.w;vec2 uv=0.5*clipSpace.xy+vec2(0.5);if (uv.x<0. || uv.x>1.0 || uv.y<0. || uv.y>1.0)\n{return 1.0;}\nelse\n{float shadowPixelDepth=clamp(depthMetric,0.,1.0);float visibility=1.;vec2 poissonDisk[4];poissonDisk[0]=vec2(-0.94201624,-0.39906216);poissonDisk[1]=vec2(0.94558609,-0.76890725);poissonDisk[2]=vec2(-0.094184101,-0.92938870);poissonDisk[3]=vec2(0.34495938,0.29387760);\n#ifndef SHADOWFLOAT\nif (unpack(TEXTUREFUNC(shadowSampler,uv+poissonDisk[0]*mapSize,0.))<shadowPixelDepth) visibility-=0.25;if (unpack(TEXTUREFUNC(shadowSampler,uv+poissonDisk[1]*mapSize,0.))<shadowPixelDepth) visibility-=0.25;if (unpack(TEXTUREFUNC(shadowSampler,uv+poissonDisk[2]*mapSize,0.))<shadowPixelDepth) visibility-=0.25;if (unpack(TEXTUREFUNC(shadowSampler,uv+poissonDisk[3]*mapSize,0.))<shadowPixelDepth) visibility-=0.25;\n#else\nif (TEXTUREFUNC(shadowSampler,uv+poissonDisk[0]*mapSize,0.).x<shadowPixelDepth) visibility-=0.25;if (TEXTUREFUNC(shadowSampler,uv+poissonDisk[1]*mapSize,0.).x<shadowPixelDepth) visibility-=0.25;if (TEXTUREFUNC(shadowSampler,uv+poissonDisk[2]*mapSize,0.).x<shadowPixelDepth) visibility-=0.25;if (TEXTUREFUNC(shadowSampler,uv+poissonDisk[3]*mapSize,0.).x<shadowPixelDepth) visibility-=0.25;\n#endif\nreturn computeFallOff(min(1.0,visibility+darkness),clipSpace.xy,frustumEdgeFalloff);}}\n#define inline\nfloat computeShadowWithESM(vec4 vPositionFromLight,float depthMetric,sampler2D shadowSampler,float darkness,float depthScale,float frustumEdgeFalloff)\n{vec3 clipSpace=vPositionFromLight.xyz/vPositionFromLight.w;vec2 uv=0.5*clipSpace.xy+vec2(0.5);if (uv.x<0. || uv.x>1.0 || uv.y<0. || uv.y>1.0)\n{return 1.0;}\nelse\n{float shadowPixelDepth=clamp(depthMetric,0.,1.0);\n#ifndef SHADOWFLOAT\nfloat shadowMapSample=unpack(TEXTUREFUNC(shadowSampler,uv,0.));\n#else\nfloat shadowMapSample=TEXTUREFUNC(shadowSampler,uv,0.).x;\n#endif\nfloat esm=1.0-clamp(exp(min(87.,depthScale*shadowPixelDepth))*shadowMapSample,0.,1.-darkness);return computeFallOff(esm,clipSpace.xy,frustumEdgeFalloff);}}\n#define inline\nfloat computeShadowWithCloseESM(vec4 vPositionFromLight,float depthMetric,sampler2D shadowSampler,float darkness,float depthScale,float frustumEdgeFalloff)\n{vec3 clipSpace=vPositionFromLight.xyz/vPositionFromLight.w;vec2 uv=0.5*clipSpace.xy+vec2(0.5);if (uv.x<0. || uv.x>1.0 || uv.y<0. || uv.y>1.0)\n{return 1.0;}\nelse\n{float shadowPixelDepth=clamp(depthMetric,0.,1.0); \n#ifndef SHADOWFLOAT\nfloat shadowMapSample=unpack(TEXTUREFUNC(shadowSampler,uv,0.));\n#else\nfloat shadowMapSample=TEXTUREFUNC(shadowSampler,uv,0.).x;\n#endif\nfloat esm=clamp(exp(min(87.,-depthScale*(shadowPixelDepth-shadowMapSample))),darkness,1.);return computeFallOff(esm,clipSpace.xy,frustumEdgeFalloff);}}\n#ifdef IS_NDC_HALF_ZRANGE\n#define ZINCLIP clipSpace.z\n#else\n#define ZINCLIP uvDepth.z\n#endif\n#if defined(WEBGL2) || defined(WEBGPU) || defined(NATIVE)\n#define GREATEST_LESS_THAN_ONE 0.99999994\n/* disable_uniformity_analysis */\n#define inline\nfloat computeShadowWithCSMPCF1(float layer,vec4 vPositionFromLight,float depthMetric,highp sampler2DArrayShadow shadowSampler,float darkness,float frustumEdgeFalloff)\n{vec3 clipSpace=vPositionFromLight.xyz/vPositionFromLight.w;vec3 uvDepth=vec3(0.5*clipSpace.xyz+vec3(0.5));uvDepth.z=clamp(ZINCLIP,0.,GREATEST_LESS_THAN_ONE);vec4 uvDepthLayer=vec4(uvDepth.x,uvDepth.y,layer,uvDepth.z);float shadow=texture2D(shadowSampler,uvDepthLayer);shadow=mix(darkness,1.,shadow);return computeFallOff(shadow,clipSpace.xy,frustumEdgeFalloff);}\n#define inline\nfloat computeShadowWithCSMPCF3(float layer,vec4 vPositionFromLight,float depthMetric,highp sampler2DArrayShadow shadowSampler,vec2 shadowMapSizeAndInverse,float darkness,float frustumEdgeFalloff)\n{vec3 clipSpace=vPositionFromLight.xyz/vPositionFromLight.w;vec3 uvDepth=vec3(0.5*clipSpace.xyz+vec3(0.5));uvDepth.z=clamp(ZINCLIP,0.,GREATEST_LESS_THAN_ONE);vec2 uv=uvDepth.xy*shadowMapSizeAndInverse.x; \nuv+=0.5; \nvec2 st=fract(uv); \nvec2 base_uv=floor(uv)-0.5; \nbase_uv*=shadowMapSizeAndInverse.y; \nvec2 uvw0=3.-2.*st;vec2 uvw1=1.+2.*st;vec2 u=vec2((2.-st.x)/uvw0.x-1.,st.x/uvw1.x+1.)*shadowMapSizeAndInverse.y;vec2 v=vec2((2.-st.y)/uvw0.y-1.,st.y/uvw1.y+1.)*shadowMapSizeAndInverse.y;float shadow=0.;shadow+=uvw0.x*uvw0.y*texture2D(shadowSampler,vec4(base_uv.xy+vec2(u[0],v[0]),layer,uvDepth.z));shadow+=uvw1.x*uvw0.y*texture2D(shadowSampler,vec4(base_uv.xy+vec2(u[1],v[0]),layer,uvDepth.z));shadow+=uvw0.x*uvw1.y*texture2D(shadowSampler,vec4(base_uv.xy+vec2(u[0],v[1]),layer,uvDepth.z));shadow+=uvw1.x*uvw1.y*texture2D(shadowSampler,vec4(base_uv.xy+vec2(u[1],v[1]),layer,uvDepth.z));shadow=shadow/16.;shadow=mix(darkness,1.,shadow);return computeFallOff(shadow,clipSpace.xy,frustumEdgeFalloff);}\n#define inline\nfloat computeShadowWithCSMPCF5(float layer,vec4 vPositionFromLight,float depthMetric,highp sampler2DArrayShadow shadowSampler,vec2 shadowMapSizeAndInverse,float darkness,float frustumEdgeFalloff)\n{vec3 clipSpace=vPositionFromLight.xyz/vPositionFromLight.w;vec3 uvDepth=vec3(0.5*clipSpace.xyz+vec3(0.5));uvDepth.z=clamp(ZINCLIP,0.,GREATEST_LESS_THAN_ONE);vec2 uv=uvDepth.xy*shadowMapSizeAndInverse.x; \nuv+=0.5; \nvec2 st=fract(uv); \nvec2 base_uv=floor(uv)-0.5; \nbase_uv*=shadowMapSizeAndInverse.y; \nvec2 uvw0=4.-3.*st;vec2 uvw1=vec2(7.);vec2 uvw2=1.+3.*st;vec3 u=vec3((3.-2.*st.x)/uvw0.x-2.,(3.+st.x)/uvw1.x,st.x/uvw2.x+2.)*shadowMapSizeAndInverse.y;vec3 v=vec3((3.-2.*st.y)/uvw0.y-2.,(3.+st.y)/uvw1.y,st.y/uvw2.y+2.)*shadowMapSizeAndInverse.y;float shadow=0.;shadow+=uvw0.x*uvw0.y*texture2D(shadowSampler,vec4(base_uv.xy+vec2(u[0],v[0]),layer,uvDepth.z));shadow+=uvw1.x*uvw0.y*texture2D(shadowSampler,vec4(base_uv.xy+vec2(u[1],v[0]),layer,uvDepth.z));shadow+=uvw2.x*uvw0.y*texture2D(shadowSampler,vec4(base_uv.xy+vec2(u[2],v[0]),layer,uvDepth.z));shadow+=uvw0.x*uvw1.y*texture2D(shadowSampler,vec4(base_uv.xy+vec2(u[0],v[1]),layer,uvDepth.z));shadow+=uvw1.x*uvw1.y*texture2D(shadowSampler,vec4(base_uv.xy+vec2(u[1],v[1]),layer,uvDepth.z));shadow+=uvw2.x*uvw1.y*texture2D(shadowSampler,vec4(base_uv.xy+vec2(u[2],v[1]),layer,uvDepth.z));shadow+=uvw0.x*uvw2.y*texture2D(shadowSampler,vec4(base_uv.xy+vec2(u[0],v[2]),layer,uvDepth.z));shadow+=uvw1.x*uvw2.y*texture2D(shadowSampler,vec4(base_uv.xy+vec2(u[1],v[2]),layer,uvDepth.z));shadow+=uvw2.x*uvw2.y*texture2D(shadowSampler,vec4(base_uv.xy+vec2(u[2],v[2]),layer,uvDepth.z));shadow=shadow/144.;shadow=mix(darkness,1.,shadow);return computeFallOff(shadow,clipSpace.xy,frustumEdgeFalloff);}\n#define inline\nfloat computeShadowWithPCF1(vec4 vPositionFromLight,float depthMetric,highp sampler2DShadow shadowSampler,float darkness,float frustumEdgeFalloff)\n{if (depthMetric>1.0 || depthMetric<0.0) {return 1.0;}\nelse\n{vec3 clipSpace=vPositionFromLight.xyz/vPositionFromLight.w;vec3 uvDepth=vec3(0.5*clipSpace.xyz+vec3(0.5));uvDepth.z=ZINCLIP;float shadow=TEXTUREFUNC(shadowSampler,uvDepth,0.);shadow=mix(darkness,1.,shadow);return computeFallOff(shadow,clipSpace.xy,frustumEdgeFalloff);}}\n#define inline\nfloat computeShadowWithPCF3(vec4 vPositionFromLight,float depthMetric,highp sampler2DShadow shadowSampler,vec2 shadowMapSizeAndInverse,float darkness,float frustumEdgeFalloff)\n{if (depthMetric>1.0 || depthMetric<0.0) {return 1.0;}\nelse\n{vec3 clipSpace=vPositionFromLight.xyz/vPositionFromLight.w;vec3 uvDepth=vec3(0.5*clipSpace.xyz+vec3(0.5));uvDepth.z=ZINCLIP;vec2 uv=uvDepth.xy*shadowMapSizeAndInverse.x; \nuv+=0.5; \nvec2 st=fract(uv); \nvec2 base_uv=floor(uv)-0.5; \nbase_uv*=shadowMapSizeAndInverse.y; \nvec2 uvw0=3.-2.*st;vec2 uvw1=1.+2.*st;vec2 u=vec2((2.-st.x)/uvw0.x-1.,st.x/uvw1.x+1.)*shadowMapSizeAndInverse.y;vec2 v=vec2((2.-st.y)/uvw0.y-1.,st.y/uvw1.y+1.)*shadowMapSizeAndInverse.y;float shadow=0.;shadow+=uvw0.x*uvw0.y*TEXTUREFUNC(shadowSampler,vec3(base_uv.xy+vec2(u[0],v[0]),uvDepth.z),0.);shadow+=uvw1.x*uvw0.y*TEXTUREFUNC(shadowSampler,vec3(base_uv.xy+vec2(u[1],v[0]),uvDepth.z),0.);shadow+=uvw0.x*uvw1.y*TEXTUREFUNC(shadowSampler,vec3(base_uv.xy+vec2(u[0],v[1]),uvDepth.z),0.);shadow+=uvw1.x*uvw1.y*TEXTUREFUNC(shadowSampler,vec3(base_uv.xy+vec2(u[1],v[1]),uvDepth.z),0.);shadow=shadow/16.;shadow=mix(darkness,1.,shadow);return computeFallOff(shadow,clipSpace.xy,frustumEdgeFalloff);}}\n#define inline\nfloat computeShadowWithPCF5(vec4 vPositionFromLight,float depthMetric,highp sampler2DShadow shadowSampler,vec2 shadowMapSizeAndInverse,float darkness,float frustumEdgeFalloff)\n{if (depthMetric>1.0 || depthMetric<0.0) {return 1.0;}\nelse\n{vec3 clipSpace=vPositionFromLight.xyz/vPositionFromLight.w;vec3 uvDepth=vec3(0.5*clipSpace.xyz+vec3(0.5));uvDepth.z=ZINCLIP;vec2 uv=uvDepth.xy*shadowMapSizeAndInverse.x; \nuv+=0.5; \nvec2 st=fract(uv); \nvec2 base_uv=floor(uv)-0.5; \nbase_uv*=shadowMapSizeAndInverse.y; \nvec2 uvw0=4.-3.*st;vec2 uvw1=vec2(7.);vec2 uvw2=1.+3.*st;vec3 u=vec3((3.-2.*st.x)/uvw0.x-2.,(3.+st.x)/uvw1.x,st.x/uvw2.x+2.)*shadowMapSizeAndInverse.y;vec3 v=vec3((3.-2.*st.y)/uvw0.y-2.,(3.+st.y)/uvw1.y,st.y/uvw2.y+2.)*shadowMapSizeAndInverse.y;float shadow=0.;shadow+=uvw0.x*uvw0.y*TEXTUREFUNC(shadowSampler,vec3(base_uv.xy+vec2(u[0],v[0]),uvDepth.z),0.);shadow+=uvw1.x*uvw0.y*TEXTUREFUNC(shadowSampler,vec3(base_uv.xy+vec2(u[1],v[0]),uvDepth.z),0.);shadow+=uvw2.x*uvw0.y*TEXTUREFUNC(shadowSampler,vec3(base_uv.xy+vec2(u[2],v[0]),uvDepth.z),0.);shadow+=uvw0.x*uvw1.y*TEXTUREFUNC(shadowSampler,vec3(base_uv.xy+vec2(u[0],v[1]),uvDepth.z),0.);shadow+=uvw1.x*uvw1.y*TEXTUREFUNC(shadowSampler,vec3(base_uv.xy+vec2(u[1],v[1]),uvDepth.z),0.);shadow+=uvw2.x*uvw1.y*TEXTUREFUNC(shadowSampler,vec3(base_uv.xy+vec2(u[2],v[1]),uvDepth.z),0.);shadow+=uvw0.x*uvw2.y*TEXTUREFUNC(shadowSampler,vec3(base_uv.xy+vec2(u[0],v[2]),uvDepth.z),0.);shadow+=uvw1.x*uvw2.y*TEXTUREFUNC(shadowSampler,vec3(base_uv.xy+vec2(u[1],v[2]),uvDepth.z),0.);shadow+=uvw2.x*uvw2.y*TEXTUREFUNC(shadowSampler,vec3(base_uv.xy+vec2(u[2],v[2]),uvDepth.z),0.);shadow=shadow/144.;shadow=mix(darkness,1.,shadow);return computeFallOff(shadow,clipSpace.xy,frustumEdgeFalloff);}}\nconst vec3 PoissonSamplers32[64]=vec3[64](\nvec3(0.06407013,0.05409927,0.),\nvec3(0.7366577,0.5789394,0.),\nvec3(-0.6270542,-0.5320278,0.),\nvec3(-0.4096107,0.8411095,0.),\nvec3(0.6849564,-0.4990818,0.),\nvec3(-0.874181,-0.04579735,0.),\nvec3(0.9989998,0.0009880066,0.),\nvec3(-0.004920578,-0.9151649,0.),\nvec3(0.1805763,0.9747483,0.),\nvec3(-0.2138451,0.2635818,0.),\nvec3(0.109845,0.3884785,0.),\nvec3(0.06876755,-0.3581074,0.),\nvec3(0.374073,-0.7661266,0.),\nvec3(0.3079132,-0.1216763,0.),\nvec3(-0.3794335,-0.8271583,0.),\nvec3(-0.203878,-0.07715034,0.),\nvec3(0.5912697,0.1469799,0.),\nvec3(-0.88069,0.3031784,0.),\nvec3(0.5040108,0.8283722,0.),\nvec3(-0.5844124,0.5494877,0.),\nvec3(0.6017799,-0.1726654,0.),\nvec3(-0.5554981,0.1559997,0.),\nvec3(-0.3016369,-0.3900928,0.),\nvec3(-0.5550632,-0.1723762,0.),\nvec3(0.925029,0.2995041,0.),\nvec3(-0.2473137,0.5538505,0.),\nvec3(0.9183037,-0.2862392,0.),\nvec3(0.2469421,0.6718712,0.),\nvec3(0.3916397,-0.4328209,0.),\nvec3(-0.03576927,-0.6220032,0.),\nvec3(-0.04661255,0.7995201,0.),\nvec3(0.4402924,0.3640312,0.),\nvec3(0.),\nvec3(0.),\nvec3(0.),\nvec3(0.),\nvec3(0.),\nvec3(0.),\nvec3(0.),\nvec3(0.),\nvec3(0.),\nvec3(0.),\nvec3(0.),\nvec3(0.),\nvec3(0.),\nvec3(0.),\nvec3(0.),\nvec3(0.),\nvec3(0.),\nvec3(0.),\nvec3(0.),\nvec3(0.),\nvec3(0.),\nvec3(0.),\nvec3(0.),\nvec3(0.),\nvec3(0.),\nvec3(0.),\nvec3(0.),\nvec3(0.),\nvec3(0.),\nvec3(0.),\nvec3(0.),\nvec3(0.)\n);const vec3 PoissonSamplers64[64]=vec3[64](\nvec3(-0.613392,0.617481,0.),\nvec3(0.170019,-0.040254,0.),\nvec3(-0.299417,0.791925,0.),\nvec3(0.645680,0.493210,0.),\nvec3(-0.651784,0.717887,0.),\nvec3(0.421003,0.027070,0.),\nvec3(-0.817194,-0.271096,0.),\nvec3(-0.705374,-0.668203,0.),\nvec3(0.977050,-0.108615,0.),\nvec3(0.063326,0.142369,0.),\nvec3(0.203528,0.214331,0.),\nvec3(-0.667531,0.326090,0.),\nvec3(-0.098422,-0.295755,0.),\nvec3(-0.885922,0.215369,0.),\nvec3(0.566637,0.605213,0.),\nvec3(0.039766,-0.396100,0.),\nvec3(0.751946,0.453352,0.),\nvec3(0.078707,-0.715323,0.),\nvec3(-0.075838,-0.529344,0.),\nvec3(0.724479,-0.580798,0.),\nvec3(0.222999,-0.215125,0.),\nvec3(-0.467574,-0.405438,0.),\nvec3(-0.248268,-0.814753,0.),\nvec3(0.354411,-0.887570,0.),\nvec3(0.175817,0.382366,0.),\nvec3(0.487472,-0.063082,0.),\nvec3(-0.084078,0.898312,0.),\nvec3(0.488876,-0.783441,0.),\nvec3(0.470016,0.217933,0.),\nvec3(-0.696890,-0.549791,0.),\nvec3(-0.149693,0.605762,0.),\nvec3(0.034211,0.979980,0.),\nvec3(0.503098,-0.308878,0.),\nvec3(-0.016205,-0.872921,0.),\nvec3(0.385784,-0.393902,0.),\nvec3(-0.146886,-0.859249,0.),\nvec3(0.643361,0.164098,0.),\nvec3(0.634388,-0.049471,0.),\nvec3(-0.688894,0.007843,0.),\nvec3(0.464034,-0.188818,0.),\nvec3(-0.440840,0.137486,0.),\nvec3(0.364483,0.511704,0.),\nvec3(0.034028,0.325968,0.),\nvec3(0.099094,-0.308023,0.),\nvec3(0.693960,-0.366253,0.),\nvec3(0.678884,-0.204688,0.),\nvec3(0.001801,0.780328,0.),\nvec3(0.145177,-0.898984,0.),\nvec3(0.062655,-0.611866,0.),\nvec3(0.315226,-0.604297,0.),\nvec3(-0.780145,0.486251,0.),\nvec3(-0.371868,0.882138,0.),\nvec3(0.200476,0.494430,0.),\nvec3(-0.494552,-0.711051,0.),\nvec3(0.612476,0.705252,0.),\nvec3(-0.578845,-0.768792,0.),\nvec3(-0.772454,-0.090976,0.),\nvec3(0.504440,0.372295,0.),\nvec3(0.155736,0.065157,0.),\nvec3(0.391522,0.849605,0.),\nvec3(-0.620106,-0.328104,0.),\nvec3(0.789239,-0.419965,0.),\nvec3(-0.545396,0.538133,0.),\nvec3(-0.178564,-0.596057,0.)\n);\n#define inline\nfloat computeShadowWithCSMPCSS(float layer,vec4 vPositionFromLight,float depthMetric,highp sampler2DArray depthSampler,highp sampler2DArrayShadow shadowSampler,float shadowMapSizeInverse,float lightSizeUV,float darkness,float frustumEdgeFalloff,int searchTapCount,int pcfTapCount,vec3[64] poissonSamplers,vec2 lightSizeUVCorrection,float depthCorrection,float penumbraDarkness)\n{vec3 clipSpace=vPositionFromLight.xyz/vPositionFromLight.w;vec3 uvDepth=vec3(0.5*clipSpace.xyz+vec3(0.5));uvDepth.z=clamp(ZINCLIP,0.,GREATEST_LESS_THAN_ONE);vec4 uvDepthLayer=vec4(uvDepth.x,uvDepth.y,layer,uvDepth.z);float blockerDepth=0.0;float sumBlockerDepth=0.0;float numBlocker=0.0;for (int i=0; i<searchTapCount; i ++) {blockerDepth=texture2D(depthSampler,vec3(uvDepth.xy+(lightSizeUV*lightSizeUVCorrection*shadowMapSizeInverse*PoissonSamplers32[i].xy),layer)).r;if (blockerDepth<depthMetric) {sumBlockerDepth+=blockerDepth;numBlocker++;}}\nfloat avgBlockerDepth=sumBlockerDepth/numBlocker;float AAOffset=shadowMapSizeInverse*10.;float penumbraRatio=((depthMetric-avgBlockerDepth)*depthCorrection+AAOffset);vec4 filterRadius=vec4(penumbraRatio*lightSizeUV*lightSizeUVCorrection*shadowMapSizeInverse,0.,0.);float random=getRand(vPositionFromLight.xy);float rotationAngle=random*3.1415926;vec2 rotationVector=vec2(cos(rotationAngle),sin(rotationAngle));float shadow=0.;for (int i=0; i<pcfTapCount; i++) {vec4 offset=vec4(poissonSamplers[i],0.);offset=vec4(offset.x*rotationVector.x-offset.y*rotationVector.y,offset.y*rotationVector.x+offset.x*rotationVector.y,0.,0.);shadow+=texture2D(shadowSampler,uvDepthLayer+offset*filterRadius);}\nshadow/=float(pcfTapCount);shadow=mix(shadow,1.,min((depthMetric-avgBlockerDepth)*depthCorrection*penumbraDarkness,1.));shadow=mix(darkness,1.,shadow);if (numBlocker<1.0) {return 1.0;}\nelse\n{return computeFallOff(shadow,clipSpace.xy,frustumEdgeFalloff);}}\n#define inline\nfloat computeShadowWithPCSS(vec4 vPositionFromLight,float depthMetric,sampler2D depthSampler,highp sampler2DShadow shadowSampler,float shadowMapSizeInverse,float lightSizeUV,float darkness,float frustumEdgeFalloff,int searchTapCount,int pcfTapCount,vec3[64] poissonSamplers)\n{if (depthMetric>1.0 || depthMetric<0.0) {return 1.0;}\nelse\n{vec3 clipSpace=vPositionFromLight.xyz/vPositionFromLight.w;vec3 uvDepth=vec3(0.5*clipSpace.xyz+vec3(0.5));uvDepth.z=ZINCLIP;float blockerDepth=0.0;float sumBlockerDepth=0.0;float numBlocker=0.0;for (int i=0; i<searchTapCount; i ++) {blockerDepth=TEXTUREFUNC(depthSampler,uvDepth.xy+(lightSizeUV*shadowMapSizeInverse*PoissonSamplers32[i].xy),0.).r;if (blockerDepth<depthMetric) {sumBlockerDepth+=blockerDepth;numBlocker++;}}\nif (numBlocker<1.0) {return 1.0;}\nelse\n{float avgBlockerDepth=sumBlockerDepth/numBlocker;float AAOffset=shadowMapSizeInverse*10.;float penumbraRatio=((depthMetric-avgBlockerDepth)+AAOffset);float filterRadius=penumbraRatio*lightSizeUV*shadowMapSizeInverse;float random=getRand(vPositionFromLight.xy);float rotationAngle=random*3.1415926;vec2 rotationVector=vec2(cos(rotationAngle),sin(rotationAngle));float shadow=0.;for (int i=0; i<pcfTapCount; i++) {vec3 offset=poissonSamplers[i];offset=vec3(offset.x*rotationVector.x-offset.y*rotationVector.y,offset.y*rotationVector.x+offset.x*rotationVector.y,0.);shadow+=TEXTUREFUNC(shadowSampler,uvDepth+offset*filterRadius,0.);}\nshadow/=float(pcfTapCount);shadow=mix(shadow,1.,depthMetric-avgBlockerDepth);shadow=mix(darkness,1.,shadow);return computeFallOff(shadow,clipSpace.xy,frustumEdgeFalloff);}}}\n#define inline\nfloat computeShadowWithPCSS16(vec4 vPositionFromLight,float depthMetric,sampler2D depthSampler,highp sampler2DShadow shadowSampler,float shadowMapSizeInverse,float lightSizeUV,float darkness,float frustumEdgeFalloff)\n{return computeShadowWithPCSS(vPositionFromLight,depthMetric,depthSampler,shadowSampler,shadowMapSizeInverse,lightSizeUV,darkness,frustumEdgeFalloff,16,16,PoissonSamplers32);}\n#define inline\nfloat computeShadowWithPCSS32(vec4 vPositionFromLight,float depthMetric,sampler2D depthSampler,highp sampler2DShadow shadowSampler,float shadowMapSizeInverse,float lightSizeUV,float darkness,float frustumEdgeFalloff)\n{return computeShadowWithPCSS(vPositionFromLight,depthMetric,depthSampler,shadowSampler,shadowMapSizeInverse,lightSizeUV,darkness,frustumEdgeFalloff,16,32,PoissonSamplers32);}\n#define inline\nfloat computeShadowWithPCSS64(vec4 vPositionFromLight,float depthMetric,sampler2D depthSampler,highp sampler2DShadow shadowSampler,float shadowMapSizeInverse,float lightSizeUV,float darkness,float frustumEdgeFalloff)\n{return computeShadowWithPCSS(vPositionFromLight,depthMetric,depthSampler,shadowSampler,shadowMapSizeInverse,lightSizeUV,darkness,frustumEdgeFalloff,32,64,PoissonSamplers64);}\n#define inline\nfloat computeShadowWithCSMPCSS16(float layer,vec4 vPositionFromLight,float depthMetric,highp sampler2DArray depthSampler,highp sampler2DArrayShadow shadowSampler,float shadowMapSizeInverse,float lightSizeUV,float darkness,float frustumEdgeFalloff,vec2 lightSizeUVCorrection,float depthCorrection,float penumbraDarkness)\n{return computeShadowWithCSMPCSS(layer,vPositionFromLight,depthMetric,depthSampler,shadowSampler,shadowMapSizeInverse,lightSizeUV,darkness,frustumEdgeFalloff,16,16,PoissonSamplers32,lightSizeUVCorrection,depthCorrection,penumbraDarkness);}\n#define inline\nfloat computeShadowWithCSMPCSS32(float layer,vec4 vPositionFromLight,float depthMetric,highp sampler2DArray depthSampler,highp sampler2DArrayShadow shadowSampler,float shadowMapSizeInverse,float lightSizeUV,float darkness,float frustumEdgeFalloff,vec2 lightSizeUVCorrection,float depthCorrection,float penumbraDarkness)\n{return computeShadowWithCSMPCSS(layer,vPositionFromLight,depthMetric,depthSampler,shadowSampler,shadowMapSizeInverse,lightSizeUV,darkness,frustumEdgeFalloff,16,32,PoissonSamplers32,lightSizeUVCorrection,depthCorrection,penumbraDarkness);}\n#define inline\nfloat computeShadowWithCSMPCSS64(float layer,vec4 vPositionFromLight,float depthMetric,highp sampler2DArray depthSampler,highp sampler2DArrayShadow shadowSampler,float shadowMapSizeInverse,float lightSizeUV,float darkness,float frustumEdgeFalloff,vec2 lightSizeUVCorrection,float depthCorrection,float penumbraDarkness)\n{return computeShadowWithCSMPCSS(layer,vPositionFromLight,depthMetric,depthSampler,shadowSampler,shadowMapSizeInverse,lightSizeUV,darkness,frustumEdgeFalloff,32,64,PoissonSamplers64,lightSizeUVCorrection,depthCorrection,penumbraDarkness);}\n#endif\n#endif\n`;\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @internal */\nexport const shadowsFragmentFunctions = { name, shader };\n", "// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore\";\n\nconst name = \"clipPlaneFragmentDeclaration\";\nconst shader = `#ifdef CLIPPLANE\nvarying float fClipDistance;\n#endif\n#ifdef CLIPPLANE2\nvarying float fClipDistance2;\n#endif\n#ifdef CLIPPLANE3\nvarying float fClipDistance3;\n#endif\n#ifdef CLIPPLANE4\nvarying float fClipDistance4;\n#endif\n#ifdef CLIPPLANE5\nvarying float fClipDistance5;\n#endif\n#ifdef CLIPPLANE6\nvarying float fClipDistance6;\n#endif\n`;\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @internal */\nexport const clipPlaneFragmentDeclaration = { name, shader };\n", "// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore\";\n\nconst name = \"logDepthDeclaration\";\nconst shader = `#ifdef LOGARITHMICDEPTH\nuniform float logarithmicDepthConstant;varying float vFragmentDepth;\n#endif\n`;\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @internal */\nexport const logDepthDeclaration = { name, shader };\n", "// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore\";\n\nconst name = \"fogFragmentDeclaration\";\nconst shader = `#ifdef FOG\n#define FOGMODE_NONE 0.\n#define FOGMODE_EXP 1.\n#define FOGMODE_EXP2 2.\n#define FOGMODE_LINEAR 3.\n#define E 2.71828\nuniform vec4 vFogInfos;uniform vec3 vFogColor;varying vec3 vFogDistance;float CalcFogFactor()\n{float fogCoeff=1.0;float fogStart=vFogInfos.y;float fogEnd=vFogInfos.z;float fogDensity=vFogInfos.w;float fogDistance=length(vFogDistance);if (FOGMODE_LINEAR==vFogInfos.x)\n{fogCoeff=(fogEnd-fogDistance)/(fogEnd-fogStart);}\nelse if (FOGMODE_EXP==vFogInfos.x)\n{fogCoeff=1.0/pow(E,fogDistance*fogDensity);}\nelse if (FOGMODE_EXP2==vFogInfos.x)\n{fogCoeff=1.0/pow(E,fogDistance*fogDistance*fogDensity*fogDensity);}\nreturn clamp(fogCoeff,0.0,1.0);}\n#endif\n`;\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @internal */\nexport const fogFragmentDeclaration = { name, shader };\n", "// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore\";\n\nconst name = \"clipPlaneFragment\";\nconst shader = `#if defined(CLIPPLANE) || defined(CLIPPLANE2) || defined(CLIPPLANE3) || defined(CLIPPLANE4) || defined(CLIPPLANE5) || defined(CLIPPLANE6)\nif (false) {}\n#endif\n#ifdef CLIPPLANE\nelse if (fClipDistance>0.0)\n{discard;}\n#endif\n#ifdef CLIPPLANE2\nelse if (fClipDistance2>0.0)\n{discard;}\n#endif\n#ifdef CLIPPLANE3\nelse if (fClipDistance3>0.0)\n{discard;}\n#endif\n#ifdef CLIPPLANE4\nelse if (fClipDistance4>0.0)\n{discard;}\n#endif\n#ifdef CLIPPLANE5\nelse if (fClipDistance5>0.0)\n{discard;}\n#endif\n#ifdef CLIPPLANE6\nelse if (fClipDistance6>0.0)\n{discard;}\n#endif\n`;\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @internal */\nexport const clipPlaneFragment = { name, shader };\n", "// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore\";\n\nconst name = \"lightFragment\";\nconst shader = `#ifdef LIGHT{X}\n#if defined(SHADOWONLY) || defined(LIGHTMAP) && defined(LIGHTMAPEXCLUDED{X}) && defined(LIGHTMAPNOSPECULAR{X})\n#else\n#ifdef PBR\n#ifdef SPOTLIGHT{X}\npreInfo=computePointAndSpotPreLightingInfo(light{X}.vLightData,viewDirectionW,normalW);\n#elif defined(POINTLIGHT{X})\npreInfo=computePointAndSpotPreLightingInfo(light{X}.vLightData,viewDirectionW,normalW);\n#elif defined(HEMILIGHT{X})\npreInfo=computeHemisphericPreLightingInfo(light{X}.vLightData,viewDirectionW,normalW);\n#elif defined(DIRLIGHT{X})\npreInfo=computeDirectionalPreLightingInfo(light{X}.vLightData,viewDirectionW,normalW);\n#endif\npreInfo.NdotV=NdotV;\n#ifdef SPOTLIGHT{X}\n#ifdef LIGHT_FALLOFF_GLTF{X}\npreInfo.attenuation=computeDistanceLightFalloff_GLTF(preInfo.lightDistanceSquared,light{X}.vLightFalloff.y);preInfo.attenuation*=computeDirectionalLightFalloff_GLTF(light{X}.vLightDirection.xyz,preInfo.L,light{X}.vLightFalloff.z,light{X}.vLightFalloff.w);\n#elif defined(LIGHT_FALLOFF_PHYSICAL{X})\npreInfo.attenuation=computeDistanceLightFalloff_Physical(preInfo.lightDistanceSquared);preInfo.attenuation*=computeDirectionalLightFalloff_Physical(light{X}.vLightDirection.xyz,preInfo.L,light{X}.vLightDirection.w);\n#elif defined(LIGHT_FALLOFF_STANDARD{X})\npreInfo.attenuation=computeDistanceLightFalloff_Standard(preInfo.lightOffset,light{X}.vLightFalloff.x);preInfo.attenuation*=computeDirectionalLightFalloff_Standard(light{X}.vLightDirection.xyz,preInfo.L,light{X}.vLightDirection.w,light{X}.vLightData.w);\n#else\npreInfo.attenuation=computeDistanceLightFalloff(preInfo.lightOffset,preInfo.lightDistanceSquared,light{X}.vLightFalloff.x,light{X}.vLightFalloff.y);preInfo.attenuation*=computeDirectionalLightFalloff(light{X}.vLightDirection.xyz,preInfo.L,light{X}.vLightDirection.w,light{X}.vLightData.w,light{X}.vLightFalloff.z,light{X}.vLightFalloff.w);\n#endif\n#elif defined(POINTLIGHT{X})\n#ifdef LIGHT_FALLOFF_GLTF{X}\npreInfo.attenuation=computeDistanceLightFalloff_GLTF(preInfo.lightDistanceSquared,light{X}.vLightFalloff.y);\n#elif defined(LIGHT_FALLOFF_PHYSICAL{X})\npreInfo.attenuation=computeDistanceLightFalloff_Physical(preInfo.lightDistanceSquared);\n#elif defined(LIGHT_FALLOFF_STANDARD{X})\npreInfo.attenuation=computeDistanceLightFalloff_Standard(preInfo.lightOffset,light{X}.vLightFalloff.x);\n#else\npreInfo.attenuation=computeDistanceLightFalloff(preInfo.lightOffset,preInfo.lightDistanceSquared,light{X}.vLightFalloff.x,light{X}.vLightFalloff.y);\n#endif\n#else\npreInfo.attenuation=1.0;\n#endif\n#ifdef HEMILIGHT{X}\npreInfo.roughness=roughness;\n#else\npreInfo.roughness=adjustRoughnessFromLightProperties(roughness,light{X}.vLightSpecular.a,preInfo.lightDistance);\n#endif\n#ifdef IRIDESCENCE\npreInfo.iridescenceIntensity=iridescenceIntensity;\n#endif\n#ifdef HEMILIGHT{X}\ninfo.diffuse=computeHemisphericDiffuseLighting(preInfo,light{X}.vLightDiffuse.rgb,light{X}.vLightGround);\n#elif defined(SS_TRANSLUCENCY)\ninfo.diffuse=computeDiffuseAndTransmittedLighting(preInfo,light{X}.vLightDiffuse.rgb,subSurfaceOut.transmittance);\n#else\ninfo.diffuse=computeDiffuseLighting(preInfo,light{X}.vLightDiffuse.rgb);\n#endif\n#ifdef SPECULARTERM\n#ifdef ANISOTROPIC\ninfo.specular=computeAnisotropicSpecularLighting(preInfo,viewDirectionW,normalW,anisotropicOut.anisotropicTangent,anisotropicOut.anisotropicBitangent,anisotropicOut.anisotropy,clearcoatOut.specularEnvironmentR0,specularEnvironmentR90,AARoughnessFactors.x,light{X}.vLightDiffuse.rgb);\n#else\ninfo.specular=computeSpecularLighting(preInfo,normalW,clearcoatOut.specularEnvironmentR0,specularEnvironmentR90,AARoughnessFactors.x,light{X}.vLightDiffuse.rgb);\n#endif\n#endif\n#ifdef SHEEN\n#ifdef SHEEN_LINKWITHALBEDO\npreInfo.roughness=sheenOut.sheenIntensity;\n#else\n#ifdef HEMILIGHT{X}\npreInfo.roughness=sheenOut.sheenRoughness;\n#else\npreInfo.roughness=adjustRoughnessFromLightProperties(sheenOut.sheenRoughness,light{X}.vLightSpecular.a,preInfo.lightDistance);\n#endif\n#endif\ninfo.sheen=computeSheenLighting(preInfo,normalW,sheenOut.sheenColor,specularEnvironmentR90,AARoughnessFactors.x,light{X}.vLightDiffuse.rgb);\n#endif\n#ifdef CLEARCOAT\n#ifdef HEMILIGHT{X}\npreInfo.roughness=clearcoatOut.clearCoatRoughness;\n#else\npreInfo.roughness=adjustRoughnessFromLightProperties(clearcoatOut.clearCoatRoughness,light{X}.vLightSpecular.a,preInfo.lightDistance);\n#endif\ninfo.clearCoat=computeClearCoatLighting(preInfo,clearcoatOut.clearCoatNormalW,clearcoatOut.clearCoatAARoughnessFactors.x,clearcoatOut.clearCoatIntensity,light{X}.vLightDiffuse.rgb);\n#ifdef CLEARCOAT_TINT\nabsorption=computeClearCoatLightingAbsorption(clearcoatOut.clearCoatNdotVRefract,preInfo.L,clearcoatOut.clearCoatNormalW,clearcoatOut.clearCoatColor,clearcoatOut.clearCoatThickness,clearcoatOut.clearCoatIntensity);info.diffuse*=absorption;\n#ifdef SPECULARTERM\ninfo.specular*=absorption;\n#endif\n#endif\ninfo.diffuse*=info.clearCoat.w;\n#ifdef SPECULARTERM\ninfo.specular*=info.clearCoat.w;\n#endif\n#ifdef SHEEN\ninfo.sheen*=info.clearCoat.w;\n#endif\n#endif\n#else\n#ifdef SPOTLIGHT{X}\ninfo=computeSpotLighting(viewDirectionW,normalW,light{X}.vLightData,light{X}.vLightDirection,light{X}.vLightDiffuse.rgb,light{X}.vLightSpecular.rgb,light{X}.vLightDiffuse.a,glossiness);\n#elif defined(HEMILIGHT{X})\ninfo=computeHemisphericLighting(viewDirectionW,normalW,light{X}.vLightData,light{X}.vLightDiffuse.rgb,light{X}.vLightSpecular.rgb,light{X}.vLightGround,glossiness);\n#elif defined(POINTLIGHT{X}) || defined(DIRLIGHT{X})\ninfo=computeLighting(viewDirectionW,normalW,light{X}.vLightData,light{X}.vLightDiffuse.rgb,light{X}.vLightSpecular.rgb,light{X}.vLightDiffuse.a,glossiness);\n#endif\n#endif\n#ifdef PROJECTEDLIGHTTEXTURE{X}\ninfo.diffuse*=computeProjectionTextureDiffuseLighting(projectionLightSampler{X},textureProjectionMatrix{X});\n#endif\n#endif\n#ifdef SHADOW{X}\n#ifdef SHADOWCSM{X}\nfor (int i=0; i<SHADOWCSMNUM_CASCADES{X}; i++) \n{\n#ifdef SHADOWCSM_RIGHTHANDED{X}\ndiff{X}=viewFrustumZ{X}[i]+vPositionFromCamera{X}.z;\n#else\ndiff{X}=viewFrustumZ{X}[i]-vPositionFromCamera{X}.z;\n#endif\nif (diff{X}>=0.) {index{X}=i;break;}}\n#ifdef SHADOWCSMUSESHADOWMAXZ{X}\nif (index{X}>=0)\n#endif\n{\n#if defined(SHADOWPCF{X})\n#if defined(SHADOWLOWQUALITY{X})\nshadow=computeShadowWithCSMPCF1(float(index{X}),vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],shadowSampler{X},light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);\n#elif defined(SHADOWMEDIUMQUALITY{X})\nshadow=computeShadowWithCSMPCF3(float(index{X}),vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],shadowSampler{X},light{X}.shadowsInfo.yz,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);\n#else\nshadow=computeShadowWithCSMPCF5(float(index{X}),vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],shadowSampler{X},light{X}.shadowsInfo.yz,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);\n#endif\n#elif defined(SHADOWPCSS{X})\n#if defined(SHADOWLOWQUALITY{X})\nshadow=computeShadowWithCSMPCSS16(float(index{X}),vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],depthSampler{X},shadowSampler{X},light{X}.shadowsInfo.y,light{X}.shadowsInfo.z,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w,lightSizeUVCorrection{X}[index{X}],depthCorrection{X}[index{X}],penumbraDarkness{X});\n#elif defined(SHADOWMEDIUMQUALITY{X})\nshadow=computeShadowWithCSMPCSS32(float(index{X}),vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],depthSampler{X},shadowSampler{X},light{X}.shadowsInfo.y,light{X}.shadowsInfo.z,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w,lightSizeUVCorrection{X}[index{X}],depthCorrection{X}[index{X}],penumbraDarkness{X});\n#else\nshadow=computeShadowWithCSMPCSS64(float(index{X}),vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],depthSampler{X},shadowSampler{X},light{X}.shadowsInfo.y,light{X}.shadowsInfo.z,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w,lightSizeUVCorrection{X}[index{X}],depthCorrection{X}[index{X}],penumbraDarkness{X});\n#endif\n#else\nshadow=computeShadowCSM(float(index{X}),vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],shadowSampler{X},light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);\n#endif\n#ifdef SHADOWCSMDEBUG{X}\nshadowDebug{X}=vec3(shadow)*vCascadeColorsMultiplier{X}[index{X}];\n#endif\n#ifndef SHADOWCSMNOBLEND{X}\nfloat frustumLength=frustumLengths{X}[index{X}];float diffRatio=clamp(diff{X}/frustumLength,0.,1.)*cascadeBlendFactor{X};if (index{X}<(SHADOWCSMNUM_CASCADES{X}-1) && diffRatio<1.)\n{index{X}+=1;float nextShadow=0.;\n#if defined(SHADOWPCF{X})\n#if defined(SHADOWLOWQUALITY{X})\nnextShadow=computeShadowWithCSMPCF1(float(index{X}),vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],shadowSampler{X},light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);\n#elif defined(SHADOWMEDIUMQUALITY{X})\nnextShadow=computeShadowWithCSMPCF3(float(index{X}),vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],shadowSampler{X},light{X}.shadowsInfo.yz,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);\n#else\nnextShadow=computeShadowWithCSMPCF5(float(index{X}),vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],shadowSampler{X},light{X}.shadowsInfo.yz,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);\n#endif\n#elif defined(SHADOWPCSS{X})\n#if defined(SHADOWLOWQUALITY{X})\nnextShadow=computeShadowWithCSMPCSS16(float(index{X}),vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],depthSampler{X},shadowSampler{X},light{X}.shadowsInfo.y,light{X}.shadowsInfo.z,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w,lightSizeUVCorrection{X}[index{X}],depthCorrection{X}[index{X}],penumbraDarkness{X});\n#elif defined(SHADOWMEDIUMQUALITY{X})\nnextShadow=computeShadowWithCSMPCSS32(float(index{X}),vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],depthSampler{X},shadowSampler{X},light{X}.shadowsInfo.y,light{X}.shadowsInfo.z,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w,lightSizeUVCorrection{X}[index{X}],depthCorrection{X}[index{X}],penumbraDarkness{X});\n#else\nnextShadow=computeShadowWithCSMPCSS64(float(index{X}),vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],depthSampler{X},shadowSampler{X},light{X}.shadowsInfo.y,light{X}.shadowsInfo.z,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w,lightSizeUVCorrection{X}[index{X}],depthCorrection{X}[index{X}],penumbraDarkness{X});\n#endif\n#else\nnextShadow=computeShadowCSM(float(index{X}),vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],shadowSampler{X},light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);\n#endif\nshadow=mix(nextShadow,shadow,diffRatio);\n#ifdef SHADOWCSMDEBUG{X}\nshadowDebug{X}=mix(vec3(nextShadow)*vCascadeColorsMultiplier{X}[index{X}],shadowDebug{X},diffRatio);\n#endif\n}\n#endif\n}\n#elif defined(SHADOWCLOSEESM{X})\n#if defined(SHADOWCUBE{X})\nshadow=computeShadowWithCloseESMCube(vPositionW,light{X}.vLightData.xyz,shadowSampler{X},light{X}.shadowsInfo.x,light{X}.shadowsInfo.z,light{X}.depthValues);\n#else\nshadow=computeShadowWithCloseESM(vPositionFromLight{X},vDepthMetric{X},shadowSampler{X},light{X}.shadowsInfo.x,light{X}.shadowsInfo.z,light{X}.shadowsInfo.w);\n#endif\n#elif defined(SHADOWESM{X})\n#if defined(SHADOWCUBE{X})\nshadow=computeShadowWithESMCube(vPositionW,light{X}.vLightData.xyz,shadowSampler{X},light{X}.shadowsInfo.x,light{X}.shadowsInfo.z,light{X}.depthValues);\n#else\nshadow=computeShadowWithESM(vPositionFromLight{X},vDepthMetric{X},shadowSampler{X},light{X}.shadowsInfo.x,light{X}.shadowsInfo.z,light{X}.shadowsInfo.w);\n#endif\n#elif defined(SHADOWPOISSON{X})\n#if defined(SHADOWCUBE{X})\nshadow=computeShadowWithPoissonSamplingCube(vPositionW,light{X}.vLightData.xyz,shadowSampler{X},light{X}.shadowsInfo.y,light{X}.shadowsInfo.x,light{X}.depthValues);\n#else\nshadow=computeShadowWithPoissonSampling(vPositionFromLight{X},vDepthMetric{X},shadowSampler{X},light{X}.shadowsInfo.y,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);\n#endif\n#elif defined(SHADOWPCF{X})\n#if defined(SHADOWLOWQUALITY{X})\nshadow=computeShadowWithPCF1(vPositionFromLight{X},vDepthMetric{X},shadowSampler{X},light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);\n#elif defined(SHADOWMEDIUMQUALITY{X})\nshadow=computeShadowWithPCF3(vPositionFromLight{X},vDepthMetric{X},shadowSampler{X},light{X}.shadowsInfo.yz,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);\n#else\nshadow=computeShadowWithPCF5(vPositionFromLight{X},vDepthMetric{X},shadowSampler{X},light{X}.shadowsInfo.yz,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);\n#endif\n#elif defined(SHADOWPCSS{X})\n#if defined(SHADOWLOWQUALITY{X})\nshadow=computeShadowWithPCSS16(vPositionFromLight{X},vDepthMetric{X},depthSampler{X},shadowSampler{X},light{X}.shadowsInfo.y,light{X}.shadowsInfo.z,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);\n#elif defined(SHADOWMEDIUMQUALITY{X})\nshadow=computeShadowWithPCSS32(vPositionFromLight{X},vDepthMetric{X},depthSampler{X},shadowSampler{X},light{X}.shadowsInfo.y,light{X}.shadowsInfo.z,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);\n#else\nshadow=computeShadowWithPCSS64(vPositionFromLight{X},vDepthMetric{X},depthSampler{X},shadowSampler{X},light{X}.shadowsInfo.y,light{X}.shadowsInfo.z,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);\n#endif\n#else\n#if defined(SHADOWCUBE{X})\nshadow=computeShadowCube(vPositionW,light{X}.vLightData.xyz,shadowSampler{X},light{X}.shadowsInfo.x,light{X}.depthValues);\n#else\nshadow=computeShadow(vPositionFromLight{X},vDepthMetric{X},shadowSampler{X},light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);\n#endif\n#endif\n#ifdef SHADOWONLY\n#ifndef SHADOWINUSE\n#define SHADOWINUSE\n#endif\nglobalShadow+=shadow;shadowLightCount+=1.0;\n#endif\n#else\nshadow=1.;\n#endif\naggShadow+=shadow;numLights+=1.0;\n#ifndef SHADOWONLY\n#ifdef CUSTOMUSERLIGHTING\ndiffuseBase+=computeCustomDiffuseLighting(info,diffuseBase,shadow);\n#ifdef SPECULARTERM\nspecularBase+=computeCustomSpecularLighting(info,specularBase,shadow);\n#endif\n#elif defined(LIGHTMAP) && defined(LIGHTMAPEXCLUDED{X})\ndiffuseBase+=lightmapColor.rgb*shadow;\n#ifdef SPECULARTERM\n#ifndef LIGHTMAPNOSPECULAR{X}\nspecularBase+=info.specular*shadow*lightmapColor.rgb;\n#endif\n#endif\n#ifdef CLEARCOAT\n#ifndef LIGHTMAPNOSPECULAR{X}\nclearCoatBase+=info.clearCoat.rgb*shadow*lightmapColor.rgb;\n#endif\n#endif\n#ifdef SHEEN\n#ifndef LIGHTMAPNOSPECULAR{X}\nsheenBase+=info.sheen.rgb*shadow;\n#endif\n#endif\n#else\n#ifdef SHADOWCSMDEBUG{X}\ndiffuseBase+=info.diffuse*shadowDebug{X};\n#else \ndiffuseBase+=info.diffuse*shadow;\n#endif\n#ifdef SPECULARTERM\nspecularBase+=info.specular*shadow;\n#endif\n#ifdef CLEARCOAT\nclearCoatBase+=info.clearCoat.rgb*shadow;\n#endif\n#ifdef SHEEN\nsheenBase+=info.sheen.rgb*shadow;\n#endif\n#endif\n#endif\n#endif\n`;\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @internal */\nexport const lightFragment = { name, shader };\n", "// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore\";\n\nconst name = \"logDepthFragment\";\nconst shader = `#ifdef LOGARITHMICDEPTH\ngl_FragDepthEXT=log2(vFragmentDepth)*logarithmicDepthConstant*0.5;\n#endif\n`;\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @internal */\nexport const logDepthFragment = { name, shader };\n", "// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore\";\n\nconst name = \"fogFragment\";\nconst shader = `#ifdef FOG\nfloat fog=CalcFogFactor();\n#ifdef PBR\nfog=toLinearSpace(fog);\n#endif\ncolor.rgb=mix(vFogColor,color.rgb,fog);\n#endif\n`;\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @internal */\nexport const fogFragment = { name, shader };\n", "// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore\";\n\nconst name = \"bonesDeclaration\";\nconst shader = `#if NUM_BONE_INFLUENCERS>0\nattribute vec4 matricesIndices;attribute vec4 matricesWeights;\n#if NUM_BONE_INFLUENCERS>4\nattribute vec4 matricesIndicesExtra;attribute vec4 matricesWeightsExtra;\n#endif\n#ifndef BAKED_VERTEX_ANIMATION_TEXTURE\n#ifdef BONETEXTURE\nuniform highp sampler2D boneSampler;uniform float boneTextureWidth;\n#else\nuniform mat4 mBones[BonesPerMesh];\n#endif\n#ifdef BONES_VELOCITY_ENABLED\nuniform mat4 mPreviousBones[BonesPerMesh];\n#endif\n#ifdef BONETEXTURE\n#define inline\nmat4 readMatrixFromRawSampler(sampler2D smp,float index)\n{float offset=index *4.0;float dx=1.0/boneTextureWidth;vec4 m0=texture2D(smp,vec2(dx*(offset+0.5),0.));vec4 m1=texture2D(smp,vec2(dx*(offset+1.5),0.));vec4 m2=texture2D(smp,vec2(dx*(offset+2.5),0.));vec4 m3=texture2D(smp,vec2(dx*(offset+3.5),0.));return mat4(m0,m1,m2,m3);}\n#endif\n#endif\n#endif\n`;\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @internal */\nexport const bonesDeclaration = { name, shader };\n", "// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore\";\n\nconst name = \"bakedVertexAnimationDeclaration\";\nconst shader = `#ifdef BAKED_VERTEX_ANIMATION_TEXTURE\nuniform float bakedVertexAnimationTime;uniform vec2 bakedVertexAnimationTextureSizeInverted;uniform vec4 bakedVertexAnimationSettings;uniform sampler2D bakedVertexAnimationTexture;\n#ifdef INSTANCES\nattribute vec4 bakedVertexAnimationSettingsInstanced;\n#endif\n#define inline\nmat4 readMatrixFromRawSamplerVAT(sampler2D smp,float index,float frame)\n{float offset=index*4.0;float frameUV=(frame+0.5)*bakedVertexAnimationTextureSizeInverted.y;float dx=bakedVertexAnimationTextureSizeInverted.x;vec4 m0=texture2D(smp,vec2(dx*(offset+0.5),frameUV));vec4 m1=texture2D(smp,vec2(dx*(offset+1.5),frameUV));vec4 m2=texture2D(smp,vec2(dx*(offset+2.5),frameUV));vec4 m3=texture2D(smp,vec2(dx*(offset+3.5),frameUV));return mat4(m0,m1,m2,m3);}\n#endif\n`;\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @internal */\nexport const bakedVertexAnimationDeclaration = { name, shader };\n", "// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore\";\n\nconst name = \"instancesDeclaration\";\nconst shader = `#ifdef INSTANCES\nattribute vec4 world0;attribute vec4 world1;attribute vec4 world2;attribute vec4 world3;\n#ifdef INSTANCESCOLOR\nattribute vec4 instanceColor;\n#endif\n#if defined(THIN_INSTANCES) && !defined(WORLD_UBO)\nuniform mat4 world;\n#endif\n#if defined(VELOCITY) || defined(PREPASS_VELOCITY)\nattribute vec4 previousWorld0;attribute vec4 previousWorld1;attribute vec4 previousWorld2;attribute vec4 previousWorld3;\n#ifdef THIN_INSTANCES\nuniform mat4 previousWorld;\n#endif\n#endif\n#else\n#if !defined(WORLD_UBO)\nuniform mat4 world;\n#endif\n#if defined(VELOCITY) || defined(PREPASS_VELOCITY)\nuniform mat4 previousWorld;\n#endif\n#endif\n`;\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @internal */\nexport const instancesDeclaration = { name, shader };\n", "// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore\";\n\nconst name = \"clipPlaneVertexDeclaration\";\nconst shader = `#ifdef CLIPPLANE\nuniform vec4 vClipPlane;varying float fClipDistance;\n#endif\n#ifdef CLIPPLANE2\nuniform vec4 vClipPlane2;varying float fClipDistance2;\n#endif\n#ifdef CLIPPLANE3\nuniform vec4 vClipPlane3;varying float fClipDistance3;\n#endif\n#ifdef CLIPPLANE4\nuniform vec4 vClipPlane4;varying float fClipDistance4;\n#endif\n#ifdef CLIPPLANE5\nuniform vec4 vClipPlane5;varying float fClipDistance5;\n#endif\n#ifdef CLIPPLANE6\nuniform vec4 vClipPlane6;varying float fClipDistance6;\n#endif\n`;\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @internal */\nexport const clipPlaneVertexDeclaration = { name, shader };\n", "// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore\";\n\nconst name = \"fogVertexDeclaration\";\nconst shader = `#ifdef FOG\nvarying vec3 vFogDistance;\n#endif\n`;\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @internal */\nexport const fogVertexDeclaration = { name, shader };\n", "// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore\";\n\nconst name = \"instancesVertex\";\nconst shader = `#ifdef INSTANCES\nmat4 finalWorld=mat4(world0,world1,world2,world3);\n#if defined(PREPASS_VELOCITY) || defined(VELOCITY)\nmat4 finalPreviousWorld=mat4(previousWorld0,previousWorld1,previousWorld2,previousWorld3);\n#endif\n#ifdef THIN_INSTANCES\nfinalWorld=world*finalWorld;\n#if defined(PREPASS_VELOCITY) || defined(VELOCITY)\nfinalPreviousWorld=previousWorld*finalPreviousWorld;\n#endif\n#endif\n#else\nmat4 finalWorld=world;\n#if defined(PREPASS_VELOCITY) || defined(VELOCITY)\nmat4 finalPreviousWorld=previousWorld;\n#endif\n#endif\n`;\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @internal */\nexport const instancesVertex = { name, shader };\n", "// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore\";\n\nconst name = \"bonesVertex\";\nconst shader = `#ifndef BAKED_VERTEX_ANIMATION_TEXTURE\n#if NUM_BONE_INFLUENCERS>0\nmat4 influence;\n#ifdef BONETEXTURE\ninfluence=readMatrixFromRawSampler(boneSampler,matricesIndices[0])*matricesWeights[0];\n#if NUM_BONE_INFLUENCERS>1\ninfluence+=readMatrixFromRawSampler(boneSampler,matricesIndices[1])*matricesWeights[1];\n#endif\n#if NUM_BONE_INFLUENCERS>2\ninfluence+=readMatrixFromRawSampler(boneSampler,matricesIndices[2])*matricesWeights[2];\n#endif\n#if NUM_BONE_INFLUENCERS>3\ninfluence+=readMatrixFromRawSampler(boneSampler,matricesIndices[3])*matricesWeights[3];\n#endif\n#if NUM_BONE_INFLUENCERS>4\ninfluence+=readMatrixFromRawSampler(boneSampler,matricesIndicesExtra[0])*matricesWeightsExtra[0];\n#endif\n#if NUM_BONE_INFLUENCERS>5\ninfluence+=readMatrixFromRawSampler(boneSampler,matricesIndicesExtra[1])*matricesWeightsExtra[1];\n#endif\n#if NUM_BONE_INFLUENCERS>6\ninfluence+=readMatrixFromRawSampler(boneSampler,matricesIndicesExtra[2])*matricesWeightsExtra[2];\n#endif\n#if NUM_BONE_INFLUENCERS>7\ninfluence+=readMatrixFromRawSampler(boneSampler,matricesIndicesExtra[3])*matricesWeightsExtra[3];\n#endif\n#else\ninfluence=mBones[int(matricesIndices[0])]*matricesWeights[0];\n#if NUM_BONE_INFLUENCERS>1\ninfluence+=mBones[int(matricesIndices[1])]*matricesWeights[1];\n#endif\n#if NUM_BONE_INFLUENCERS>2\ninfluence+=mBones[int(matricesIndices[2])]*matricesWeights[2];\n#endif\n#if NUM_BONE_INFLUENCERS>3\ninfluence+=mBones[int(matricesIndices[3])]*matricesWeights[3];\n#endif\n#if NUM_BONE_INFLUENCERS>4\ninfluence+=mBones[int(matricesIndicesExtra[0])]*matricesWeightsExtra[0];\n#endif\n#if NUM_BONE_INFLUENCERS>5\ninfluence+=mBones[int(matricesIndicesExtra[1])]*matricesWeightsExtra[1];\n#endif\n#if NUM_BONE_INFLUENCERS>6\ninfluence+=mBones[int(matricesIndicesExtra[2])]*matricesWeightsExtra[2];\n#endif\n#if NUM_BONE_INFLUENCERS>7\ninfluence+=mBones[int(matricesIndicesExtra[3])]*matricesWeightsExtra[3];\n#endif\n#endif\nfinalWorld=finalWorld*influence;\n#endif\n#endif\n`;\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @internal */\nexport const bonesVertex = { name, shader };\n", "// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore\";\n\nconst name = \"bakedVertexAnimation\";\nconst shader = `#ifdef BAKED_VERTEX_ANIMATION_TEXTURE\n{\n#ifdef INSTANCES\n#define BVASNAME bakedVertexAnimationSettingsInstanced\n#else\n#define BVASNAME bakedVertexAnimationSettings\n#endif\nfloat VATStartFrame=BVASNAME.x;float VATEndFrame=BVASNAME.y;float VATOffsetFrame=BVASNAME.z;float VATSpeed=BVASNAME.w;float totalFrames=VATEndFrame-VATStartFrame+1.0;float time=bakedVertexAnimationTime*VATSpeed/totalFrames;float frameCorrection=time<1.0 ? 0.0 : 1.0;float numOfFrames=totalFrames-frameCorrection;float VATFrameNum=fract(time)*numOfFrames;VATFrameNum=mod(VATFrameNum+VATOffsetFrame,numOfFrames);VATFrameNum=floor(VATFrameNum);VATFrameNum+=VATStartFrame+frameCorrection;mat4 VATInfluence;VATInfluence=readMatrixFromRawSamplerVAT(bakedVertexAnimationTexture,matricesIndices[0],VATFrameNum)*matricesWeights[0];\n#if NUM_BONE_INFLUENCERS>1\nVATInfluence+=readMatrixFromRawSamplerVAT(bakedVertexAnimationTexture,matricesIndices[1],VATFrameNum)*matricesWeights[1];\n#endif\n#if NUM_BONE_INFLUENCERS>2\nVATInfluence+=readMatrixFromRawSamplerVAT(bakedVertexAnimationTexture,matricesIndices[2],VATFrameNum)*matricesWeights[2];\n#endif\n#if NUM_BONE_INFLUENCERS>3\nVATInfluence+=readMatrixFromRawSamplerVAT(bakedVertexAnimationTexture,matricesIndices[3],VATFrameNum)*matricesWeights[3];\n#endif\n#if NUM_BONE_INFLUENCERS>4\nVATInfluence+=readMatrixFromRawSamplerVAT(bakedVertexAnimationTexture,matricesIndicesExtra[0],VATFrameNum)*matricesWeightsExtra[0];\n#endif\n#if NUM_BONE_INFLUENCERS>5\nVATInfluence+=readMatrixFromRawSamplerVAT(bakedVertexAnimationTexture,matricesIndicesExtra[1],VATFrameNum)*matricesWeightsExtra[1];\n#endif\n#if NUM_BONE_INFLUENCERS>6\nVATInfluence+=readMatrixFromRawSamplerVAT(bakedVertexAnimationTexture,matricesIndicesExtra[2],VATFrameNum)*matricesWeightsExtra[2];\n#endif\n#if NUM_BONE_INFLUENCERS>7\nVATInfluence+=readMatrixFromRawSamplerVAT(bakedVertexAnimationTexture,matricesIndicesExtra[3],VATFrameNum)*matricesWeightsExtra[3];\n#endif\nfinalWorld=finalWorld*VATInfluence;}\n#endif\n`;\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @internal */\nexport const bakedVertexAnimation = { name, shader };\n", "// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore\";\n\nconst name = \"clipPlaneVertex\";\nconst shader = `#ifdef CLIPPLANE\nfClipDistance=dot(worldPos,vClipPlane);\n#endif\n#ifdef CLIPPLANE2\nfClipDistance2=dot(worldPos,vClipPlane2);\n#endif\n#ifdef CLIPPLANE3\nfClipDistance3=dot(worldPos,vClipPlane3);\n#endif\n#ifdef CLIPPLANE4\nfClipDistance4=dot(worldPos,vClipPlane4);\n#endif\n#ifdef CLIPPLANE5\nfClipDistance5=dot(worldPos,vClipPlane5);\n#endif\n#ifdef CLIPPLANE6\nfClipDistance6=dot(worldPos,vClipPlane6);\n#endif\n`;\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @internal */\nexport const clipPlaneVertex = { name, shader };\n", "// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore\";\n\nconst name = \"logDepthVertex\";\nconst shader = `#ifdef LOGARITHMICDEPTH\nvFragmentDepth=1.0+gl_Position.w;gl_Position.z=log2(max(0.000001,vFragmentDepth))*logarithmicDepthConstant;\n#endif\n`;\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @internal */\nexport const logDepthVertex = { name, shader };\n", "// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore\";\n\nconst name = \"fogVertex\";\nconst shader = `#ifdef FOG\nvFogDistance=(view*worldPos).xyz;\n#endif\n`;\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @internal */\nexport const fogVertex = { name, shader };\n", "// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore\";\n\nconst name = \"shadowsVertex\";\nconst shader = `#ifdef SHADOWS\n#if defined(SHADOWCSM{X})\nvPositionFromCamera{X}=view*worldPos;for (int i=0; i<SHADOWCSMNUM_CASCADES{X}; i++) {vPositionFromLight{X}[i]=lightMatrix{X}[i]*worldPos;\n#ifdef USE_REVERSE_DEPTHBUFFER\nvDepthMetric{X}[i]=(-vPositionFromLight{X}[i].z+light{X}.depthValues.x)/light{X}.depthValues.y;\n#else\nvDepthMetric{X}[i]=(vPositionFromLight{X}[i].z+light{X}.depthValues.x)/light{X}.depthValues.y;\n#endif\n}\n#elif defined(SHADOW{X}) && !defined(SHADOWCUBE{X})\nvPositionFromLight{X}=lightMatrix{X}*worldPos;\n#ifdef USE_REVERSE_DEPTHBUFFER\nvDepthMetric{X}=(-vPositionFromLight{X}.z+light{X}.depthValues.x)/light{X}.depthValues.y;\n#else\nvDepthMetric{X}=(vPositionFromLight{X}.z+light{X}.depthValues.x)/light{X}.depthValues.y;\n#endif\n#endif\n#endif\n`;\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @internal */\nexport const shadowsVertex = { name, shader };\n"],
  "mappings": "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",
  "names": ["name", "MaterialPluginEvent", "name", "name", "name", "shader", "name", "shader", "name", "shader", "name", "shader", "name", "shader", "name", "shader", "name", "shader", "name", "shader", "name", "shader", "name", "shader", "name", "shader", "name", "shader", "name", "shader", "name", "shader", "name", "shader", "name", "shader", "name", "shader", "name", "shader", "name", "shader", "name", "shader", "name", "shader", "name", "shader"]
}
