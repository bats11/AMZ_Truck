import {
  BindBonesParameters,
  BindFogParameters,
  BindLights,
  BindLogDepth,
  EffectFallbacks,
  HandleFallbacksForShadows,
  MaterialDefines,
  PrepareAttributesForBones,
  PrepareAttributesForInstances,
  PrepareDefinesForAttributes,
  PrepareDefinesForFrameBoundValues,
  PrepareDefinesForLights,
  PrepareDefinesForMisc,
  PrepareUniformsAndSamplersList,
  PushMaterial,
  addClipPlaneUniforms,
  bindClipPlane
} from "./chunk-ISJAPIQI.js";
import {
  Color3,
  RegisterClass,
  Scene,
  SerializationHelper,
  ShaderStore,
  VertexBuffer
} from "./chunk-73B5PMXK.js";

// node_modules/@babylonjs/materials/shadowOnly/shadowOnly.fragment.js
var name = "shadowOnlyPixelShader";
var shader = `precision highp float;uniform vec4 vEyePosition;uniform float alpha;uniform vec3 shadowColor;varying vec3 vPositionW;
#ifdef NORMAL
varying vec3 vNormalW;
#endif
#include<helperFunctions>
#include<__decl__lightFragment>[0..maxSimultaneousLights]
#include<lightsFragmentFunctions>
#include<shadowsFragmentFunctions>
#include<clipPlaneFragmentDeclaration>
#ifdef LOGARITHMICDEPTH
#extension GL_EXT_frag_depth : enable
#endif
#include<logDepthDeclaration>
#include<fogFragmentDeclaration>
#define CUSTOM_FRAGMENT_DEFINITIONS
void main(void) {
#define CUSTOM_FRAGMENT_MAIN_BEGIN
#include<clipPlaneFragment>
vec3 viewDirectionW=normalize(vEyePosition.xyz-vPositionW);
#ifdef NORMAL
vec3 normalW=normalize(vNormalW);
#else
vec3 normalW=vec3(1.0,1.0,1.0);
#endif
vec3 diffuseBase=vec3(0.,0.,0.);lightingInfo info;float shadow=1.;float glossiness=0.;float aggShadow=0.;float numLights=0.;
#include<lightFragment>[0..1]
vec4 color=vec4(shadowColor,(1.0-clamp(shadow,0.,1.))*alpha);
#include<logDepthFragment>
#include<fogFragment>
gl_FragColor=color;
#include<imageProcessingCompatibility>
#define CUSTOM_FRAGMENT_MAIN_END
}`;
ShaderStore.ShadersStore[name] = shader;

// node_modules/@babylonjs/materials/shadowOnly/shadowOnly.vertex.js
var name2 = "shadowOnlyVertexShader";
var shader2 = `precision highp float;attribute vec3 position;
#ifdef NORMAL
attribute vec3 normal;
#endif
#include<bonesDeclaration>
#include<bakedVertexAnimationDeclaration>
#include<instancesDeclaration>
uniform mat4 view;uniform mat4 viewProjection;
#ifdef POINTSIZE
uniform float pointSize;
#endif
varying vec3 vPositionW;
#ifdef NORMAL
varying vec3 vNormalW;
#endif
#ifdef VERTEXCOLOR
varying vec4 vColor;
#endif
#include<clipPlaneVertexDeclaration>
#include<logDepthDeclaration>
#include<fogVertexDeclaration>
#include<__decl__lightFragment>[0..maxSimultaneousLights]
#define CUSTOM_VERTEX_DEFINITIONS
void main(void) {
#define CUSTOM_VERTEX_MAIN_BEGIN
#include<instancesVertex>
#include<bonesVertex>
#include<bakedVertexAnimation>
vec4 worldPos=finalWorld*vec4(position,1.0);gl_Position=viewProjection*worldPos;vPositionW=vec3(worldPos);
#ifdef NORMAL
vNormalW=normalize(vec3(finalWorld*vec4(normal,0.0)));
#endif
#include<clipPlaneVertex>
#include<logDepthVertex>
#include<fogVertex>
#include<shadowsVertex>[0..maxSimultaneousLights]
#if defined(POINTSIZE) && !defined(WEBGPU)
gl_PointSize=pointSize;
#endif
#define CUSTOM_VERTEX_MAIN_END
}
`;
ShaderStore.ShadersStore[name2] = shader2;

// node_modules/@babylonjs/materials/shadowOnly/shadowOnlyMaterial.js
var ShadowOnlyMaterialDefines = class extends MaterialDefines {
  constructor() {
    super();
    this.CLIPPLANE = false;
    this.CLIPPLANE2 = false;
    this.CLIPPLANE3 = false;
    this.CLIPPLANE4 = false;
    this.CLIPPLANE5 = false;
    this.CLIPPLANE6 = false;
    this.POINTSIZE = false;
    this.FOG = false;
    this.NORMAL = false;
    this.NUM_BONE_INFLUENCERS = 0;
    this.BonesPerMesh = 0;
    this.INSTANCES = false;
    this.IMAGEPROCESSINGPOSTPROCESS = false;
    this.SKIPFINALCOLORCLAMP = false;
    this.LOGARITHMICDEPTH = false;
    this.rebuild();
  }
};
var ShadowOnlyMaterial = class _ShadowOnlyMaterial extends PushMaterial {
  constructor(name3, scene) {
    super(name3, scene);
    this._needAlphaBlending = true;
    this.shadowColor = Color3.Black();
  }
  needAlphaBlending() {
    return this._needAlphaBlending;
  }
  needAlphaTesting() {
    return false;
  }
  getAlphaTestTexture() {
    return null;
  }
  get activeLight() {
    return this._activeLight;
  }
  set activeLight(light) {
    this._activeLight = light;
  }
  _getFirstShadowLightForMesh(mesh) {
    for (const light of mesh.lightSources) {
      if (light.shadowEnabled) {
        return light;
      }
    }
    return null;
  }
  // Methods
  isReadyForSubMesh(mesh, subMesh, useInstances) {
    var _a;
    const drawWrapper = subMesh._drawWrapper;
    if (this.isFrozen) {
      if (drawWrapper.effect && drawWrapper._wasPreviouslyReady && drawWrapper._wasPreviouslyUsingInstances === useInstances) {
        return true;
      }
    }
    if (!subMesh.materialDefines) {
      subMesh.materialDefines = new ShadowOnlyMaterialDefines();
    }
    const defines = subMesh.materialDefines;
    const scene = this.getScene();
    if (this._isReadyForSubMesh(subMesh)) {
      return true;
    }
    const engine = scene.getEngine();
    if (this._activeLight) {
      for (const light of mesh.lightSources) {
        if (light.shadowEnabled) {
          if (this._activeLight === light) {
            break;
          }
          const lightPosition = mesh.lightSources.indexOf(this._activeLight);
          if (lightPosition !== -1) {
            mesh.lightSources.splice(lightPosition, 1);
            mesh.lightSources.splice(0, 0, this._activeLight);
          }
          break;
        }
      }
    }
    PrepareDefinesForFrameBoundValues(scene, engine, this, defines, useInstances ? true : false);
    PrepareDefinesForMisc(mesh, scene, this._useLogarithmicDepth, this.pointsCloud, this.fogEnabled, this._shouldTurnAlphaTestOn(mesh), defines);
    defines._needNormals = PrepareDefinesForLights(scene, mesh, defines, false, 1);
    const shadowGenerator = (_a = this._getFirstShadowLightForMesh(mesh)) == null ? void 0 : _a.getShadowGenerator();
    this._needAlphaBlending = true;
    if (shadowGenerator && shadowGenerator.getClassName && shadowGenerator.getClassName() === "CascadedShadowGenerator") {
      const csg = shadowGenerator;
      this._needAlphaBlending = !csg.autoCalcDepthBounds;
    }
    PrepareDefinesForAttributes(mesh, defines, false, true);
    if (defines.isDirty) {
      defines.markAsProcessed();
      scene.resetCachedMaterial();
      const fallbacks = new EffectFallbacks();
      if (defines.FOG) {
        fallbacks.addFallback(1, "FOG");
      }
      HandleFallbacksForShadows(defines, fallbacks, 1);
      if (defines.NUM_BONE_INFLUENCERS > 0) {
        fallbacks.addCPUSkinningFallback(0, mesh);
      }
      defines.IMAGEPROCESSINGPOSTPROCESS = scene.imageProcessingConfiguration.applyByPostProcess;
      const attribs = [VertexBuffer.PositionKind];
      if (defines.NORMAL) {
        attribs.push(VertexBuffer.NormalKind);
      }
      PrepareAttributesForBones(attribs, mesh, defines, fallbacks);
      PrepareAttributesForInstances(attribs, defines);
      const shaderName = "shadowOnly";
      const join = defines.toString();
      const uniforms = [
        "world",
        "view",
        "viewProjection",
        "vEyePosition",
        "vLightsType",
        "vFogInfos",
        "vFogColor",
        "pointSize",
        "alpha",
        "shadowColor",
        "mBones",
        "logarithmicDepthConstant"
      ];
      const samplers = [];
      const uniformBuffers = [];
      addClipPlaneUniforms(uniforms);
      PrepareUniformsAndSamplersList({
        uniformsNames: uniforms,
        uniformBuffersNames: uniformBuffers,
        samplers,
        defines,
        maxSimultaneousLights: 1
      });
      subMesh.setEffect(scene.getEngine().createEffect(shaderName, {
        attributes: attribs,
        uniformsNames: uniforms,
        uniformBuffersNames: uniformBuffers,
        samplers,
        defines: join,
        fallbacks,
        onCompiled: this.onCompiled,
        onError: this.onError,
        indexParameters: { maxSimultaneousLights: 1 }
      }, engine), defines, this._materialContext);
    }
    if (!subMesh.effect || !subMesh.effect.isReady()) {
      return false;
    }
    defines._renderId = scene.getRenderId();
    drawWrapper._wasPreviouslyReady = true;
    drawWrapper._wasPreviouslyUsingInstances = !!useInstances;
    return true;
  }
  bindForSubMesh(world, mesh, subMesh) {
    const scene = this.getScene();
    const defines = subMesh.materialDefines;
    if (!defines) {
      return;
    }
    const effect = subMesh.effect;
    if (!effect) {
      return;
    }
    this._activeEffect = effect;
    this.bindOnlyWorldMatrix(world);
    this._activeEffect.setMatrix("viewProjection", scene.getTransformMatrix());
    BindBonesParameters(mesh, this._activeEffect);
    if (this._mustRebind(scene, effect, subMesh)) {
      bindClipPlane(effect, this, scene);
      if (this.pointsCloud) {
        this._activeEffect.setFloat("pointSize", this.pointSize);
      }
      this._activeEffect.setFloat("alpha", this.alpha);
      this._activeEffect.setColor3("shadowColor", this.shadowColor);
      if (this._useLogarithmicDepth) {
        BindLogDepth(defines, effect, scene);
      }
      scene.bindEyePosition(effect);
    }
    if (scene.lightsEnabled) {
      BindLights(scene, mesh, this._activeEffect, defines, 1);
      const light = this._getFirstShadowLightForMesh(mesh);
      if (light) {
        light._renderId = -1;
      }
    }
    if (scene.fogEnabled && mesh.applyFog && scene.fogMode !== Scene.FOGMODE_NONE || defines["SHADOWCSM0"]) {
      this._activeEffect.setMatrix("view", scene.getViewMatrix());
    }
    BindFogParameters(scene, mesh, this._activeEffect);
    this._afterBind(mesh, this._activeEffect, subMesh);
  }
  clone(name3) {
    return SerializationHelper.Clone(() => new _ShadowOnlyMaterial(name3, this.getScene()), this);
  }
  serialize() {
    const serializationObject = super.serialize();
    serializationObject.customType = "BABYLON.ShadowOnlyMaterial";
    return serializationObject;
  }
  getClassName() {
    return "ShadowOnlyMaterial";
  }
  // Statics
  static Parse(source, scene, rootUrl) {
    return SerializationHelper.Parse(() => new _ShadowOnlyMaterial(source.name, scene), source, scene, rootUrl);
  }
};
RegisterClass("BABYLON.ShadowOnlyMaterial", ShadowOnlyMaterial);

export {
  ShadowOnlyMaterial
};
//# sourceMappingURL=chunk-ODEKFHW2.js.map
