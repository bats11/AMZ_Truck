import {
  AutoReleaseWorkerPool,
  GetEnvInfo,
  UploadEnvLevelsAsync,
  UploadEnvSpherical
} from "./chunk-HG2GYB4D.js";
import {
  BaseTexture,
  CubeMapToSphericalPolynomialTools,
  Engine,
  FromHalfFloat,
  SphericalPolynomial,
  Texture,
  ToHalfFloat
} from "./chunk-NMVAUVZO.js";
import {
  InternalTexture,
  InternalTextureSource,
  Logger,
  Scalar,
  ThinEngine,
  Tools,
  Vector3
} from "./chunk-73B5PMXK.js";

// node_modules/@babylonjs/core/Misc/dds.js
var DDS_MAGIC = 542327876;
var DDSD_MIPMAPCOUNT = 131072;
var DDSCAPS2_CUBEMAP = 512;
var DDPF_FOURCC = 4;
var DDPF_RGB = 64;
var DDPF_LUMINANCE = 131072;
function FourCCToInt32(value) {
  return value.charCodeAt(0) + (value.charCodeAt(1) << 8) + (value.charCodeAt(2) << 16) + (value.charCodeAt(3) << 24);
}
function Int32ToFourCC(value) {
  return String.fromCharCode(value & 255, value >> 8 & 255, value >> 16 & 255, value >> 24 & 255);
}
var FOURCC_DXT1 = FourCCToInt32("DXT1");
var FOURCC_DXT3 = FourCCToInt32("DXT3");
var FOURCC_DXT5 = FourCCToInt32("DXT5");
var FOURCC_DX10 = FourCCToInt32("DX10");
var FOURCC_D3DFMT_R16G16B16A16F = 113;
var FOURCC_D3DFMT_R32G32B32A32F = 116;
var DXGI_FORMAT_R32G32B32A32_FLOAT = 2;
var DXGI_FORMAT_R16G16B16A16_FLOAT = 10;
var DXGI_FORMAT_B8G8R8X8_UNORM = 88;
var headerLengthInt = 31;
var off_magic = 0;
var off_size = 1;
var off_flags = 2;
var off_height = 3;
var off_width = 4;
var off_mipmapCount = 7;
var off_pfFlags = 20;
var off_pfFourCC = 21;
var off_RGBbpp = 22;
var off_RMask = 23;
var off_GMask = 24;
var off_BMask = 25;
var off_AMask = 26;
var off_caps2 = 28;
var off_dxgiFormat = 32;
var DDSTools = class _DDSTools {
  /**
   * Gets DDS information from an array buffer
   * @param data defines the array buffer view to read data from
   * @returns the DDS information
   */
  static GetDDSInfo(data) {
    const header = new Int32Array(data.buffer, data.byteOffset, headerLengthInt);
    const extendedHeader = new Int32Array(data.buffer, data.byteOffset, headerLengthInt + 4);
    let mipmapCount = 1;
    if (header[off_flags] & DDSD_MIPMAPCOUNT) {
      mipmapCount = Math.max(1, header[off_mipmapCount]);
    }
    const fourCC = header[off_pfFourCC];
    const dxgiFormat = fourCC === FOURCC_DX10 ? extendedHeader[off_dxgiFormat] : 0;
    let textureType = 0;
    switch (fourCC) {
      case FOURCC_D3DFMT_R16G16B16A16F:
        textureType = 2;
        break;
      case FOURCC_D3DFMT_R32G32B32A32F:
        textureType = 1;
        break;
      case FOURCC_DX10:
        if (dxgiFormat === DXGI_FORMAT_R16G16B16A16_FLOAT) {
          textureType = 2;
          break;
        }
        if (dxgiFormat === DXGI_FORMAT_R32G32B32A32_FLOAT) {
          textureType = 1;
          break;
        }
    }
    return {
      width: header[off_width],
      height: header[off_height],
      mipmapCount,
      isFourCC: (header[off_pfFlags] & DDPF_FOURCC) === DDPF_FOURCC,
      isRGB: (header[off_pfFlags] & DDPF_RGB) === DDPF_RGB,
      isLuminance: (header[off_pfFlags] & DDPF_LUMINANCE) === DDPF_LUMINANCE,
      isCube: (header[off_caps2] & DDSCAPS2_CUBEMAP) === DDSCAPS2_CUBEMAP,
      isCompressed: fourCC === FOURCC_DXT1 || fourCC === FOURCC_DXT3 || fourCC === FOURCC_DXT5,
      dxgiFormat,
      textureType
    };
  }
  static _GetHalfFloatAsFloatRGBAArrayBuffer(width, height, dataOffset, dataLength, arrayBuffer, lod) {
    const destArray = new Float32Array(dataLength);
    const srcData = new Uint16Array(arrayBuffer, dataOffset);
    let index = 0;
    for (let y = 0; y < height; y++) {
      for (let x = 0; x < width; x++) {
        const srcPos = (x + y * width) * 4;
        destArray[index] = FromHalfFloat(srcData[srcPos]);
        destArray[index + 1] = FromHalfFloat(srcData[srcPos + 1]);
        destArray[index + 2] = FromHalfFloat(srcData[srcPos + 2]);
        if (_DDSTools.StoreLODInAlphaChannel) {
          destArray[index + 3] = lod;
        } else {
          destArray[index + 3] = FromHalfFloat(srcData[srcPos + 3]);
        }
        index += 4;
      }
    }
    return destArray;
  }
  static _GetHalfFloatRGBAArrayBuffer(width, height, dataOffset, dataLength, arrayBuffer, lod) {
    if (_DDSTools.StoreLODInAlphaChannel) {
      const destArray = new Uint16Array(dataLength);
      const srcData = new Uint16Array(arrayBuffer, dataOffset);
      let index = 0;
      for (let y = 0; y < height; y++) {
        for (let x = 0; x < width; x++) {
          const srcPos = (x + y * width) * 4;
          destArray[index] = srcData[srcPos];
          destArray[index + 1] = srcData[srcPos + 1];
          destArray[index + 2] = srcData[srcPos + 2];
          destArray[index + 3] = ToHalfFloat(lod);
          index += 4;
        }
      }
      return destArray;
    }
    return new Uint16Array(arrayBuffer, dataOffset, dataLength);
  }
  static _GetFloatRGBAArrayBuffer(width, height, dataOffset, dataLength, arrayBuffer, lod) {
    if (_DDSTools.StoreLODInAlphaChannel) {
      const destArray = new Float32Array(dataLength);
      const srcData = new Float32Array(arrayBuffer, dataOffset);
      let index = 0;
      for (let y = 0; y < height; y++) {
        for (let x = 0; x < width; x++) {
          const srcPos = (x + y * width) * 4;
          destArray[index] = srcData[srcPos];
          destArray[index + 1] = srcData[srcPos + 1];
          destArray[index + 2] = srcData[srcPos + 2];
          destArray[index + 3] = lod;
          index += 4;
        }
      }
      return destArray;
    }
    return new Float32Array(arrayBuffer, dataOffset, dataLength);
  }
  static _GetFloatAsHalfFloatRGBAArrayBuffer(width, height, dataOffset, dataLength, arrayBuffer, lod) {
    const destArray = new Uint16Array(dataLength);
    const srcData = new Float32Array(arrayBuffer, dataOffset);
    let index = 0;
    for (let y = 0; y < height; y++) {
      for (let x = 0; x < width; x++) {
        destArray[index] = ToHalfFloat(srcData[index]);
        destArray[index + 1] = ToHalfFloat(srcData[index + 1]);
        destArray[index + 2] = ToHalfFloat(srcData[index + 2]);
        if (_DDSTools.StoreLODInAlphaChannel) {
          destArray[index + 3] = ToHalfFloat(lod);
        } else {
          destArray[index + 3] = ToHalfFloat(srcData[index + 3]);
        }
        index += 4;
      }
    }
    return destArray;
  }
  static _GetFloatAsUIntRGBAArrayBuffer(width, height, dataOffset, dataLength, arrayBuffer, lod) {
    const destArray = new Uint8Array(dataLength);
    const srcData = new Float32Array(arrayBuffer, dataOffset);
    let index = 0;
    for (let y = 0; y < height; y++) {
      for (let x = 0; x < width; x++) {
        const srcPos = (x + y * width) * 4;
        destArray[index] = Scalar.Clamp(srcData[srcPos]) * 255;
        destArray[index + 1] = Scalar.Clamp(srcData[srcPos + 1]) * 255;
        destArray[index + 2] = Scalar.Clamp(srcData[srcPos + 2]) * 255;
        if (_DDSTools.StoreLODInAlphaChannel) {
          destArray[index + 3] = lod;
        } else {
          destArray[index + 3] = Scalar.Clamp(srcData[srcPos + 3]) * 255;
        }
        index += 4;
      }
    }
    return destArray;
  }
  static _GetHalfFloatAsUIntRGBAArrayBuffer(width, height, dataOffset, dataLength, arrayBuffer, lod) {
    const destArray = new Uint8Array(dataLength);
    const srcData = new Uint16Array(arrayBuffer, dataOffset);
    let index = 0;
    for (let y = 0; y < height; y++) {
      for (let x = 0; x < width; x++) {
        const srcPos = (x + y * width) * 4;
        destArray[index] = Scalar.Clamp(FromHalfFloat(srcData[srcPos])) * 255;
        destArray[index + 1] = Scalar.Clamp(FromHalfFloat(srcData[srcPos + 1])) * 255;
        destArray[index + 2] = Scalar.Clamp(FromHalfFloat(srcData[srcPos + 2])) * 255;
        if (_DDSTools.StoreLODInAlphaChannel) {
          destArray[index + 3] = lod;
        } else {
          destArray[index + 3] = Scalar.Clamp(FromHalfFloat(srcData[srcPos + 3])) * 255;
        }
        index += 4;
      }
    }
    return destArray;
  }
  static _GetRGBAArrayBuffer(width, height, dataOffset, dataLength, arrayBuffer, rOffset, gOffset, bOffset, aOffset) {
    const byteArray = new Uint8Array(dataLength);
    const srcData = new Uint8Array(arrayBuffer, dataOffset);
    let index = 0;
    for (let y = 0; y < height; y++) {
      for (let x = 0; x < width; x++) {
        const srcPos = (x + y * width) * 4;
        byteArray[index] = srcData[srcPos + rOffset];
        byteArray[index + 1] = srcData[srcPos + gOffset];
        byteArray[index + 2] = srcData[srcPos + bOffset];
        byteArray[index + 3] = srcData[srcPos + aOffset];
        index += 4;
      }
    }
    return byteArray;
  }
  static _ExtractLongWordOrder(value) {
    if (value === 0 || value === 255 || value === -16777216) {
      return 0;
    }
    return 1 + _DDSTools._ExtractLongWordOrder(value >> 8);
  }
  static _GetRGBArrayBuffer(width, height, dataOffset, dataLength, arrayBuffer, rOffset, gOffset, bOffset) {
    const byteArray = new Uint8Array(dataLength);
    const srcData = new Uint8Array(arrayBuffer, dataOffset);
    let index = 0;
    for (let y = 0; y < height; y++) {
      for (let x = 0; x < width; x++) {
        const srcPos = (x + y * width) * 3;
        byteArray[index] = srcData[srcPos + rOffset];
        byteArray[index + 1] = srcData[srcPos + gOffset];
        byteArray[index + 2] = srcData[srcPos + bOffset];
        index += 3;
      }
    }
    return byteArray;
  }
  static _GetLuminanceArrayBuffer(width, height, dataOffset, dataLength, arrayBuffer) {
    const byteArray = new Uint8Array(dataLength);
    const srcData = new Uint8Array(arrayBuffer, dataOffset);
    let index = 0;
    for (let y = 0; y < height; y++) {
      for (let x = 0; x < width; x++) {
        const srcPos = x + y * width;
        byteArray[index] = srcData[srcPos];
        index++;
      }
    }
    return byteArray;
  }
  /**
   * Uploads DDS Levels to a Babylon Texture
   * @internal
   */
  static UploadDDSLevels(engine, texture, data, info, loadMipmaps, faces, lodIndex = -1, currentFace, destTypeMustBeFilterable = true) {
    let sphericalPolynomialFaces = null;
    if (info.sphericalPolynomial) {
      sphericalPolynomialFaces = [];
    }
    const ext = !!engine.getCaps().s3tc;
    texture.generateMipMaps = loadMipmaps;
    const header = new Int32Array(data.buffer, data.byteOffset, headerLengthInt);
    let fourCC, width, height, dataLength = 0, dataOffset;
    let byteArray, mipmapCount, mip;
    let internalCompressedFormat = 0;
    let blockBytes = 1;
    if (header[off_magic] !== DDS_MAGIC) {
      Logger.Error("Invalid magic number in DDS header");
      return;
    }
    if (!info.isFourCC && !info.isRGB && !info.isLuminance) {
      Logger.Error("Unsupported format, must contain a FourCC, RGB or LUMINANCE code");
      return;
    }
    if (info.isCompressed && !ext) {
      Logger.Error("Compressed textures are not supported on this platform.");
      return;
    }
    let bpp = header[off_RGBbpp];
    dataOffset = header[off_size] + 4;
    let computeFormats = false;
    if (info.isFourCC) {
      fourCC = header[off_pfFourCC];
      switch (fourCC) {
        case FOURCC_DXT1:
          blockBytes = 8;
          internalCompressedFormat = 33777;
          break;
        case FOURCC_DXT3:
          blockBytes = 16;
          internalCompressedFormat = 33778;
          break;
        case FOURCC_DXT5:
          blockBytes = 16;
          internalCompressedFormat = 33779;
          break;
        case FOURCC_D3DFMT_R16G16B16A16F:
          computeFormats = true;
          bpp = 64;
          break;
        case FOURCC_D3DFMT_R32G32B32A32F:
          computeFormats = true;
          bpp = 128;
          break;
        case FOURCC_DX10: {
          dataOffset += 5 * 4;
          let supported = false;
          switch (info.dxgiFormat) {
            case DXGI_FORMAT_R16G16B16A16_FLOAT:
              computeFormats = true;
              bpp = 64;
              supported = true;
              break;
            case DXGI_FORMAT_R32G32B32A32_FLOAT:
              computeFormats = true;
              bpp = 128;
              supported = true;
              break;
            case DXGI_FORMAT_B8G8R8X8_UNORM:
              info.isRGB = true;
              info.isFourCC = false;
              bpp = 32;
              supported = true;
              break;
          }
          if (supported) {
            break;
          }
        }
        default:
          Logger.Error(["Unsupported FourCC code:", Int32ToFourCC(fourCC)]);
          return;
      }
    }
    const rOffset = _DDSTools._ExtractLongWordOrder(header[off_RMask]);
    const gOffset = _DDSTools._ExtractLongWordOrder(header[off_GMask]);
    const bOffset = _DDSTools._ExtractLongWordOrder(header[off_BMask]);
    const aOffset = _DDSTools._ExtractLongWordOrder(header[off_AMask]);
    if (computeFormats) {
      internalCompressedFormat = engine._getRGBABufferInternalSizedFormat(info.textureType);
    }
    mipmapCount = 1;
    if (header[off_flags] & DDSD_MIPMAPCOUNT && loadMipmaps !== false) {
      mipmapCount = Math.max(1, header[off_mipmapCount]);
    }
    const startFace = currentFace || 0;
    const caps = engine.getCaps();
    for (let face = startFace; face < faces; face++) {
      width = header[off_width];
      height = header[off_height];
      for (mip = 0; mip < mipmapCount; ++mip) {
        if (lodIndex === -1 || lodIndex === mip) {
          const i = lodIndex === -1 ? mip : 0;
          if (!info.isCompressed && info.isFourCC) {
            texture.format = 5;
            dataLength = width * height * 4;
            let floatArray = null;
            if (engine._badOS || engine._badDesktopOS || !caps.textureHalfFloat && !caps.textureFloat) {
              if (bpp === 128) {
                floatArray = _DDSTools._GetFloatAsUIntRGBAArrayBuffer(width, height, data.byteOffset + dataOffset, dataLength, data.buffer, i);
                if (sphericalPolynomialFaces && i == 0) {
                  sphericalPolynomialFaces.push(_DDSTools._GetFloatRGBAArrayBuffer(width, height, data.byteOffset + dataOffset, dataLength, data.buffer, i));
                }
              } else if (bpp === 64) {
                floatArray = _DDSTools._GetHalfFloatAsUIntRGBAArrayBuffer(width, height, data.byteOffset + dataOffset, dataLength, data.buffer, i);
                if (sphericalPolynomialFaces && i == 0) {
                  sphericalPolynomialFaces.push(_DDSTools._GetHalfFloatAsFloatRGBAArrayBuffer(width, height, data.byteOffset + dataOffset, dataLength, data.buffer, i));
                }
              }
              texture.type = 0;
            } else {
              const floatAvailable = caps.textureFloat && (destTypeMustBeFilterable && caps.textureFloatLinearFiltering || !destTypeMustBeFilterable);
              const halfFloatAvailable = caps.textureHalfFloat && (destTypeMustBeFilterable && caps.textureHalfFloatLinearFiltering || !destTypeMustBeFilterable);
              const destType = (bpp === 128 || bpp === 64 && !halfFloatAvailable) && floatAvailable ? 1 : (bpp === 64 || bpp === 128 && !floatAvailable) && halfFloatAvailable ? 2 : 0;
              let dataGetter;
              let dataGetterPolynomial = null;
              switch (bpp) {
                case 128: {
                  switch (destType) {
                    case 1:
                      dataGetter = _DDSTools._GetFloatRGBAArrayBuffer;
                      dataGetterPolynomial = null;
                      break;
                    case 2:
                      dataGetter = _DDSTools._GetFloatAsHalfFloatRGBAArrayBuffer;
                      dataGetterPolynomial = _DDSTools._GetFloatRGBAArrayBuffer;
                      break;
                    case 0:
                      dataGetter = _DDSTools._GetFloatAsUIntRGBAArrayBuffer;
                      dataGetterPolynomial = _DDSTools._GetFloatRGBAArrayBuffer;
                      break;
                  }
                  break;
                }
                default: {
                  switch (destType) {
                    case 1:
                      dataGetter = _DDSTools._GetHalfFloatAsFloatRGBAArrayBuffer;
                      dataGetterPolynomial = null;
                      break;
                    case 2:
                      dataGetter = _DDSTools._GetHalfFloatRGBAArrayBuffer;
                      dataGetterPolynomial = _DDSTools._GetHalfFloatAsFloatRGBAArrayBuffer;
                      break;
                    case 0:
                      dataGetter = _DDSTools._GetHalfFloatAsUIntRGBAArrayBuffer;
                      dataGetterPolynomial = _DDSTools._GetHalfFloatAsFloatRGBAArrayBuffer;
                      break;
                  }
                  break;
                }
              }
              texture.type = destType;
              floatArray = dataGetter(width, height, data.byteOffset + dataOffset, dataLength, data.buffer, i);
              if (sphericalPolynomialFaces && i == 0) {
                sphericalPolynomialFaces.push(dataGetterPolynomial ? dataGetterPolynomial(width, height, data.byteOffset + dataOffset, dataLength, data.buffer, i) : floatArray);
              }
            }
            if (floatArray) {
              engine._uploadDataToTextureDirectly(texture, floatArray, face, i);
            }
          } else if (info.isRGB) {
            texture.type = 0;
            if (bpp === 24) {
              texture.format = 4;
              dataLength = width * height * 3;
              byteArray = _DDSTools._GetRGBArrayBuffer(width, height, data.byteOffset + dataOffset, dataLength, data.buffer, rOffset, gOffset, bOffset);
              engine._uploadDataToTextureDirectly(texture, byteArray, face, i);
            } else {
              texture.format = 5;
              dataLength = width * height * 4;
              byteArray = _DDSTools._GetRGBAArrayBuffer(width, height, data.byteOffset + dataOffset, dataLength, data.buffer, rOffset, gOffset, bOffset, aOffset);
              engine._uploadDataToTextureDirectly(texture, byteArray, face, i);
            }
          } else if (info.isLuminance) {
            const unpackAlignment = engine._getUnpackAlignement();
            const unpaddedRowSize = width;
            const paddedRowSize = Math.floor((width + unpackAlignment - 1) / unpackAlignment) * unpackAlignment;
            dataLength = paddedRowSize * (height - 1) + unpaddedRowSize;
            byteArray = _DDSTools._GetLuminanceArrayBuffer(width, height, data.byteOffset + dataOffset, dataLength, data.buffer);
            texture.format = 1;
            texture.type = 0;
            engine._uploadDataToTextureDirectly(texture, byteArray, face, i);
          } else {
            dataLength = Math.max(4, width) / 4 * Math.max(4, height) / 4 * blockBytes;
            byteArray = new Uint8Array(data.buffer, data.byteOffset + dataOffset, dataLength);
            texture.type = 0;
            engine._uploadCompressedDataToTextureDirectly(texture, internalCompressedFormat, width, height, byteArray, face, i);
          }
        }
        dataOffset += bpp ? width * height * (bpp / 8) : dataLength;
        width *= 0.5;
        height *= 0.5;
        width = Math.max(1, width);
        height = Math.max(1, height);
      }
      if (currentFace !== void 0) {
        break;
      }
    }
    if (sphericalPolynomialFaces && sphericalPolynomialFaces.length > 0) {
      info.sphericalPolynomial = CubeMapToSphericalPolynomialTools.ConvertCubeMapToSphericalPolynomial({
        size: header[off_width],
        right: sphericalPolynomialFaces[0],
        left: sphericalPolynomialFaces[1],
        up: sphericalPolynomialFaces[2],
        down: sphericalPolynomialFaces[3],
        front: sphericalPolynomialFaces[4],
        back: sphericalPolynomialFaces[5],
        format: 5,
        type: 1,
        gammaSpace: false
      });
    } else {
      info.sphericalPolynomial = void 0;
    }
  }
};
DDSTools.StoreLODInAlphaChannel = false;
ThinEngine.prototype.createPrefilteredCubeTexture = function(rootUrl, scene, lodScale, lodOffset, onLoad = null, onError = null, format, forcedExtension = null, createPolynomials = true) {
  const callback = (loadData) => {
    if (!loadData) {
      if (onLoad) {
        onLoad(null);
      }
      return;
    }
    const texture = loadData.texture;
    if (!createPolynomials) {
      texture._sphericalPolynomial = new SphericalPolynomial();
    } else if (loadData.info.sphericalPolynomial) {
      texture._sphericalPolynomial = loadData.info.sphericalPolynomial;
    }
    texture._source = InternalTextureSource.CubePrefiltered;
    if (this.getCaps().textureLOD) {
      if (onLoad) {
        onLoad(texture);
      }
      return;
    }
    const mipSlices = 3;
    const gl = this._gl;
    const width = loadData.width;
    if (!width) {
      return;
    }
    const textures = [];
    for (let i = 0; i < mipSlices; i++) {
      const smoothness = i / (mipSlices - 1);
      const roughness = 1 - smoothness;
      const minLODIndex = lodOffset;
      const maxLODIndex = Scalar.Log2(width) * lodScale + lodOffset;
      const lodIndex = minLODIndex + (maxLODIndex - minLODIndex) * roughness;
      const mipmapIndex = Math.round(Math.min(Math.max(lodIndex, 0), maxLODIndex));
      const glTextureFromLod = new InternalTexture(this, InternalTextureSource.Temp);
      glTextureFromLod.type = texture.type;
      glTextureFromLod.format = texture.format;
      glTextureFromLod.width = Math.pow(2, Math.max(Scalar.Log2(width) - mipmapIndex, 0));
      glTextureFromLod.height = glTextureFromLod.width;
      glTextureFromLod.isCube = true;
      glTextureFromLod._cachedWrapU = 0;
      glTextureFromLod._cachedWrapV = 0;
      this._bindTextureDirectly(gl.TEXTURE_CUBE_MAP, glTextureFromLod, true);
      glTextureFromLod.samplingMode = 2;
      gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
      gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
      gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
      gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
      if (loadData.isDDS) {
        const info = loadData.info;
        const data = loadData.data;
        this._unpackFlipY(info.isCompressed);
        DDSTools.UploadDDSLevels(this, glTextureFromLod, data, info, true, 6, mipmapIndex);
      } else {
        Logger.Warn("DDS is the only prefiltered cube map supported so far.");
      }
      this._bindTextureDirectly(gl.TEXTURE_CUBE_MAP, null);
      const lodTexture = new BaseTexture(scene);
      lodTexture._isCube = true;
      lodTexture._texture = glTextureFromLod;
      glTextureFromLod.isReady = true;
      textures.push(lodTexture);
    }
    texture._lodTextureHigh = textures[2];
    texture._lodTextureMid = textures[1];
    texture._lodTextureLow = textures[0];
    if (onLoad) {
      onLoad(texture);
    }
  };
  return this.createCubeTexture(rootUrl, scene, null, false, callback, onError, format, forcedExtension, createPolynomials, lodScale, lodOffset);
};

// node_modules/@babylonjs/core/Materials/Textures/Loaders/ddsTextureLoader.js
var _DDSTextureLoader = class {
  constructor() {
    this.supportCascades = true;
  }
  /**
   * This returns if the loader support the current file information.
   * @param extension defines the file extension of the file being loaded
   * @returns true if the loader can load the specified file
   */
  canLoad(extension) {
    return extension.endsWith(".dds");
  }
  /**
   * Uploads the cube texture data to the WebGL texture. It has already been bound.
   * @param imgs contains the cube maps
   * @param texture defines the BabylonJS internal texture
   * @param createPolynomials will be true if polynomials have been requested
   * @param onLoad defines the callback to trigger once the texture is ready
   */
  loadCubeData(imgs, texture, createPolynomials, onLoad) {
    const engine = texture.getEngine();
    let info;
    let loadMipmap = false;
    let maxLevel = 1e3;
    if (Array.isArray(imgs)) {
      for (let index = 0; index < imgs.length; index++) {
        const data = imgs[index];
        info = DDSTools.GetDDSInfo(data);
        texture.width = info.width;
        texture.height = info.height;
        loadMipmap = (info.isRGB || info.isLuminance || info.mipmapCount > 1) && texture.generateMipMaps;
        engine._unpackFlipY(info.isCompressed);
        DDSTools.UploadDDSLevels(engine, texture, data, info, loadMipmap, 6, -1, index);
        if (!info.isFourCC && info.mipmapCount === 1) {
          engine.generateMipMapsForCubemap(texture);
        } else {
          maxLevel = info.mipmapCount - 1;
        }
      }
    } else {
      const data = imgs;
      info = DDSTools.GetDDSInfo(data);
      texture.width = info.width;
      texture.height = info.height;
      if (createPolynomials) {
        info.sphericalPolynomial = new SphericalPolynomial();
      }
      loadMipmap = (info.isRGB || info.isLuminance || info.mipmapCount > 1) && texture.generateMipMaps;
      engine._unpackFlipY(info.isCompressed);
      DDSTools.UploadDDSLevels(engine, texture, data, info, loadMipmap, 6);
      if (!info.isFourCC && info.mipmapCount === 1) {
        engine.generateMipMapsForCubemap(texture, false);
      } else {
        maxLevel = info.mipmapCount - 1;
      }
    }
    engine._setCubeMapTextureParams(texture, loadMipmap, maxLevel);
    texture.isReady = true;
    texture.onLoadedObservable.notifyObservers(texture);
    texture.onLoadedObservable.clear();
    if (onLoad) {
      onLoad({ isDDS: true, width: texture.width, info, data: imgs, texture });
    }
  }
  /**
   * Uploads the 2D texture data to the WebGL texture. It has already been bound once in the callback.
   * @param data contains the texture data
   * @param texture defines the BabylonJS internal texture
   * @param callback defines the method to call once ready to upload
   */
  loadData(data, texture, callback) {
    const info = DDSTools.GetDDSInfo(data);
    const loadMipmap = (info.isRGB || info.isLuminance || info.mipmapCount > 1) && texture.generateMipMaps && info.width >> info.mipmapCount - 1 === 1;
    callback(info.width, info.height, loadMipmap, info.isFourCC, () => {
      DDSTools.UploadDDSLevels(texture.getEngine(), texture, data, info, loadMipmap, 1);
    });
  }
};
Engine._TextureLoaders.push(new _DDSTextureLoader());

// node_modules/@babylonjs/core/Materials/Textures/Loaders/envTextureLoader.js
var _ENVTextureLoader = class {
  constructor() {
    this.supportCascades = false;
  }
  /**
   * This returns if the loader support the current file information.
   * @param extension defines the file extension of the file being loaded
   * @returns true if the loader can load the specified file
   */
  canLoad(extension) {
    return extension.endsWith(".env");
  }
  /**
   * Uploads the cube texture data to the WebGL texture. It has already been bound.
   * @param data contains the texture data
   * @param texture defines the BabylonJS internal texture
   * @param createPolynomials will be true if polynomials have been requested
   * @param onLoad defines the callback to trigger once the texture is ready
   * @param onError defines the callback to trigger in case of error
   */
  loadCubeData(data, texture, createPolynomials, onLoad, onError) {
    if (Array.isArray(data)) {
      return;
    }
    const info = GetEnvInfo(data);
    if (info) {
      texture.width = info.width;
      texture.height = info.width;
      try {
        UploadEnvSpherical(texture, info);
        UploadEnvLevelsAsync(texture, data, info).then(() => {
          texture.isReady = true;
          texture.onLoadedObservable.notifyObservers(texture);
          texture.onLoadedObservable.clear();
          if (onLoad) {
            onLoad();
          }
        }, (reason) => {
          onError == null ? void 0 : onError("Can not upload environment levels", reason);
        });
      } catch (e) {
        onError == null ? void 0 : onError("Can not upload environment file", e);
      }
    } else if (onError) {
      onError("Can not parse the environment file", null);
    }
  }
  /**
   * Uploads the 2D texture data to the WebGL texture. It has already been bound once in the callback.
   */
  loadData() {
    throw ".env not supported in 2d.";
  }
};
Engine._TextureLoaders.push(new _ENVTextureLoader());

// node_modules/@babylonjs/core/Misc/khronosTextureContainer.js
var KhronosTextureContainer = class _KhronosTextureContainer {
  /**
   * Creates a new KhronosTextureContainer
   * @param data contents of the KTX container file
   * @param facesExpected should be either 1 or 6, based whether a cube texture or or
   */
  constructor(data, facesExpected) {
    this.data = data;
    this.isInvalid = false;
    if (!_KhronosTextureContainer.IsValid(data)) {
      this.isInvalid = true;
      Logger.Error("texture missing KTX identifier");
      return;
    }
    const dataSize = Uint32Array.BYTES_PER_ELEMENT;
    const headerDataView = new DataView(this.data.buffer, this.data.byteOffset + 12, 13 * dataSize);
    const endianness = headerDataView.getUint32(0, true);
    const littleEndian = endianness === 67305985;
    this.glType = headerDataView.getUint32(1 * dataSize, littleEndian);
    this.glTypeSize = headerDataView.getUint32(2 * dataSize, littleEndian);
    this.glFormat = headerDataView.getUint32(3 * dataSize, littleEndian);
    this.glInternalFormat = headerDataView.getUint32(4 * dataSize, littleEndian);
    this.glBaseInternalFormat = headerDataView.getUint32(5 * dataSize, littleEndian);
    this.pixelWidth = headerDataView.getUint32(6 * dataSize, littleEndian);
    this.pixelHeight = headerDataView.getUint32(7 * dataSize, littleEndian);
    this.pixelDepth = headerDataView.getUint32(8 * dataSize, littleEndian);
    this.numberOfArrayElements = headerDataView.getUint32(9 * dataSize, littleEndian);
    this.numberOfFaces = headerDataView.getUint32(10 * dataSize, littleEndian);
    this.numberOfMipmapLevels = headerDataView.getUint32(11 * dataSize, littleEndian);
    this.bytesOfKeyValueData = headerDataView.getUint32(12 * dataSize, littleEndian);
    if (this.glType !== 0) {
      Logger.Error("only compressed formats currently supported");
      this.isInvalid = true;
      return;
    } else {
      this.numberOfMipmapLevels = Math.max(1, this.numberOfMipmapLevels);
    }
    if (this.pixelHeight === 0 || this.pixelDepth !== 0) {
      Logger.Error("only 2D textures currently supported");
      this.isInvalid = true;
      return;
    }
    if (this.numberOfArrayElements !== 0) {
      Logger.Error("texture arrays not currently supported");
      this.isInvalid = true;
      return;
    }
    if (this.numberOfFaces !== facesExpected) {
      Logger.Error("number of faces expected" + facesExpected + ", but found " + this.numberOfFaces);
      this.isInvalid = true;
      return;
    }
    this.loadType = _KhronosTextureContainer.COMPRESSED_2D;
  }
  /**
   * Uploads KTX content to a Babylon Texture.
   * It is assumed that the texture has already been created & is currently bound
   * @internal
   */
  uploadLevels(texture, loadMipmaps) {
    switch (this.loadType) {
      case _KhronosTextureContainer.COMPRESSED_2D:
        this._upload2DCompressedLevels(texture, loadMipmaps);
        break;
      case _KhronosTextureContainer.TEX_2D:
      case _KhronosTextureContainer.COMPRESSED_3D:
      case _KhronosTextureContainer.TEX_3D:
    }
  }
  _upload2DCompressedLevels(texture, loadMipmaps) {
    let dataOffset = _KhronosTextureContainer.HEADER_LEN + this.bytesOfKeyValueData;
    let width = this.pixelWidth;
    let height = this.pixelHeight;
    const mipmapCount = loadMipmaps ? this.numberOfMipmapLevels : 1;
    for (let level = 0; level < mipmapCount; level++) {
      const imageSize = new Int32Array(this.data.buffer, this.data.byteOffset + dataOffset, 1)[0];
      dataOffset += 4;
      for (let face = 0; face < this.numberOfFaces; face++) {
        const byteArray = new Uint8Array(this.data.buffer, this.data.byteOffset + dataOffset, imageSize);
        const engine = texture.getEngine();
        engine._uploadCompressedDataToTextureDirectly(texture, texture.format, width, height, byteArray, face, level);
        dataOffset += imageSize;
        dataOffset += 3 - (imageSize + 3) % 4;
      }
      width = Math.max(1, width * 0.5);
      height = Math.max(1, height * 0.5);
    }
  }
  /**
   * Checks if the given data starts with a KTX file identifier.
   * @param data the data to check
   * @returns true if the data is a KTX file or false otherwise
   */
  static IsValid(data) {
    if (data.byteLength >= 12) {
      const identifier = new Uint8Array(data.buffer, data.byteOffset, 12);
      if (identifier[0] === 171 && identifier[1] === 75 && identifier[2] === 84 && identifier[3] === 88 && identifier[4] === 32 && identifier[5] === 49 && identifier[6] === 49 && identifier[7] === 187 && identifier[8] === 13 && identifier[9] === 10 && identifier[10] === 26 && identifier[11] === 10) {
        return true;
      }
    }
    return false;
  }
};
KhronosTextureContainer.HEADER_LEN = 12 + 13 * 4;
KhronosTextureContainer.COMPRESSED_2D = 0;
KhronosTextureContainer.COMPRESSED_3D = 1;
KhronosTextureContainer.TEX_2D = 2;
KhronosTextureContainer.TEX_3D = 3;

// node_modules/@babylonjs/core/Materials/Textures/ktx2decoderTypes.js
var SourceTextureFormat;
(function(SourceTextureFormat2) {
  SourceTextureFormat2[SourceTextureFormat2["ETC1S"] = 0] = "ETC1S";
  SourceTextureFormat2[SourceTextureFormat2["UASTC4x4"] = 1] = "UASTC4x4";
})(SourceTextureFormat || (SourceTextureFormat = {}));
var TranscodeTarget;
(function(TranscodeTarget2) {
  TranscodeTarget2[TranscodeTarget2["ASTC_4X4_RGBA"] = 0] = "ASTC_4X4_RGBA";
  TranscodeTarget2[TranscodeTarget2["BC7_RGBA"] = 1] = "BC7_RGBA";
  TranscodeTarget2[TranscodeTarget2["BC3_RGBA"] = 2] = "BC3_RGBA";
  TranscodeTarget2[TranscodeTarget2["BC1_RGB"] = 3] = "BC1_RGB";
  TranscodeTarget2[TranscodeTarget2["PVRTC1_4_RGBA"] = 4] = "PVRTC1_4_RGBA";
  TranscodeTarget2[TranscodeTarget2["PVRTC1_4_RGB"] = 5] = "PVRTC1_4_RGB";
  TranscodeTarget2[TranscodeTarget2["ETC2_RGBA"] = 6] = "ETC2_RGBA";
  TranscodeTarget2[TranscodeTarget2["ETC1_RGB"] = 7] = "ETC1_RGB";
  TranscodeTarget2[TranscodeTarget2["RGBA32"] = 8] = "RGBA32";
  TranscodeTarget2[TranscodeTarget2["R8"] = 9] = "R8";
  TranscodeTarget2[TranscodeTarget2["RG8"] = 10] = "RG8";
})(TranscodeTarget || (TranscodeTarget = {}));
var EngineFormat;
(function(EngineFormat2) {
  EngineFormat2[EngineFormat2["COMPRESSED_RGBA_BPTC_UNORM_EXT"] = 36492] = "COMPRESSED_RGBA_BPTC_UNORM_EXT";
  EngineFormat2[EngineFormat2["COMPRESSED_RGBA_ASTC_4X4_KHR"] = 37808] = "COMPRESSED_RGBA_ASTC_4X4_KHR";
  EngineFormat2[EngineFormat2["COMPRESSED_RGB_S3TC_DXT1_EXT"] = 33776] = "COMPRESSED_RGB_S3TC_DXT1_EXT";
  EngineFormat2[EngineFormat2["COMPRESSED_RGBA_S3TC_DXT5_EXT"] = 33779] = "COMPRESSED_RGBA_S3TC_DXT5_EXT";
  EngineFormat2[EngineFormat2["COMPRESSED_RGBA_PVRTC_4BPPV1_IMG"] = 35842] = "COMPRESSED_RGBA_PVRTC_4BPPV1_IMG";
  EngineFormat2[EngineFormat2["COMPRESSED_RGB_PVRTC_4BPPV1_IMG"] = 35840] = "COMPRESSED_RGB_PVRTC_4BPPV1_IMG";
  EngineFormat2[EngineFormat2["COMPRESSED_RGBA8_ETC2_EAC"] = 37496] = "COMPRESSED_RGBA8_ETC2_EAC";
  EngineFormat2[EngineFormat2["COMPRESSED_RGB8_ETC2"] = 37492] = "COMPRESSED_RGB8_ETC2";
  EngineFormat2[EngineFormat2["COMPRESSED_RGB_ETC1_WEBGL"] = 36196] = "COMPRESSED_RGB_ETC1_WEBGL";
  EngineFormat2[EngineFormat2["RGBA8Format"] = 32856] = "RGBA8Format";
  EngineFormat2[EngineFormat2["R8Format"] = 33321] = "R8Format";
  EngineFormat2[EngineFormat2["RG8Format"] = 33323] = "RG8Format";
})(EngineFormat || (EngineFormat = {}));

// node_modules/@babylonjs/core/Misc/khronosTextureContainer2Worker.js
function applyConfig(urls, binariesAndModulesContainer) {
  const KTX2DecoderModule = (binariesAndModulesContainer == null ? void 0 : binariesAndModulesContainer.jsDecoderModule) || KTX2DECODER;
  if (urls) {
    if (urls.wasmUASTCToASTC) {
      KTX2DecoderModule.LiteTranscoder_UASTC_ASTC.WasmModuleURL = urls.wasmUASTCToASTC;
    }
    if (urls.wasmUASTCToBC7) {
      KTX2DecoderModule.LiteTranscoder_UASTC_BC7.WasmModuleURL = urls.wasmUASTCToBC7;
    }
    if (urls.wasmUASTCToRGBA_UNORM) {
      KTX2DecoderModule.LiteTranscoder_UASTC_RGBA_UNORM.WasmModuleURL = urls.wasmUASTCToRGBA_UNORM;
    }
    if (urls.wasmUASTCToRGBA_SRGB) {
      KTX2DecoderModule.LiteTranscoder_UASTC_RGBA_SRGB.WasmModuleURL = urls.wasmUASTCToRGBA_SRGB;
    }
    if (urls.wasmUASTCToR8_UNORM) {
      KTX2DecoderModule.LiteTranscoder_UASTC_R8_UNORM.WasmModuleURL = urls.wasmUASTCToR8_UNORM;
    }
    if (urls.wasmUASTCToRG8_UNORM) {
      KTX2DecoderModule.LiteTranscoder_UASTC_RG8_UNORM.WasmModuleURL = urls.wasmUASTCToRG8_UNORM;
    }
    if (urls.jsMSCTranscoder) {
      KTX2DecoderModule.MSCTranscoder.JSModuleURL = urls.jsMSCTranscoder;
    }
    if (urls.wasmMSCTranscoder) {
      KTX2DecoderModule.MSCTranscoder.WasmModuleURL = urls.wasmMSCTranscoder;
    }
    if (urls.wasmZSTDDecoder) {
      KTX2DecoderModule.ZSTDDecoder.WasmModuleURL = urls.wasmZSTDDecoder;
    }
  }
  if (binariesAndModulesContainer) {
    if (binariesAndModulesContainer.wasmUASTCToASTC) {
      KTX2DecoderModule.LiteTranscoder_UASTC_ASTC.WasmBinary = binariesAndModulesContainer.wasmUASTCToASTC;
    }
    if (binariesAndModulesContainer.wasmUASTCToBC7) {
      KTX2DecoderModule.LiteTranscoder_UASTC_BC7.WasmBinary = binariesAndModulesContainer.wasmUASTCToBC7;
    }
    if (binariesAndModulesContainer.wasmUASTCToRGBA_UNORM) {
      KTX2DecoderModule.LiteTranscoder_UASTC_RGBA_UNORM.WasmBinary = binariesAndModulesContainer.wasmUASTCToRGBA_UNORM;
    }
    if (binariesAndModulesContainer.wasmUASTCToRGBA_SRGB) {
      KTX2DecoderModule.LiteTranscoder_UASTC_RGBA_SRGB.WasmBinary = binariesAndModulesContainer.wasmUASTCToRGBA_SRGB;
    }
    if (binariesAndModulesContainer.wasmUASTCToR8_UNORM) {
      KTX2DecoderModule.LiteTranscoder_UASTC_R8_UNORM.WasmBinary = binariesAndModulesContainer.wasmUASTCToR8_UNORM;
    }
    if (binariesAndModulesContainer.wasmUASTCToRG8_UNORM) {
      KTX2DecoderModule.LiteTranscoder_UASTC_RG8_UNORM.WasmBinary = binariesAndModulesContainer.wasmUASTCToRG8_UNORM;
    }
    if (binariesAndModulesContainer.jsMSCTranscoder) {
      KTX2DecoderModule.MSCTranscoder.JSModule = binariesAndModulesContainer.jsMSCTranscoder;
    }
    if (binariesAndModulesContainer.wasmMSCTranscoder) {
      KTX2DecoderModule.MSCTranscoder.WasmBinary = binariesAndModulesContainer.wasmMSCTranscoder;
    }
    if (binariesAndModulesContainer.wasmZSTDDecoder) {
      KTX2DecoderModule.ZSTDDecoder.WasmBinary = binariesAndModulesContainer.wasmZSTDDecoder;
    }
  }
}
function workerFunction(KTX2DecoderModule) {
  if (typeof KTX2DecoderModule === "undefined" && typeof KTX2DECODER !== "undefined") {
    KTX2DecoderModule = KTX2DECODER;
  }
  let ktx2Decoder;
  onmessage = (event) => {
    if (!event.data) {
      return;
    }
    switch (event.data.action) {
      case "init": {
        const urls = event.data.urls;
        if (urls) {
          if (urls.jsDecoderModule && typeof KTX2DecoderModule === "undefined") {
            importScripts(urls.jsDecoderModule);
            KTX2DecoderModule = KTX2DECODER;
          }
          applyConfig(urls);
        }
        if (event.data.wasmBinaries) {
          applyConfig(void 0, { ...event.data.wasmBinaries, jsDecoderModule: KTX2DecoderModule });
        }
        ktx2Decoder = new KTX2DecoderModule.KTX2Decoder();
        postMessage({ action: "init" });
        break;
      }
      case "setDefaultDecoderOptions": {
        KTX2DecoderModule.KTX2Decoder.DefaultDecoderOptions = event.data.options;
        break;
      }
      case "decode":
        ktx2Decoder.decode(event.data.data, event.data.caps, event.data.options).then((data) => {
          const buffers = [];
          for (let mip = 0; mip < data.mipmaps.length; ++mip) {
            const mipmap = data.mipmaps[mip];
            if (mipmap && mipmap.data) {
              buffers.push(mipmap.data.buffer);
            }
          }
          postMessage({ action: "decoded", success: true, decodedData: data }, buffers);
        }).catch((reason) => {
          postMessage({ action: "decoded", success: false, msg: reason });
        });
        break;
    }
  };
}
function initializeWebWorker(worker, wasmBinaries, urls) {
  return new Promise((resolve, reject) => {
    const onError = (error) => {
      worker.removeEventListener("error", onError);
      worker.removeEventListener("message", onMessage);
      reject(error);
    };
    const onMessage = (message) => {
      if (message.data.action === "init") {
        worker.removeEventListener("error", onError);
        worker.removeEventListener("message", onMessage);
        resolve(worker);
      }
    };
    worker.addEventListener("error", onError);
    worker.addEventListener("message", onMessage);
    worker.postMessage({
      action: "init",
      urls,
      wasmBinaries
    });
  });
}

// node_modules/@babylonjs/core/Misc/khronosTextureContainer2.js
var DefaultKTX2DecoderOptions = class {
  constructor() {
    this._isDirty = true;
    this._useRGBAIfOnlyBC1BC3AvailableWhenUASTC = true;
    this._ktx2DecoderOptions = {};
  }
  /**
   * Gets the dirty flag
   */
  get isDirty() {
    return this._isDirty;
  }
  /**
   * force a (uncompressed) RGBA transcoded format if transcoding a UASTC source format and ASTC + BC7 are not available as a compressed transcoded format
   */
  get useRGBAIfASTCBC7NotAvailableWhenUASTC() {
    return this._useRGBAIfASTCBC7NotAvailableWhenUASTC;
  }
  set useRGBAIfASTCBC7NotAvailableWhenUASTC(value) {
    if (this._useRGBAIfASTCBC7NotAvailableWhenUASTC === value) {
      return;
    }
    this._useRGBAIfASTCBC7NotAvailableWhenUASTC = value;
    this._isDirty = true;
  }
  /**
   * force a (uncompressed) RGBA transcoded format if transcoding a UASTC source format and only BC1 or BC3 are available as a compressed transcoded format.
   * This property is true by default to favor speed over memory, because currently transcoding from UASTC to BC1/3 is slow because the transcoder transcodes
   * to uncompressed and then recompresses the texture
   */
  get useRGBAIfOnlyBC1BC3AvailableWhenUASTC() {
    return this._useRGBAIfOnlyBC1BC3AvailableWhenUASTC;
  }
  set useRGBAIfOnlyBC1BC3AvailableWhenUASTC(value) {
    if (this._useRGBAIfOnlyBC1BC3AvailableWhenUASTC === value) {
      return;
    }
    this._useRGBAIfOnlyBC1BC3AvailableWhenUASTC = value;
    this._isDirty = true;
  }
  /**
   * force to always use (uncompressed) RGBA for transcoded format
   */
  get forceRGBA() {
    return this._forceRGBA;
  }
  set forceRGBA(value) {
    if (this._forceRGBA === value) {
      return;
    }
    this._forceRGBA = value;
    this._isDirty = true;
  }
  /**
   * force to always use (uncompressed) R8 for transcoded format
   */
  get forceR8() {
    return this._forceR8;
  }
  set forceR8(value) {
    if (this._forceR8 === value) {
      return;
    }
    this._forceR8 = value;
    this._isDirty = true;
  }
  /**
   * force to always use (uncompressed) RG8 for transcoded format
   */
  get forceRG8() {
    return this._forceRG8;
  }
  set forceRG8(value) {
    if (this._forceRG8 === value) {
      return;
    }
    this._forceRG8 = value;
    this._isDirty = true;
  }
  /**
   * list of transcoders to bypass when looking for a suitable transcoder. The available transcoders are:
   *      UniversalTranscoder_UASTC_ASTC
   *      UniversalTranscoder_UASTC_BC7
   *      UniversalTranscoder_UASTC_RGBA_UNORM
   *      UniversalTranscoder_UASTC_RGBA_SRGB
   *      UniversalTranscoder_UASTC_R8_UNORM
   *      UniversalTranscoder_UASTC_RG8_UNORM
   *      MSCTranscoder
   */
  get bypassTranscoders() {
    return this._bypassTranscoders;
  }
  set bypassTranscoders(value) {
    if (this._bypassTranscoders === value) {
      return;
    }
    this._bypassTranscoders = value;
    this._isDirty = true;
  }
  /** @internal */
  _getKTX2DecoderOptions() {
    if (!this._isDirty) {
      return this._ktx2DecoderOptions;
    }
    this._isDirty = false;
    const options = {
      useRGBAIfASTCBC7NotAvailableWhenUASTC: this._useRGBAIfASTCBC7NotAvailableWhenUASTC,
      forceRGBA: this._forceRGBA,
      forceR8: this._forceR8,
      forceRG8: this._forceRG8,
      bypassTranscoders: this._bypassTranscoders
    };
    if (this.useRGBAIfOnlyBC1BC3AvailableWhenUASTC) {
      options.transcodeFormatDecisionTree = {
        UASTC: {
          transcodeFormat: [TranscodeTarget.BC1_RGB, TranscodeTarget.BC3_RGBA],
          yes: {
            transcodeFormat: TranscodeTarget.RGBA32,
            engineFormat: EngineFormat.RGBA8Format,
            roundToMultiple4: false
          }
        }
      };
    }
    this._ktx2DecoderOptions = options;
    return options;
  }
};
var KhronosTextureContainer2 = class _KhronosTextureContainer2 {
  static GetDefaultNumWorkers() {
    if (typeof navigator !== "object" || !navigator.hardwareConcurrency) {
      return 1;
    }
    return Math.min(Math.floor(navigator.hardwareConcurrency * 0.5), 4);
  }
  static _Initialize(numWorkers) {
    if (_KhronosTextureContainer2._WorkerPoolPromise || _KhronosTextureContainer2._DecoderModulePromise) {
      return;
    }
    const urls = {
      jsDecoderModule: Tools.GetBabylonScriptURL(this.URLConfig.jsDecoderModule, true),
      wasmUASTCToASTC: Tools.GetBabylonScriptURL(this.URLConfig.wasmUASTCToASTC, true),
      wasmUASTCToBC7: Tools.GetBabylonScriptURL(this.URLConfig.wasmUASTCToBC7, true),
      wasmUASTCToRGBA_UNORM: Tools.GetBabylonScriptURL(this.URLConfig.wasmUASTCToRGBA_UNORM, true),
      wasmUASTCToRGBA_SRGB: Tools.GetBabylonScriptURL(this.URLConfig.wasmUASTCToRGBA_SRGB, true),
      wasmUASTCToR8_UNORM: Tools.GetBabylonScriptURL(this.URLConfig.wasmUASTCToR8_UNORM, true),
      wasmUASTCToRG8_UNORM: Tools.GetBabylonScriptURL(this.URLConfig.wasmUASTCToRG8_UNORM, true),
      jsMSCTranscoder: Tools.GetBabylonScriptURL(this.URLConfig.jsMSCTranscoder, true),
      wasmMSCTranscoder: Tools.GetBabylonScriptURL(this.URLConfig.wasmMSCTranscoder, true),
      wasmZSTDDecoder: Tools.GetBabylonScriptURL(this.URLConfig.wasmZSTDDecoder, true)
    };
    if (numWorkers && typeof Worker === "function" && typeof URL !== "undefined") {
      _KhronosTextureContainer2._WorkerPoolPromise = new Promise((resolve) => {
        const workerContent = `${applyConfig}(${workerFunction})()`;
        const workerBlobUrl = URL.createObjectURL(new Blob([workerContent], { type: "application/javascript" }));
        resolve(new AutoReleaseWorkerPool(numWorkers, () => initializeWebWorker(new Worker(workerBlobUrl), void 0, urls)));
      });
    } else {
      if (typeof _KhronosTextureContainer2._KTX2DecoderModule === "undefined") {
        _KhronosTextureContainer2._DecoderModulePromise = Tools.LoadBabylonScriptAsync(urls.jsDecoderModule).then(() => {
          _KhronosTextureContainer2._KTX2DecoderModule = KTX2DECODER;
          _KhronosTextureContainer2._KTX2DecoderModule.MSCTranscoder.UseFromWorkerThread = false;
          _KhronosTextureContainer2._KTX2DecoderModule.WASMMemoryManager.LoadBinariesFromCurrentThread = true;
          applyConfig(urls, _KhronosTextureContainer2._KTX2DecoderModule);
          return new _KhronosTextureContainer2._KTX2DecoderModule.KTX2Decoder();
        });
      } else {
        _KhronosTextureContainer2._KTX2DecoderModule.MSCTranscoder.UseFromWorkerThread = false;
        _KhronosTextureContainer2._KTX2DecoderModule.WASMMemoryManager.LoadBinariesFromCurrentThread = true;
        _KhronosTextureContainer2._DecoderModulePromise = Promise.resolve(new _KhronosTextureContainer2._KTX2DecoderModule.KTX2Decoder());
      }
    }
  }
  /**
   * Constructor
   * @param engine The engine to use
   * @param numWorkersOrOptions The number of workers for async operations. Specify `0` to disable web workers and run synchronously in the current context.
   */
  constructor(engine, numWorkersOrOptions = _KhronosTextureContainer2.DefaultNumWorkers) {
    var _a;
    this._engine = engine;
    if (typeof numWorkersOrOptions === "object" && numWorkersOrOptions.workerPool) {
      _KhronosTextureContainer2._WorkerPoolPromise = Promise.resolve(numWorkersOrOptions.workerPool);
    } else {
      if (typeof numWorkersOrOptions === "object") {
        _KhronosTextureContainer2._KTX2DecoderModule = (_a = numWorkersOrOptions == null ? void 0 : numWorkersOrOptions.binariesAndModulesContainer) == null ? void 0 : _a.jsDecoderModule;
      } else if (typeof KTX2DECODER !== "undefined") {
        _KhronosTextureContainer2._KTX2DecoderModule = KTX2DECODER;
      }
      const numberOfWorkers = typeof numWorkersOrOptions === "number" ? numWorkersOrOptions : numWorkersOrOptions.numWorkers ?? _KhronosTextureContainer2.DefaultNumWorkers;
      _KhronosTextureContainer2._Initialize(numberOfWorkers);
    }
  }
  /**
   * @internal
   */
  _uploadAsync(data, internalTexture, options) {
    const caps = this._engine.getCaps();
    const compressedTexturesCaps = {
      astc: !!caps.astc,
      bptc: !!caps.bptc,
      s3tc: !!caps.s3tc,
      pvrtc: !!caps.pvrtc,
      etc2: !!caps.etc2,
      etc1: !!caps.etc1
    };
    if (_KhronosTextureContainer2._WorkerPoolPromise) {
      return _KhronosTextureContainer2._WorkerPoolPromise.then((workerPool) => {
        return new Promise((resolve, reject) => {
          workerPool.push((worker, onComplete) => {
            const onError = (error) => {
              worker.removeEventListener("error", onError);
              worker.removeEventListener("message", onMessage);
              reject(error);
              onComplete();
            };
            const onMessage = (message) => {
              if (message.data.action === "decoded") {
                worker.removeEventListener("error", onError);
                worker.removeEventListener("message", onMessage);
                if (!message.data.success) {
                  reject({ message: message.data.msg });
                } else {
                  try {
                    this._createTexture(message.data.decodedData, internalTexture, options);
                    resolve();
                  } catch (err) {
                    reject({ message: err });
                  }
                }
                onComplete();
              }
            };
            worker.addEventListener("error", onError);
            worker.addEventListener("message", onMessage);
            worker.postMessage({ action: "setDefaultDecoderOptions", options: _KhronosTextureContainer2.DefaultDecoderOptions._getKTX2DecoderOptions() });
            const dataCopy = new Uint8Array(data.byteLength);
            dataCopy.set(new Uint8Array(data.buffer, data.byteOffset, data.byteLength));
            worker.postMessage({ action: "decode", data: dataCopy, caps: compressedTexturesCaps, options }, [dataCopy.buffer]);
          });
        });
      });
    } else if (_KhronosTextureContainer2._DecoderModulePromise) {
      return _KhronosTextureContainer2._DecoderModulePromise.then((decoder) => {
        if (_KhronosTextureContainer2.DefaultDecoderOptions.isDirty) {
          _KhronosTextureContainer2._KTX2DecoderModule.KTX2Decoder.DefaultDecoderOptions = _KhronosTextureContainer2.DefaultDecoderOptions._getKTX2DecoderOptions();
        }
        return new Promise((resolve, reject) => {
          decoder.decode(data, caps).then((data2) => {
            this._createTexture(data2, internalTexture);
            resolve();
          }).catch((reason) => {
            reject({ message: reason });
          });
        });
      });
    }
    throw new Error("KTX2 decoder module is not available");
  }
  _createTexture(data, internalTexture, options) {
    const oglTexture2D = 3553;
    this._engine._bindTextureDirectly(oglTexture2D, internalTexture);
    if (options) {
      options.transcodedFormat = data.transcodedFormat;
      options.isInGammaSpace = data.isInGammaSpace;
      options.hasAlpha = data.hasAlpha;
      options.transcoderName = data.transcoderName;
    }
    let isUncompressedFormat = true;
    switch (data.transcodedFormat) {
      case 32856:
        internalTexture.type = 0;
        internalTexture.format = 5;
        break;
      case 33321:
        internalTexture.type = 0;
        internalTexture.format = 6;
        break;
      case 33323:
        internalTexture.type = 0;
        internalTexture.format = 7;
        break;
      default:
        internalTexture.format = data.transcodedFormat;
        isUncompressedFormat = false;
        break;
    }
    internalTexture._gammaSpace = data.isInGammaSpace;
    internalTexture.generateMipMaps = data.mipmaps.length > 1;
    if (data.errors) {
      throw new Error("KTX2 container - could not transcode the data. " + data.errors);
    }
    for (let t = 0; t < data.mipmaps.length; ++t) {
      const mipmap = data.mipmaps[t];
      if (!mipmap || !mipmap.data) {
        throw new Error("KTX2 container - could not transcode one of the image");
      }
      if (isUncompressedFormat) {
        internalTexture.width = mipmap.width;
        internalTexture.height = mipmap.height;
        this._engine._uploadDataToTextureDirectly(internalTexture, mipmap.data, 0, t, void 0, true);
      } else {
        this._engine._uploadCompressedDataToTextureDirectly(internalTexture, data.transcodedFormat, mipmap.width, mipmap.height, mipmap.data, 0, t);
      }
    }
    internalTexture._extension = ".ktx2";
    internalTexture.width = data.mipmaps[0].width;
    internalTexture.height = data.mipmaps[0].height;
    internalTexture.isReady = true;
    this._engine._bindTextureDirectly(oglTexture2D, null);
  }
  /**
   * Checks if the given data starts with a KTX2 file identifier.
   * @param data the data to check
   * @returns true if the data is a KTX2 file or false otherwise
   */
  static IsValid(data) {
    if (data.byteLength >= 12) {
      const identifier = new Uint8Array(data.buffer, data.byteOffset, 12);
      if (identifier[0] === 171 && identifier[1] === 75 && identifier[2] === 84 && identifier[3] === 88 && identifier[4] === 32 && identifier[5] === 50 && identifier[6] === 48 && identifier[7] === 187 && identifier[8] === 13 && identifier[9] === 10 && identifier[10] === 26 && identifier[11] === 10) {
        return true;
      }
    }
    return false;
  }
};
KhronosTextureContainer2.URLConfig = {
  jsDecoderModule: "https://cdn.babylonjs.com/babylon.ktx2Decoder.js",
  wasmUASTCToASTC: null,
  wasmUASTCToBC7: null,
  wasmUASTCToRGBA_UNORM: null,
  wasmUASTCToRGBA_SRGB: null,
  wasmUASTCToR8_UNORM: null,
  wasmUASTCToRG8_UNORM: null,
  jsMSCTranscoder: null,
  wasmMSCTranscoder: null,
  wasmZSTDDecoder: null
};
KhronosTextureContainer2.DefaultNumWorkers = KhronosTextureContainer2.GetDefaultNumWorkers();
KhronosTextureContainer2.DefaultDecoderOptions = new DefaultKTX2DecoderOptions();

// node_modules/@babylonjs/core/Materials/Textures/Loaders/ktxTextureLoader.js
function mapSRGBToLinear(format) {
  switch (format) {
    case 35916:
      return 33776;
    case 35918:
      return 33778;
    case 35919:
      return 33779;
    case 37493:
      return 37492;
    case 37497:
      return 37496;
    case 37495:
      return 37494;
    case 37840:
      return 37808;
    case 36493:
      return 36492;
  }
  return null;
}
var _KTXTextureLoader = class {
  constructor() {
    this.supportCascades = false;
  }
  /**
   * This returns if the loader support the current file information.
   * @param extension defines the file extension of the file being loaded
   * @param mimeType defines the optional mime type of the file being loaded
   * @returns true if the loader can load the specified file
   */
  canLoad(extension, mimeType) {
    return extension.endsWith(".ktx") || extension.endsWith(".ktx2") || mimeType === "image/ktx" || mimeType === "image/ktx2";
  }
  /**
   * Uploads the cube texture data to the WebGL texture. It has already been bound.
   * @param data contains the texture data
   * @param texture defines the BabylonJS internal texture
   * @param createPolynomials will be true if polynomials have been requested
   * @param onLoad defines the callback to trigger once the texture is ready
   */
  loadCubeData(data, texture, createPolynomials, onLoad) {
    if (Array.isArray(data)) {
      return;
    }
    texture._invertVScale = !texture.invertY;
    const engine = texture.getEngine();
    const ktx = new KhronosTextureContainer(data, 6);
    const loadMipmap = ktx.numberOfMipmapLevels > 1 && texture.generateMipMaps;
    engine._unpackFlipY(true);
    ktx.uploadLevels(texture, texture.generateMipMaps);
    texture.width = ktx.pixelWidth;
    texture.height = ktx.pixelHeight;
    engine._setCubeMapTextureParams(texture, loadMipmap, ktx.numberOfMipmapLevels - 1);
    texture.isReady = true;
    texture.onLoadedObservable.notifyObservers(texture);
    texture.onLoadedObservable.clear();
    if (onLoad) {
      onLoad();
    }
  }
  /**
   * Uploads the 2D texture data to the WebGL texture. It has already been bound once in the callback.
   * @param data contains the texture data
   * @param texture defines the BabylonJS internal texture
   * @param callback defines the method to call once ready to upload
   * @param options
   */
  loadData(data, texture, callback, options) {
    if (KhronosTextureContainer.IsValid(data)) {
      texture._invertVScale = !texture.invertY;
      const ktx = new KhronosTextureContainer(data, 1);
      const mappedFormat = mapSRGBToLinear(ktx.glInternalFormat);
      if (mappedFormat) {
        texture.format = mappedFormat;
        texture._useSRGBBuffer = texture.getEngine()._getUseSRGBBuffer(true, texture.generateMipMaps);
        texture._gammaSpace = true;
      } else {
        texture.format = ktx.glInternalFormat;
      }
      callback(ktx.pixelWidth, ktx.pixelHeight, texture.generateMipMaps, true, () => {
        ktx.uploadLevels(texture, texture.generateMipMaps);
      }, ktx.isInvalid);
    } else if (KhronosTextureContainer2.IsValid(data)) {
      const ktx2 = new KhronosTextureContainer2(texture.getEngine());
      ktx2._uploadAsync(data, texture, options).then(() => {
        callback(texture.width, texture.height, texture.generateMipMaps, true, () => {
        }, false);
      }, (error) => {
        Logger.Warn(`Failed to load KTX2 texture data: ${error.message}`);
        callback(0, 0, false, false, () => {
        }, true);
      });
    } else {
      Logger.Error("texture missing KTX identifier");
      callback(0, 0, false, false, () => {
      }, true);
    }
  }
};
Engine._TextureLoaders.unshift(new _KTXTextureLoader());

// node_modules/@babylonjs/core/Misc/tga.js
var _TYPE_INDEXED = 1;
var _TYPE_RGB = 2;
var _TYPE_GREY = 3;
var _TYPE_RLE_INDEXED = 9;
var _TYPE_RLE_RGB = 10;
var _TYPE_RLE_GREY = 11;
var _ORIGIN_MASK = 48;
var _ORIGIN_SHIFT = 4;
var _ORIGIN_BL = 0;
var _ORIGIN_BR = 1;
var _ORIGIN_UL = 2;
var _ORIGIN_UR = 3;
function GetTGAHeader(data) {
  let offset = 0;
  const header = {
    id_length: data[offset++],
    colormap_type: data[offset++],
    image_type: data[offset++],
    colormap_index: data[offset++] | data[offset++] << 8,
    colormap_length: data[offset++] | data[offset++] << 8,
    colormap_size: data[offset++],
    origin: [data[offset++] | data[offset++] << 8, data[offset++] | data[offset++] << 8],
    width: data[offset++] | data[offset++] << 8,
    height: data[offset++] | data[offset++] << 8,
    pixel_size: data[offset++],
    flags: data[offset++]
  };
  return header;
}
function UploadContent(texture, data) {
  if (data.length < 19) {
    Logger.Error("Unable to load TGA file - Not enough data to contain header");
    return;
  }
  let offset = 18;
  const header = GetTGAHeader(data);
  if (header.id_length + offset > data.length) {
    Logger.Error("Unable to load TGA file - Not enough data");
    return;
  }
  offset += header.id_length;
  let use_rle = false;
  let use_pal = false;
  let use_grey = false;
  switch (header.image_type) {
    case _TYPE_RLE_INDEXED:
      use_rle = true;
    case _TYPE_INDEXED:
      use_pal = true;
      break;
    case _TYPE_RLE_RGB:
      use_rle = true;
    case _TYPE_RGB:
      break;
    case _TYPE_RLE_GREY:
      use_rle = true;
    case _TYPE_GREY:
      use_grey = true;
      break;
  }
  let pixel_data;
  const pixel_size = header.pixel_size >> 3;
  const pixel_total = header.width * header.height * pixel_size;
  let palettes;
  if (use_pal) {
    palettes = data.subarray(offset, offset += header.colormap_length * (header.colormap_size >> 3));
  }
  if (use_rle) {
    pixel_data = new Uint8Array(pixel_total);
    let c, count, i;
    let localOffset = 0;
    const pixels = new Uint8Array(pixel_size);
    while (offset < pixel_total && localOffset < pixel_total) {
      c = data[offset++];
      count = (c & 127) + 1;
      if (c & 128) {
        for (i = 0; i < pixel_size; ++i) {
          pixels[i] = data[offset++];
        }
        for (i = 0; i < count; ++i) {
          pixel_data.set(pixels, localOffset + i * pixel_size);
        }
        localOffset += pixel_size * count;
      } else {
        count *= pixel_size;
        for (i = 0; i < count; ++i) {
          pixel_data[localOffset + i] = data[offset++];
        }
        localOffset += count;
      }
    }
  } else {
    pixel_data = data.subarray(offset, offset += use_pal ? header.width * header.height : pixel_total);
  }
  let x_start, y_start, x_step, y_step, y_end, x_end;
  switch ((header.flags & _ORIGIN_MASK) >> _ORIGIN_SHIFT) {
    default:
    case _ORIGIN_UL:
      x_start = 0;
      x_step = 1;
      x_end = header.width;
      y_start = 0;
      y_step = 1;
      y_end = header.height;
      break;
    case _ORIGIN_BL:
      x_start = 0;
      x_step = 1;
      x_end = header.width;
      y_start = header.height - 1;
      y_step = -1;
      y_end = -1;
      break;
    case _ORIGIN_UR:
      x_start = header.width - 1;
      x_step = -1;
      x_end = -1;
      y_start = 0;
      y_step = 1;
      y_end = header.height;
      break;
    case _ORIGIN_BR:
      x_start = header.width - 1;
      x_step = -1;
      x_end = -1;
      y_start = header.height - 1;
      y_step = -1;
      y_end = -1;
      break;
  }
  const func = "_getImageData" + (use_grey ? "Grey" : "") + header.pixel_size + "bits";
  const imageData = TGATools[func](header, palettes, pixel_data, y_start, y_step, y_end, x_start, x_step, x_end);
  const engine = texture.getEngine();
  engine._uploadDataToTextureDirectly(texture, imageData);
}
function _getImageData8bits(header, palettes, pixel_data, y_start, y_step, y_end, x_start, x_step, x_end) {
  const image = pixel_data, colormap = palettes;
  const width = header.width, height = header.height;
  let color, i = 0, x, y;
  const imageData = new Uint8Array(width * height * 4);
  for (y = y_start; y !== y_end; y += y_step) {
    for (x = x_start; x !== x_end; x += x_step, i++) {
      color = image[i];
      imageData[(x + width * y) * 4 + 3] = 255;
      imageData[(x + width * y) * 4 + 2] = colormap[color * 3 + 0];
      imageData[(x + width * y) * 4 + 1] = colormap[color * 3 + 1];
      imageData[(x + width * y) * 4 + 0] = colormap[color * 3 + 2];
    }
  }
  return imageData;
}
function _getImageData16bits(header, palettes, pixel_data, y_start, y_step, y_end, x_start, x_step, x_end) {
  const image = pixel_data;
  const width = header.width, height = header.height;
  let color, i = 0, x, y;
  const imageData = new Uint8Array(width * height * 4);
  for (y = y_start; y !== y_end; y += y_step) {
    for (x = x_start; x !== x_end; x += x_step, i += 2) {
      color = image[i + 0] + (image[i + 1] << 8);
      const r = ((color & 31744) >> 10) * 255 / 31 | 0;
      const g = ((color & 992) >> 5) * 255 / 31 | 0;
      const b = (color & 31) * 255 / 31 | 0;
      imageData[(x + width * y) * 4 + 0] = r;
      imageData[(x + width * y) * 4 + 1] = g;
      imageData[(x + width * y) * 4 + 2] = b;
      imageData[(x + width * y) * 4 + 3] = color & 32768 ? 0 : 255;
    }
  }
  return imageData;
}
function _getImageData24bits(header, palettes, pixel_data, y_start, y_step, y_end, x_start, x_step, x_end) {
  const image = pixel_data;
  const width = header.width, height = header.height;
  let i = 0, x, y;
  const imageData = new Uint8Array(width * height * 4);
  for (y = y_start; y !== y_end; y += y_step) {
    for (x = x_start; x !== x_end; x += x_step, i += 3) {
      imageData[(x + width * y) * 4 + 3] = 255;
      imageData[(x + width * y) * 4 + 2] = image[i + 0];
      imageData[(x + width * y) * 4 + 1] = image[i + 1];
      imageData[(x + width * y) * 4 + 0] = image[i + 2];
    }
  }
  return imageData;
}
function _getImageData32bits(header, palettes, pixel_data, y_start, y_step, y_end, x_start, x_step, x_end) {
  const image = pixel_data;
  const width = header.width, height = header.height;
  let i = 0, x, y;
  const imageData = new Uint8Array(width * height * 4);
  for (y = y_start; y !== y_end; y += y_step) {
    for (x = x_start; x !== x_end; x += x_step, i += 4) {
      imageData[(x + width * y) * 4 + 2] = image[i + 0];
      imageData[(x + width * y) * 4 + 1] = image[i + 1];
      imageData[(x + width * y) * 4 + 0] = image[i + 2];
      imageData[(x + width * y) * 4 + 3] = image[i + 3];
    }
  }
  return imageData;
}
function _getImageDataGrey8bits(header, palettes, pixel_data, y_start, y_step, y_end, x_start, x_step, x_end) {
  const image = pixel_data;
  const width = header.width, height = header.height;
  let color, i = 0, x, y;
  const imageData = new Uint8Array(width * height * 4);
  for (y = y_start; y !== y_end; y += y_step) {
    for (x = x_start; x !== x_end; x += x_step, i++) {
      color = image[i];
      imageData[(x + width * y) * 4 + 0] = color;
      imageData[(x + width * y) * 4 + 1] = color;
      imageData[(x + width * y) * 4 + 2] = color;
      imageData[(x + width * y) * 4 + 3] = 255;
    }
  }
  return imageData;
}
function _getImageDataGrey16bits(header, palettes, pixel_data, y_start, y_step, y_end, x_start, x_step, x_end) {
  const image = pixel_data;
  const width = header.width, height = header.height;
  let i = 0, x, y;
  const imageData = new Uint8Array(width * height * 4);
  for (y = y_start; y !== y_end; y += y_step) {
    for (x = x_start; x !== x_end; x += x_step, i += 2) {
      imageData[(x + width * y) * 4 + 0] = image[i + 0];
      imageData[(x + width * y) * 4 + 1] = image[i + 0];
      imageData[(x + width * y) * 4 + 2] = image[i + 0];
      imageData[(x + width * y) * 4 + 3] = image[i + 1];
    }
  }
  return imageData;
}
var TGATools = {
  /**
   * Gets the header of a TGA file
   * @param data defines the TGA data
   * @returns the header
   */
  GetTGAHeader,
  /**
   * Uploads TGA content to a Babylon Texture
   * @internal
   */
  UploadContent,
  /** @internal */
  _getImageData8bits,
  /** @internal */
  _getImageData16bits,
  /** @internal */
  _getImageData24bits,
  /** @internal */
  _getImageData32bits,
  /** @internal */
  _getImageDataGrey8bits,
  /** @internal */
  _getImageDataGrey16bits
};

// node_modules/@babylonjs/core/Materials/Textures/Loaders/tgaTextureLoader.js
var _TGATextureLoader = class {
  constructor() {
    this.supportCascades = false;
  }
  /**
   * This returns if the loader support the current file information.
   * @param extension defines the file extension of the file being loaded
   * @returns true if the loader can load the specified file
   */
  canLoad(extension) {
    return extension.endsWith(".tga");
  }
  /**
   * Uploads the cube texture data to the WebGL texture. It has already been bound.
   */
  loadCubeData() {
    throw ".env not supported in Cube.";
  }
  /**
   * Uploads the 2D texture data to the WebGL texture. It has already been bound once in the callback.
   * @param data contains the texture data
   * @param texture defines the BabylonJS internal texture
   * @param callback defines the method to call once ready to upload
   */
  loadData(data, texture, callback) {
    const bytes = new Uint8Array(data.buffer, data.byteOffset, data.byteLength);
    const header = GetTGAHeader(bytes);
    callback(header.width, header.height, texture.generateMipMaps, false, () => {
      UploadContent(texture, bytes);
    });
  }
};
Engine._TextureLoaders.push(new _TGATextureLoader());

// node_modules/@babylonjs/core/Misc/HighDynamicRange/panoramaToCubemap.js
var PanoramaToCubeMapTools = class {
  /**
   * Converts a panorama stored in RGB right to left up to down format into a cubemap (6 faces).
   *
   * @param float32Array The source data.
   * @param inputWidth The width of the input panorama.
   * @param inputHeight The height of the input panorama.
   * @param size The willing size of the generated cubemap (each faces will be size * size pixels)
   * @param supersample enable supersampling the cubemap
   * @returns The cubemap data
   */
  static ConvertPanoramaToCubemap(float32Array, inputWidth, inputHeight, size, supersample = false) {
    if (!float32Array) {
      throw "ConvertPanoramaToCubemap: input cannot be null";
    }
    if (float32Array.length != inputWidth * inputHeight * 3) {
      throw "ConvertPanoramaToCubemap: input size is wrong";
    }
    const textureFront = this.CreateCubemapTexture(size, this.FACE_FRONT, float32Array, inputWidth, inputHeight, supersample);
    const textureBack = this.CreateCubemapTexture(size, this.FACE_BACK, float32Array, inputWidth, inputHeight, supersample);
    const textureLeft = this.CreateCubemapTexture(size, this.FACE_LEFT, float32Array, inputWidth, inputHeight, supersample);
    const textureRight = this.CreateCubemapTexture(size, this.FACE_RIGHT, float32Array, inputWidth, inputHeight, supersample);
    const textureUp = this.CreateCubemapTexture(size, this.FACE_UP, float32Array, inputWidth, inputHeight, supersample);
    const textureDown = this.CreateCubemapTexture(size, this.FACE_DOWN, float32Array, inputWidth, inputHeight, supersample);
    return {
      front: textureFront,
      back: textureBack,
      left: textureLeft,
      right: textureRight,
      up: textureUp,
      down: textureDown,
      size,
      type: 1,
      format: 4,
      gammaSpace: false
    };
  }
  static CreateCubemapTexture(texSize, faceData, float32Array, inputWidth, inputHeight, supersample = false) {
    const buffer = new ArrayBuffer(texSize * texSize * 4 * 3);
    const textureArray = new Float32Array(buffer);
    const samples = supersample ? Math.max(1, Math.round(inputWidth / 4 / texSize)) : 1;
    const sampleFactor = 1 / samples;
    const sampleFactorSqr = sampleFactor * sampleFactor;
    const rotDX1 = faceData[1].subtract(faceData[0]).scale(sampleFactor / texSize);
    const rotDX2 = faceData[3].subtract(faceData[2]).scale(sampleFactor / texSize);
    const dy = 1 / texSize;
    let fy = 0;
    for (let y = 0; y < texSize; y++) {
      for (let sy = 0; sy < samples; sy++) {
        let xv1 = faceData[0];
        let xv2 = faceData[2];
        for (let x = 0; x < texSize; x++) {
          for (let sx = 0; sx < samples; sx++) {
            const v = xv2.subtract(xv1).scale(fy).add(xv1);
            v.normalize();
            const color = this.CalcProjectionSpherical(v, float32Array, inputWidth, inputHeight);
            textureArray[y * texSize * 3 + x * 3 + 0] += color.r * sampleFactorSqr;
            textureArray[y * texSize * 3 + x * 3 + 1] += color.g * sampleFactorSqr;
            textureArray[y * texSize * 3 + x * 3 + 2] += color.b * sampleFactorSqr;
            xv1 = xv1.add(rotDX1);
            xv2 = xv2.add(rotDX2);
          }
        }
        fy += dy * sampleFactor;
      }
    }
    return textureArray;
  }
  static CalcProjectionSpherical(vDir, float32Array, inputWidth, inputHeight) {
    let theta = Math.atan2(vDir.z, vDir.x);
    const phi = Math.acos(vDir.y);
    while (theta < -Math.PI) {
      theta += 2 * Math.PI;
    }
    while (theta > Math.PI) {
      theta -= 2 * Math.PI;
    }
    let dx = theta / Math.PI;
    const dy = phi / Math.PI;
    dx = dx * 0.5 + 0.5;
    let px = Math.round(dx * inputWidth);
    if (px < 0) {
      px = 0;
    } else if (px >= inputWidth) {
      px = inputWidth - 1;
    }
    let py = Math.round(dy * inputHeight);
    if (py < 0) {
      py = 0;
    } else if (py >= inputHeight) {
      py = inputHeight - 1;
    }
    const inputY = inputHeight - py - 1;
    const r = float32Array[inputY * inputWidth * 3 + px * 3 + 0];
    const g = float32Array[inputY * inputWidth * 3 + px * 3 + 1];
    const b = float32Array[inputY * inputWidth * 3 + px * 3 + 2];
    return {
      r,
      g,
      b
    };
  }
};
PanoramaToCubeMapTools.FACE_LEFT = [new Vector3(-1, -1, -1), new Vector3(1, -1, -1), new Vector3(-1, 1, -1), new Vector3(1, 1, -1)];
PanoramaToCubeMapTools.FACE_RIGHT = [new Vector3(1, -1, 1), new Vector3(-1, -1, 1), new Vector3(1, 1, 1), new Vector3(-1, 1, 1)];
PanoramaToCubeMapTools.FACE_FRONT = [new Vector3(1, -1, -1), new Vector3(1, -1, 1), new Vector3(1, 1, -1), new Vector3(1, 1, 1)];
PanoramaToCubeMapTools.FACE_BACK = [new Vector3(-1, -1, 1), new Vector3(-1, -1, -1), new Vector3(-1, 1, 1), new Vector3(-1, 1, -1)];
PanoramaToCubeMapTools.FACE_DOWN = [new Vector3(1, 1, -1), new Vector3(1, 1, 1), new Vector3(-1, 1, -1), new Vector3(-1, 1, 1)];
PanoramaToCubeMapTools.FACE_UP = [new Vector3(-1, -1, -1), new Vector3(-1, -1, 1), new Vector3(1, -1, -1), new Vector3(1, -1, 1)];

// node_modules/@babylonjs/core/Misc/HighDynamicRange/hdr.js
var HDRTools = class {
  static _Ldexp(mantissa, exponent) {
    if (exponent > 1023) {
      return mantissa * Math.pow(2, 1023) * Math.pow(2, exponent - 1023);
    }
    if (exponent < -1074) {
      return mantissa * Math.pow(2, -1074) * Math.pow(2, exponent + 1074);
    }
    return mantissa * Math.pow(2, exponent);
  }
  static _Rgbe2float(float32array, red, green, blue, exponent, index) {
    if (exponent > 0) {
      exponent = this._Ldexp(1, exponent - (128 + 8));
      float32array[index + 0] = red * exponent;
      float32array[index + 1] = green * exponent;
      float32array[index + 2] = blue * exponent;
    } else {
      float32array[index + 0] = 0;
      float32array[index + 1] = 0;
      float32array[index + 2] = 0;
    }
  }
  static _ReadStringLine(uint8array, startIndex) {
    let line = "";
    let character = "";
    for (let i = startIndex; i < uint8array.length - startIndex; i++) {
      character = String.fromCharCode(uint8array[i]);
      if (character == "\n") {
        break;
      }
      line += character;
    }
    return line;
  }
  /**
   * Reads header information from an RGBE texture stored in a native array.
   * More information on this format are available here:
   * https://en.wikipedia.org/wiki/RGBE_image_format
   *
   * @param uint8array The binary file stored in  native array.
   * @returns The header information.
   */
  // eslint-disable-next-line @typescript-eslint/naming-convention
  static RGBE_ReadHeader(uint8array) {
    let height = 0;
    let width = 0;
    let line = this._ReadStringLine(uint8array, 0);
    if (line[0] != "#" || line[1] != "?") {
      throw "Bad HDR Format.";
    }
    let endOfHeader = false;
    let findFormat = false;
    let lineIndex = 0;
    do {
      lineIndex += line.length + 1;
      line = this._ReadStringLine(uint8array, lineIndex);
      if (line == "FORMAT=32-bit_rle_rgbe") {
        findFormat = true;
      } else if (line.length == 0) {
        endOfHeader = true;
      }
    } while (!endOfHeader);
    if (!findFormat) {
      throw "HDR Bad header format, unsupported FORMAT";
    }
    lineIndex += line.length + 1;
    line = this._ReadStringLine(uint8array, lineIndex);
    const sizeRegexp = /^-Y (.*) \+X (.*)$/g;
    const match = sizeRegexp.exec(line);
    if (!match || match.length < 3) {
      throw "HDR Bad header format, no size";
    }
    width = parseInt(match[2]);
    height = parseInt(match[1]);
    if (width < 8 || width > 32767) {
      throw "HDR Bad header format, unsupported size";
    }
    lineIndex += line.length + 1;
    return {
      height,
      width,
      dataPosition: lineIndex
    };
  }
  /**
   * Returns the cubemap information (each faces texture data) extracted from an RGBE texture.
   * This RGBE texture needs to store the information as a panorama.
   *
   * More information on this format are available here:
   * https://en.wikipedia.org/wiki/RGBE_image_format
   *
   * @param buffer The binary file stored in an array buffer.
   * @param size The expected size of the extracted cubemap.
   * @param supersample enable supersampling the cubemap (default: false)
   * @returns The Cube Map information.
   */
  static GetCubeMapTextureData(buffer, size, supersample = false) {
    const uint8array = new Uint8Array(buffer);
    const hdrInfo = this.RGBE_ReadHeader(uint8array);
    const data = this.RGBE_ReadPixels(uint8array, hdrInfo);
    const cubeMapData = PanoramaToCubeMapTools.ConvertPanoramaToCubemap(data, hdrInfo.width, hdrInfo.height, size, supersample);
    return cubeMapData;
  }
  /**
   * Returns the pixels data extracted from an RGBE texture.
   * This pixels will be stored left to right up to down in the R G B order in one array.
   *
   * More information on this format are available here:
   * https://en.wikipedia.org/wiki/RGBE_image_format
   *
   * @param uint8array The binary file stored in an array buffer.
   * @param hdrInfo The header information of the file.
   * @returns The pixels data in RGB right to left up to down order.
   */
  // eslint-disable-next-line @typescript-eslint/naming-convention
  static RGBE_ReadPixels(uint8array, hdrInfo) {
    return this._RGBEReadPixelsRLE(uint8array, hdrInfo);
  }
  static _RGBEReadPixelsRLE(uint8array, hdrInfo) {
    let num_scanlines = hdrInfo.height;
    const scanline_width = hdrInfo.width;
    let a, b, c, d, count;
    let dataIndex = hdrInfo.dataPosition;
    let index = 0, endIndex = 0, i = 0;
    const scanLineArrayBuffer = new ArrayBuffer(scanline_width * 4);
    const scanLineArray = new Uint8Array(scanLineArrayBuffer);
    const resultBuffer = new ArrayBuffer(hdrInfo.width * hdrInfo.height * 4 * 3);
    const resultArray = new Float32Array(resultBuffer);
    while (num_scanlines > 0) {
      a = uint8array[dataIndex++];
      b = uint8array[dataIndex++];
      c = uint8array[dataIndex++];
      d = uint8array[dataIndex++];
      if (a != 2 || b != 2 || c & 128 || hdrInfo.width < 8 || hdrInfo.width > 32767) {
        return this._RGBEReadPixelsNOTRLE(uint8array, hdrInfo);
      }
      if ((c << 8 | d) != scanline_width) {
        throw "HDR Bad header format, wrong scan line width";
      }
      index = 0;
      for (i = 0; i < 4; i++) {
        endIndex = (i + 1) * scanline_width;
        while (index < endIndex) {
          a = uint8array[dataIndex++];
          b = uint8array[dataIndex++];
          if (a > 128) {
            count = a - 128;
            if (count == 0 || count > endIndex - index) {
              throw "HDR Bad Format, bad scanline data (run)";
            }
            while (count-- > 0) {
              scanLineArray[index++] = b;
            }
          } else {
            count = a;
            if (count == 0 || count > endIndex - index) {
              throw "HDR Bad Format, bad scanline data (non-run)";
            }
            scanLineArray[index++] = b;
            if (--count > 0) {
              for (let j = 0; j < count; j++) {
                scanLineArray[index++] = uint8array[dataIndex++];
              }
            }
          }
        }
      }
      for (i = 0; i < scanline_width; i++) {
        a = scanLineArray[i];
        b = scanLineArray[i + scanline_width];
        c = scanLineArray[i + 2 * scanline_width];
        d = scanLineArray[i + 3 * scanline_width];
        this._Rgbe2float(resultArray, a, b, c, d, (hdrInfo.height - num_scanlines) * scanline_width * 3 + i * 3);
      }
      num_scanlines--;
    }
    return resultArray;
  }
  static _RGBEReadPixelsNOTRLE(uint8array, hdrInfo) {
    let num_scanlines = hdrInfo.height;
    const scanline_width = hdrInfo.width;
    let a, b, c, d, i;
    let dataIndex = hdrInfo.dataPosition;
    const resultBuffer = new ArrayBuffer(hdrInfo.width * hdrInfo.height * 4 * 3);
    const resultArray = new Float32Array(resultBuffer);
    while (num_scanlines > 0) {
      for (i = 0; i < hdrInfo.width; i++) {
        a = uint8array[dataIndex++];
        b = uint8array[dataIndex++];
        c = uint8array[dataIndex++];
        d = uint8array[dataIndex++];
        this._Rgbe2float(resultArray, a, b, c, d, (hdrInfo.height - num_scanlines) * scanline_width * 3 + i * 3);
      }
      num_scanlines--;
    }
    return resultArray;
  }
};

// node_modules/@babylonjs/core/Materials/Textures/Loaders/hdrTextureLoader.js
var _HDRTextureLoader = class {
  constructor() {
    this.supportCascades = false;
  }
  /**
   * This returns if the loader support the current file information.
   * @param extension defines the file extension of the file being loaded
   * @returns true if the loader can load the specified file
   */
  canLoad(extension) {
    return extension.endsWith(".hdr");
  }
  /**
   * Uploads the cube texture data to the WebGL texture. It has already been bound.
   */
  loadCubeData() {
    throw ".env not supported in Cube.";
  }
  /**
   * Uploads the 2D texture data to the WebGL texture. It has already been bound once in the callback.
   * @param data contains the texture data
   * @param texture defines the BabylonJS internal texture
   * @param callback defines the method to call once ready to upload
   */
  loadData(data, texture, callback) {
    const uint8array = new Uint8Array(data.buffer, data.byteOffset, data.byteLength);
    const hdrInfo = HDRTools.RGBE_ReadHeader(uint8array);
    const pixelsDataRGB32 = HDRTools.RGBE_ReadPixels(uint8array, hdrInfo);
    const pixels = hdrInfo.width * hdrInfo.height;
    const pixelsDataRGBA32 = new Float32Array(pixels * 4);
    for (let i = 0; i < pixels; i += 1) {
      pixelsDataRGBA32[i * 4] = pixelsDataRGB32[i * 3];
      pixelsDataRGBA32[i * 4 + 1] = pixelsDataRGB32[i * 3 + 1];
      pixelsDataRGBA32[i * 4 + 2] = pixelsDataRGB32[i * 3 + 2];
      pixelsDataRGBA32[i * 4 + 3] = 1;
    }
    callback(hdrInfo.width, hdrInfo.height, texture.generateMipMaps, false, () => {
      const engine = texture.getEngine();
      texture.type = 1;
      texture.format = 5;
      texture._gammaSpace = false;
      engine._uploadDataToTextureDirectly(texture, pixelsDataRGBA32);
    });
  }
};
Engine._TextureLoaders.push(new _HDRTextureLoader());

// node_modules/@babylonjs/core/Misc/basisWorker.js
function workerFunction2() {
  const _BASIS_FORMAT = {
    cTFETC1: 0,
    cTFETC2: 1,
    cTFBC1: 2,
    cTFBC3: 3,
    cTFBC4: 4,
    cTFBC5: 5,
    cTFBC7: 6,
    cTFPVRTC1_4_RGB: 8,
    cTFPVRTC1_4_RGBA: 9,
    cTFASTC_4x4: 10,
    cTFATC_RGB: 11,
    cTFATC_RGBA_INTERPOLATED_ALPHA: 12,
    cTFRGBA32: 13,
    cTFRGB565: 14,
    cTFBGR565: 15,
    cTFRGBA4444: 16,
    cTFFXT1_RGB: 17,
    cTFPVRTC2_4_RGB: 18,
    cTFPVRTC2_4_RGBA: 19,
    cTFETC2_EAC_R11: 20,
    cTFETC2_EAC_RG11: 21
  };
  let transcoderModulePromise = null;
  onmessage = (event) => {
    if (event.data.action === "init") {
      if (event.data.url) {
        try {
          importScripts(event.data.url);
        } catch (e) {
          postMessage({ action: "error", error: e });
        }
      }
      if (!transcoderModulePromise) {
        transcoderModulePromise = BASIS({
          // Override wasm binary
          wasmBinary: event.data.wasmBinary
        });
      }
      if (transcoderModulePromise !== null) {
        transcoderModulePromise.then((m) => {
          BASIS = m;
          m.initializeBasis();
          postMessage({ action: "init" });
        });
      }
    } else if (event.data.action === "transcode") {
      const config = event.data.config;
      const imgData = event.data.imageData;
      const loadedFile = new BASIS.BasisFile(imgData);
      const fileInfo = GetFileInfo(loadedFile);
      let format = event.data.ignoreSupportedFormats ? null : GetSupportedTranscodeFormat(event.data.config, fileInfo);
      let needsConversion = false;
      if (format === null) {
        needsConversion = true;
        format = fileInfo.hasAlpha ? _BASIS_FORMAT.cTFBC3 : _BASIS_FORMAT.cTFBC1;
      }
      let success = true;
      if (!loadedFile.startTranscoding()) {
        success = false;
      }
      const buffers = [];
      for (let imageIndex = 0; imageIndex < fileInfo.images.length; imageIndex++) {
        if (!success) {
          break;
        }
        const image = fileInfo.images[imageIndex];
        if (config.loadSingleImage === void 0 || config.loadSingleImage === imageIndex) {
          let mipCount = image.levels.length;
          if (config.loadMipmapLevels === false) {
            mipCount = 1;
          }
          for (let levelIndex = 0; levelIndex < mipCount; levelIndex++) {
            const levelInfo = image.levels[levelIndex];
            const pixels = TranscodeLevel(loadedFile, imageIndex, levelIndex, format, needsConversion);
            if (!pixels) {
              success = false;
              break;
            }
            levelInfo.transcodedPixels = pixels;
            buffers.push(levelInfo.transcodedPixels.buffer);
          }
        }
      }
      loadedFile.close();
      loadedFile.delete();
      if (needsConversion) {
        format = -1;
      }
      if (!success) {
        postMessage({ action: "transcode", success, id: event.data.id });
      } else {
        postMessage({ action: "transcode", success, id: event.data.id, fileInfo, format }, buffers);
      }
    }
  };
  function GetSupportedTranscodeFormat(config, fileInfo) {
    let format = null;
    if (config.supportedCompressionFormats) {
      if (config.supportedCompressionFormats.astc) {
        format = _BASIS_FORMAT.cTFASTC_4x4;
      } else if (config.supportedCompressionFormats.bc7) {
        format = _BASIS_FORMAT.cTFBC7;
      } else if (config.supportedCompressionFormats.s3tc) {
        format = fileInfo.hasAlpha ? _BASIS_FORMAT.cTFBC3 : _BASIS_FORMAT.cTFBC1;
      } else if (config.supportedCompressionFormats.pvrtc) {
        format = fileInfo.hasAlpha ? _BASIS_FORMAT.cTFPVRTC1_4_RGBA : _BASIS_FORMAT.cTFPVRTC1_4_RGB;
      } else if (config.supportedCompressionFormats.etc2) {
        format = _BASIS_FORMAT.cTFETC2;
      } else if (config.supportedCompressionFormats.etc1) {
        format = _BASIS_FORMAT.cTFETC1;
      } else {
        format = _BASIS_FORMAT.cTFRGB565;
      }
    }
    return format;
  }
  function GetFileInfo(basisFile) {
    const hasAlpha = basisFile.getHasAlpha();
    const imageCount = basisFile.getNumImages();
    const images = [];
    for (let i = 0; i < imageCount; i++) {
      const imageInfo = {
        levels: []
      };
      const levelCount = basisFile.getNumLevels(i);
      for (let level = 0; level < levelCount; level++) {
        const levelInfo = {
          width: basisFile.getImageWidth(i, level),
          height: basisFile.getImageHeight(i, level)
        };
        imageInfo.levels.push(levelInfo);
      }
      images.push(imageInfo);
    }
    const info = { hasAlpha, images };
    return info;
  }
  function TranscodeLevel(loadedFile, imageIndex, levelIndex, format, convertToRgb565) {
    const dstSize = loadedFile.getImageTranscodedSizeInBytes(imageIndex, levelIndex, format);
    let dst = new Uint8Array(dstSize);
    if (!loadedFile.transcodeImage(dst, imageIndex, levelIndex, format, 1, 0)) {
      return null;
    }
    if (convertToRgb565) {
      const alignedWidth = loadedFile.getImageWidth(imageIndex, levelIndex) + 3 & ~3;
      const alignedHeight = loadedFile.getImageHeight(imageIndex, levelIndex) + 3 & ~3;
      dst = ConvertDxtToRgb565(dst, 0, alignedWidth, alignedHeight);
    }
    return dst;
  }
  function ConvertDxtToRgb565(src, srcByteOffset, width, height) {
    const c = new Uint16Array(4);
    const dst = new Uint16Array(width * height);
    const blockWidth = width / 4;
    const blockHeight = height / 4;
    for (let blockY = 0; blockY < blockHeight; blockY++) {
      for (let blockX = 0; blockX < blockWidth; blockX++) {
        const i = srcByteOffset + 8 * (blockY * blockWidth + blockX);
        c[0] = src[i] | src[i + 1] << 8;
        c[1] = src[i + 2] | src[i + 3] << 8;
        c[2] = (2 * (c[0] & 31) + 1 * (c[1] & 31)) / 3 | (2 * (c[0] & 2016) + 1 * (c[1] & 2016)) / 3 & 2016 | (2 * (c[0] & 63488) + 1 * (c[1] & 63488)) / 3 & 63488;
        c[3] = (2 * (c[1] & 31) + 1 * (c[0] & 31)) / 3 | (2 * (c[1] & 2016) + 1 * (c[0] & 2016)) / 3 & 2016 | (2 * (c[1] & 63488) + 1 * (c[0] & 63488)) / 3 & 63488;
        for (let row = 0; row < 4; row++) {
          const m = src[i + 4 + row];
          let dstI = (blockY * 4 + row) * width + blockX * 4;
          dst[dstI++] = c[m & 3];
          dst[dstI++] = c[m >> 2 & 3];
          dst[dstI++] = c[m >> 4 & 3];
          dst[dstI++] = c[m >> 6 & 3];
        }
      }
    }
    return dst;
  }
}
function initializeWebWorker2(worker, wasmBinary, moduleUrl) {
  return new Promise((res, reject) => {
    const initHandler = (msg) => {
      if (msg.data.action === "init") {
        worker.removeEventListener("message", initHandler);
        res(worker);
      } else if (msg.data.action === "error") {
        reject(msg.data.error || "error initializing worker");
      }
    };
    worker.addEventListener("message", initHandler);
    worker.postMessage({ action: "init", url: moduleUrl ? Tools.GetBabylonScriptURL(moduleUrl) : void 0, wasmBinary }, [wasmBinary]);
  });
}

// node_modules/@babylonjs/core/Misc/basis.js
var BasisFileInfo = class {
};
var BasisTranscodeConfiguration = class {
};
var BASIS_FORMATS;
(function(BASIS_FORMATS2) {
  BASIS_FORMATS2[BASIS_FORMATS2["cTFETC1"] = 0] = "cTFETC1";
  BASIS_FORMATS2[BASIS_FORMATS2["cTFETC2"] = 1] = "cTFETC2";
  BASIS_FORMATS2[BASIS_FORMATS2["cTFBC1"] = 2] = "cTFBC1";
  BASIS_FORMATS2[BASIS_FORMATS2["cTFBC3"] = 3] = "cTFBC3";
  BASIS_FORMATS2[BASIS_FORMATS2["cTFBC4"] = 4] = "cTFBC4";
  BASIS_FORMATS2[BASIS_FORMATS2["cTFBC5"] = 5] = "cTFBC5";
  BASIS_FORMATS2[BASIS_FORMATS2["cTFBC7"] = 6] = "cTFBC7";
  BASIS_FORMATS2[BASIS_FORMATS2["cTFPVRTC1_4_RGB"] = 8] = "cTFPVRTC1_4_RGB";
  BASIS_FORMATS2[BASIS_FORMATS2["cTFPVRTC1_4_RGBA"] = 9] = "cTFPVRTC1_4_RGBA";
  BASIS_FORMATS2[BASIS_FORMATS2["cTFASTC_4x4"] = 10] = "cTFASTC_4x4";
  BASIS_FORMATS2[BASIS_FORMATS2["cTFATC_RGB"] = 11] = "cTFATC_RGB";
  BASIS_FORMATS2[BASIS_FORMATS2["cTFATC_RGBA_INTERPOLATED_ALPHA"] = 12] = "cTFATC_RGBA_INTERPOLATED_ALPHA";
  BASIS_FORMATS2[BASIS_FORMATS2["cTFRGBA32"] = 13] = "cTFRGBA32";
  BASIS_FORMATS2[BASIS_FORMATS2["cTFRGB565"] = 14] = "cTFRGB565";
  BASIS_FORMATS2[BASIS_FORMATS2["cTFBGR565"] = 15] = "cTFBGR565";
  BASIS_FORMATS2[BASIS_FORMATS2["cTFRGBA4444"] = 16] = "cTFRGBA4444";
  BASIS_FORMATS2[BASIS_FORMATS2["cTFFXT1_RGB"] = 17] = "cTFFXT1_RGB";
  BASIS_FORMATS2[BASIS_FORMATS2["cTFPVRTC2_4_RGB"] = 18] = "cTFPVRTC2_4_RGB";
  BASIS_FORMATS2[BASIS_FORMATS2["cTFPVRTC2_4_RGBA"] = 19] = "cTFPVRTC2_4_RGBA";
  BASIS_FORMATS2[BASIS_FORMATS2["cTFETC2_EAC_R11"] = 20] = "cTFETC2_EAC_R11";
  BASIS_FORMATS2[BASIS_FORMATS2["cTFETC2_EAC_RG11"] = 21] = "cTFETC2_EAC_RG11";
})(BASIS_FORMATS || (BASIS_FORMATS = {}));
var BasisToolsOptions = {
  /**
   * URL to use when loading the basis transcoder
   */
  JSModuleURL: `${Tools._DefaultCdnUrl}/basisTranscoder/1/basis_transcoder.js`,
  /**
   * URL to use when loading the wasm module for the transcoder
   */
  WasmModuleURL: `${Tools._DefaultCdnUrl}/basisTranscoder/1/basis_transcoder.wasm`
};
var GetInternalFormatFromBasisFormat = (basisFormat, engine) => {
  let format;
  switch (basisFormat) {
    case BASIS_FORMATS.cTFETC1:
      format = 36196;
      break;
    case BASIS_FORMATS.cTFBC1:
      format = 33776;
      break;
    case BASIS_FORMATS.cTFBC4:
      format = 33779;
      break;
    case BASIS_FORMATS.cTFASTC_4x4:
      format = 37808;
      break;
    case BASIS_FORMATS.cTFETC2:
      format = 37496;
      break;
    case BASIS_FORMATS.cTFBC7:
      format = 36492;
      break;
  }
  if (format === void 0) {
    throw "The chosen Basis transcoder format is not currently supported";
  }
  return format;
};
var _WorkerPromise = null;
var _Worker = null;
var _actionId = 0;
var _IgnoreSupportedFormats = false;
var _CreateWorkerAsync = () => {
  if (!_WorkerPromise) {
    _WorkerPromise = new Promise((res, reject) => {
      if (_Worker) {
        res(_Worker);
      } else {
        Tools.LoadFileAsync(Tools.GetBabylonScriptURL(BasisToolsOptions.WasmModuleURL)).then((wasmBinary) => {
          if (typeof URL !== "function") {
            return reject("Basis transcoder requires an environment with a URL constructor");
          }
          const workerBlobUrl = URL.createObjectURL(new Blob([`(${workerFunction2})()`], { type: "application/javascript" }));
          _Worker = new Worker(workerBlobUrl);
          initializeWebWorker2(_Worker, wasmBinary, BasisToolsOptions.JSModuleURL).then(res, reject);
        }).catch(reject);
      }
    });
  }
  return _WorkerPromise;
};
var SetBasisTranscoderWorker = (worker) => {
  _Worker = worker;
};
var TranscodeAsync = (data, config) => {
  const dataView = data instanceof ArrayBuffer ? new Uint8Array(data) : data;
  return new Promise((res, rej) => {
    _CreateWorkerAsync().then(() => {
      const actionId = _actionId++;
      const messageHandler = (msg) => {
        if (msg.data.action === "transcode" && msg.data.id === actionId) {
          _Worker.removeEventListener("message", messageHandler);
          if (!msg.data.success) {
            rej("Transcode is not supported on this device");
          } else {
            res(msg.data);
          }
        }
      };
      _Worker.addEventListener("message", messageHandler);
      const dataViewCopy = new Uint8Array(dataView.byteLength);
      dataViewCopy.set(new Uint8Array(dataView.buffer, dataView.byteOffset, dataView.byteLength));
      _Worker.postMessage({ action: "transcode", id: actionId, imageData: dataViewCopy, config, ignoreSupportedFormats: _IgnoreSupportedFormats }, [
        dataViewCopy.buffer
      ]);
    }, (error) => {
      rej(error);
    });
  });
};
var BindTexture = (texture, engine) => {
  var _a, _b;
  let target = (_a = engine._gl) == null ? void 0 : _a.TEXTURE_2D;
  if (texture.isCube) {
    target = (_b = engine._gl) == null ? void 0 : _b.TEXTURE_CUBE_MAP;
  }
  engine._bindTextureDirectly(target, texture, true);
};
var LoadTextureFromTranscodeResult = (texture, transcodeResult) => {
  const engine = texture.getEngine();
  for (let i = 0; i < transcodeResult.fileInfo.images.length; i++) {
    const rootImage = transcodeResult.fileInfo.images[i].levels[0];
    texture._invertVScale = texture.invertY;
    if (transcodeResult.format === -1 || transcodeResult.format === BASIS_FORMATS.cTFRGB565) {
      texture.type = 10;
      texture.format = 4;
      if (engine._features.basisNeedsPOT && (Scalar.Log2(rootImage.width) % 1 !== 0 || Scalar.Log2(rootImage.height) % 1 !== 0)) {
        const source = new InternalTexture(engine, InternalTextureSource.Temp);
        texture._invertVScale = texture.invertY;
        source.type = 10;
        source.format = 4;
        source.width = rootImage.width + 3 & ~3;
        source.height = rootImage.height + 3 & ~3;
        BindTexture(source, engine);
        engine._uploadDataToTextureDirectly(source, new Uint16Array(rootImage.transcodedPixels.buffer), i, 0, 4, true);
        engine._rescaleTexture(source, texture, engine.scenes[0], engine._getInternalFormat(4), () => {
          engine._releaseTexture(source);
          BindTexture(texture, engine);
        });
      } else {
        texture._invertVScale = !texture.invertY;
        texture.width = rootImage.width + 3 & ~3;
        texture.height = rootImage.height + 3 & ~3;
        texture.samplingMode = 2;
        BindTexture(texture, engine);
        engine._uploadDataToTextureDirectly(texture, new Uint16Array(rootImage.transcodedPixels.buffer), i, 0, 4, true);
      }
    } else {
      texture.width = rootImage.width;
      texture.height = rootImage.height;
      texture.generateMipMaps = transcodeResult.fileInfo.images[i].levels.length > 1;
      const format = BasisTools.GetInternalFormatFromBasisFormat(transcodeResult.format, engine);
      texture.format = format;
      BindTexture(texture, engine);
      transcodeResult.fileInfo.images[i].levels.forEach((level, index) => {
        engine._uploadCompressedDataToTextureDirectly(texture, format, level.width, level.height, level.transcodedPixels, i, index);
      });
      if (engine._features.basisNeedsPOT && (Scalar.Log2(texture.width) % 1 !== 0 || Scalar.Log2(texture.height) % 1 !== 0)) {
        Tools.Warn("Loaded .basis texture width and height are not a power of two. Texture wrapping will be set to Texture.CLAMP_ADDRESSMODE as other modes are not supported with non power of two dimensions in webGL 1.");
        texture._cachedWrapU = Texture.CLAMP_ADDRESSMODE;
        texture._cachedWrapV = Texture.CLAMP_ADDRESSMODE;
      }
    }
  }
};
var BasisTools = {
  /**
   * URL to use when loading the basis transcoder
   */
  JSModuleURL: BasisToolsOptions.JSModuleURL,
  /**
   * URL to use when loading the wasm module for the transcoder
   */
  WasmModuleURL: BasisToolsOptions.WasmModuleURL,
  /**
   * Get the internal format to be passed to texImage2D corresponding to the .basis format value
   * @param basisFormat format chosen from GetSupportedTranscodeFormat
   * @returns internal format corresponding to the Basis format
   */
  GetInternalFormatFromBasisFormat,
  /**
   * Transcodes a loaded image file to compressed pixel data
   * @param data image data to transcode
   * @param config configuration options for the transcoding
   * @returns a promise resulting in the transcoded image
   */
  TranscodeAsync,
  /**
   * Loads a texture from the transcode result
   * @param texture texture load to
   * @param transcodeResult the result of transcoding the basis file to load from
   */
  LoadTextureFromTranscodeResult
};
Object.defineProperty(BasisTools, "JSModuleURL", {
  get: function() {
    return BasisToolsOptions.JSModuleURL;
  },
  set: function(value) {
    BasisToolsOptions.JSModuleURL = value;
  }
});
Object.defineProperty(BasisTools, "WasmModuleURL", {
  get: function() {
    return BasisToolsOptions.WasmModuleURL;
  },
  set: function(value) {
    BasisToolsOptions.WasmModuleURL = value;
  }
});

// node_modules/@babylonjs/core/Materials/Textures/Loaders/basisTextureLoader.js
var _BasisTextureLoader = class {
  constructor() {
    this.supportCascades = false;
  }
  /**
   * This returns if the loader support the current file information.
   * @param extension defines the file extension of the file being loaded
   * @returns true if the loader can load the specified file
   */
  canLoad(extension) {
    return extension.endsWith(".basis");
  }
  /**
   * Uploads the cube texture data to the WebGL texture. It has already been bound.
   * @param data contains the texture data
   * @param texture defines the BabylonJS internal texture
   * @param createPolynomials will be true if polynomials have been requested
   * @param onLoad defines the callback to trigger once the texture is ready
   * @param onError defines the callback to trigger in case of error
   */
  loadCubeData(data, texture, createPolynomials, onLoad, onError) {
    if (Array.isArray(data)) {
      return;
    }
    const caps = texture.getEngine().getCaps();
    const transcodeConfig = {
      supportedCompressionFormats: {
        etc1: caps.etc1 ? true : false,
        s3tc: caps.s3tc ? true : false,
        pvrtc: caps.pvrtc ? true : false,
        etc2: caps.etc2 ? true : false,
        astc: caps.astc ? true : false,
        bc7: caps.bptc ? true : false
      }
    };
    TranscodeAsync(data, transcodeConfig).then((result) => {
      const hasMipmap = result.fileInfo.images[0].levels.length > 1 && texture.generateMipMaps;
      LoadTextureFromTranscodeResult(texture, result);
      texture.getEngine()._setCubeMapTextureParams(texture, hasMipmap);
      texture.isReady = true;
      texture.onLoadedObservable.notifyObservers(texture);
      texture.onLoadedObservable.clear();
      if (onLoad) {
        onLoad();
      }
    }).catch((err) => {
      const errorMessage = "Failed to transcode Basis file, transcoding may not be supported on this device";
      Tools.Warn(errorMessage);
      texture.isReady = true;
      if (onError) {
        onError(err);
      }
    });
  }
  /**
   * Uploads the 2D texture data to the WebGL texture. It has already been bound once in the callback.
   * @param data contains the texture data
   * @param texture defines the BabylonJS internal texture
   * @param callback defines the method to call once ready to upload
   */
  loadData(data, texture, callback) {
    const caps = texture.getEngine().getCaps();
    const transcodeConfig = {
      supportedCompressionFormats: {
        etc1: caps.etc1 ? true : false,
        s3tc: caps.s3tc ? true : false,
        pvrtc: caps.pvrtc ? true : false,
        etc2: caps.etc2 ? true : false,
        astc: caps.astc ? true : false,
        bc7: caps.bptc ? true : false
      }
    };
    TranscodeAsync(data, transcodeConfig).then((result) => {
      const rootImage = result.fileInfo.images[0].levels[0];
      const hasMipmap = result.fileInfo.images[0].levels.length > 1 && texture.generateMipMaps;
      callback(rootImage.width, rootImage.height, hasMipmap, result.format !== -1, () => {
        LoadTextureFromTranscodeResult(texture, result);
      });
    }).catch((err) => {
      Tools.Warn("Failed to transcode Basis file, transcoding may not be supported on this device");
      Tools.Warn(`Failed to transcode Basis file: ${err}`);
      callback(0, 0, false, false, () => {
      }, true);
    });
  }
};
Engine._TextureLoaders.push(new _BasisTextureLoader());

export {
  DDSTools,
  _DDSTextureLoader,
  _ENVTextureLoader,
  KhronosTextureContainer,
  SourceTextureFormat,
  TranscodeTarget,
  EngineFormat,
  DefaultKTX2DecoderOptions,
  KhronosTextureContainer2,
  _KTXTextureLoader,
  GetTGAHeader,
  UploadContent,
  TGATools,
  _TGATextureLoader,
  PanoramaToCubeMapTools,
  HDRTools,
  _HDRTextureLoader,
  BasisFileInfo,
  BasisTranscodeConfiguration,
  BasisToolsOptions,
  GetInternalFormatFromBasisFormat,
  SetBasisTranscoderWorker,
  TranscodeAsync,
  LoadTextureFromTranscodeResult,
  BasisTools,
  _BasisTextureLoader
};
//# sourceMappingURL=chunk-DKV5TYPM.js.map
