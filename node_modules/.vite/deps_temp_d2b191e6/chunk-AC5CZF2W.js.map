{
  "version": 3,
  "sources": ["../../../dev/core/src/Shaders/passCube.fragment.ts", "../../../dev/core/src/PostProcesses/passPostProcess.ts", "../../../dev/core/src/Maths/sphericalPolynomial.ts", "../../../dev/core/src/Misc/textureTools.ts", "../../../dev/core/src/Shaders/rgbdDecode.fragment.ts", "../../../dev/core/src/Misc/rgbdTextureTools.ts", "../../../dev/core/src/Misc/HighDynamicRange/cubemapToSphericalPolynomial.ts", "../../../dev/core/src/Materials/Textures/baseTexture.polynomial.ts", "../../../dev/core/src/Shaders/rgbdEncode.fragment.ts", "../../../dev/core/src/Misc/environmentTextureTools.ts", "../../../dev/core/src/Misc/workerPool.ts", "../../../dev/core/src/Engines/Extensions/engine.cubeTexture.ts"],
  "sourcesContent": ["// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore\";\n\nconst name = \"passCubePixelShader\";\nconst shader = `varying vec2 vUV;uniform samplerCube textureSampler;\n#define CUSTOM_FRAGMENT_DEFINITIONS\nvoid main(void) \n{vec2 uv=vUV*2.0-1.0;\n#ifdef POSITIVEX\ngl_FragColor=textureCube(textureSampler,vec3(1.001,uv.y,uv.x));\n#endif\n#ifdef NEGATIVEX\ngl_FragColor=textureCube(textureSampler,vec3(-1.001,uv.y,uv.x));\n#endif\n#ifdef POSITIVEY\ngl_FragColor=textureCube(textureSampler,vec3(uv.y,1.001,uv.x));\n#endif\n#ifdef NEGATIVEY\ngl_FragColor=textureCube(textureSampler,vec3(uv.y,-1.001,uv.x));\n#endif\n#ifdef POSITIVEZ\ngl_FragColor=textureCube(textureSampler,vec3(uv,1.001));\n#endif\n#ifdef NEGATIVEZ\ngl_FragColor=textureCube(textureSampler,vec3(uv,-1.001));\n#endif\n}`;\n// Sideeffect\nShaderStore.ShadersStore[name] = shader;\n/** @internal */\nexport const passCubePixelShader = { name, shader };\n", "import type { Nullable } from \"../types\";\r\nimport { Constants } from \"../Engines/constants\";\r\nimport type { Camera } from \"../Cameras/camera\";\r\nimport type { PostProcessOptions } from \"./postProcess\";\r\nimport { PostProcess } from \"./postProcess\";\r\nimport { Engine } from \"../Engines/engine\";\r\n\r\nimport \"../Shaders/pass.fragment\";\r\nimport \"../Shaders/passCube.fragment\";\r\nimport { RegisterClass } from \"../Misc/typeStore\";\r\nimport { SerializationHelper } from \"../Misc/decorators.serialization\";\r\n\r\nimport type { Scene } from \"../scene\";\r\n\r\n/**\r\n * PassPostProcess which produces an output the same as it's input\r\n */\r\nexport class PassPostProcess extends PostProcess {\r\n    /**\r\n     * Gets a string identifying the name of the class\r\n     * @returns \"PassPostProcess\" string\r\n     */\r\n    public getClassName(): string {\r\n        return \"PassPostProcess\";\r\n    }\r\n\r\n    /**\r\n     * Creates the PassPostProcess\r\n     * @param name The name of the effect.\r\n     * @param options The required width/height ratio to downsize to before computing the render pass.\r\n     * @param camera The camera to apply the render pass to.\r\n     * @param samplingMode The sampling mode to be used when computing the pass. (default: 0)\r\n     * @param engine The engine which the post process will be applied. (default: current engine)\r\n     * @param reusable If the post process can be reused on the same frame. (default: false)\r\n     * @param textureType The type of texture to be used when performing the post processing.\r\n     * @param blockCompilation If compilation of the shader should not be done in the constructor. The updateEffect method can be used to compile the shader at a later time. (default: false)\r\n     */\r\n    constructor(\r\n        name: string,\r\n        options: number | PostProcessOptions,\r\n        camera: Nullable<Camera> = null,\r\n        samplingMode?: number,\r\n        engine?: Engine,\r\n        reusable?: boolean,\r\n        textureType: number = Constants.TEXTURETYPE_UNSIGNED_INT,\r\n        blockCompilation = false\r\n    ) {\r\n        super(name, \"pass\", null, null, options, camera, samplingMode, engine, reusable, undefined, textureType, undefined, null, blockCompilation);\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public static _Parse(parsedPostProcess: any, targetCamera: Camera, scene: Scene, rootUrl: string) {\r\n        return SerializationHelper.Parse(\r\n            () => {\r\n                return new PassPostProcess(\r\n                    parsedPostProcess.name,\r\n                    parsedPostProcess.options,\r\n                    targetCamera,\r\n                    parsedPostProcess.renderTargetSamplingMode,\r\n                    parsedPostProcess._engine,\r\n                    parsedPostProcess.reusable\r\n                );\r\n            },\r\n            parsedPostProcess,\r\n            scene,\r\n            rootUrl\r\n        );\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.PassPostProcess\", PassPostProcess);\r\n\r\n/**\r\n * PassCubePostProcess which produces an output the same as it's input (which must be a cube texture)\r\n */\r\nexport class PassCubePostProcess extends PostProcess {\r\n    private _face = 0;\r\n\r\n    /**\r\n     * Gets or sets the cube face to display.\r\n     *  * 0 is +X\r\n     *  * 1 is -X\r\n     *  * 2 is +Y\r\n     *  * 3 is -Y\r\n     *  * 4 is +Z\r\n     *  * 5 is -Z\r\n     */\r\n    public get face(): number {\r\n        return this._face;\r\n    }\r\n\r\n    public set face(value: number) {\r\n        if (value < 0 || value > 5) {\r\n            return;\r\n        }\r\n\r\n        this._face = value;\r\n        switch (this._face) {\r\n            case 0:\r\n                this.updateEffect(\"#define POSITIVEX\");\r\n                break;\r\n            case 1:\r\n                this.updateEffect(\"#define NEGATIVEX\");\r\n                break;\r\n            case 2:\r\n                this.updateEffect(\"#define POSITIVEY\");\r\n                break;\r\n            case 3:\r\n                this.updateEffect(\"#define NEGATIVEY\");\r\n                break;\r\n            case 4:\r\n                this.updateEffect(\"#define POSITIVEZ\");\r\n                break;\r\n            case 5:\r\n                this.updateEffect(\"#define NEGATIVEZ\");\r\n                break;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets a string identifying the name of the class\r\n     * @returns \"PassCubePostProcess\" string\r\n     */\r\n    public getClassName(): string {\r\n        return \"PassCubePostProcess\";\r\n    }\r\n\r\n    /**\r\n     * Creates the PassCubePostProcess\r\n     * @param name The name of the effect.\r\n     * @param options The required width/height ratio to downsize to before computing the render pass.\r\n     * @param camera The camera to apply the render pass to.\r\n     * @param samplingMode The sampling mode to be used when computing the pass. (default: 0)\r\n     * @param engine The engine which the post process will be applied. (default: current engine)\r\n     * @param reusable If the post process can be reused on the same frame. (default: false)\r\n     * @param textureType The type of texture to be used when performing the post processing.\r\n     * @param blockCompilation If compilation of the shader should not be done in the constructor. The updateEffect method can be used to compile the shader at a later time. (default: false)\r\n     */\r\n    constructor(\r\n        name: string,\r\n        options: number | PostProcessOptions,\r\n        camera: Nullable<Camera> = null,\r\n        samplingMode?: number,\r\n        engine?: Engine,\r\n        reusable?: boolean,\r\n        textureType: number = Constants.TEXTURETYPE_UNSIGNED_INT,\r\n        blockCompilation = false\r\n    ) {\r\n        super(name, \"passCube\", null, null, options, camera, samplingMode, engine, reusable, \"#define POSITIVEX\", textureType, undefined, null, blockCompilation);\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public static _Parse(parsedPostProcess: any, targetCamera: Camera, scene: Scene, rootUrl: string) {\r\n        return SerializationHelper.Parse(\r\n            () => {\r\n                return new PassCubePostProcess(\r\n                    parsedPostProcess.name,\r\n                    parsedPostProcess.options,\r\n                    targetCamera,\r\n                    parsedPostProcess.renderTargetSamplingMode,\r\n                    parsedPostProcess._engine,\r\n                    parsedPostProcess.reusable\r\n                );\r\n            },\r\n            parsedPostProcess,\r\n            scene,\r\n            rootUrl\r\n        );\r\n    }\r\n}\r\n\r\nEngine._RescalePostProcessFactory = (engine: Engine) => {\r\n    return new PassPostProcess(\"rescale\", 1, null, Constants.TEXTURE_BILINEAR_SAMPLINGMODE, engine, false, Constants.TEXTURETYPE_UNSIGNED_INT);\r\n};\r\n", "/* eslint-disable @typescript-eslint/naming-convention */\r\nimport { Vector3 } from \"../Maths/math.vector\";\r\nimport type { Nullable } from \"../types\";\r\nimport type { Color3 } from \"../Maths/math.color\";\r\nimport { TmpVectors } from \"./math\";\r\n\r\n// https://dickyjim.wordpress.com/2013/09/04/spherical-harmonics-for-beginners/\r\n// http://silviojemma.com/public/papers/lighting/spherical-harmonic-lighting.pdf\r\n// https://www.ppsloan.org/publications/StupidSH36.pdf\r\n// http://cseweb.ucsd.edu/~ravir/papers/envmap/envmap.pdf\r\n// https://www.ppsloan.org/publications/SHJCGT.pdf\r\n// https://www.ppsloan.org/publications/shdering.pdf\r\n// https://google.github.io/filament/Filament.md.html#annex/sphericalharmonics\r\n// https://patapom.com/blog/SHPortal/\r\n// https://imdoingitwrong.wordpress.com/2011/04/14/spherical-harmonics-wtf/\r\n\r\n// Using real SH basis:\r\n//  m>0             m   m\r\n// y   = sqrt(2) * K * P * cos(m*phi) * cos(theta)\r\n//  l               l   l\r\n//\r\n//  m<0             m   |m|\r\n// y   = sqrt(2) * K * P * sin(m*phi) * cos(theta)\r\n//  l               l   l\r\n//\r\n//  m=0   0   0\r\n// y   = K * P * trigono terms\r\n//  l     l   l\r\n//\r\n//  m       (2l + 1)(l - |m|)!\r\n// K = sqrt(------------------)\r\n//  l           4pi(l + |m|)!\r\n//\r\n// and P by recursion:\r\n//\r\n// P00(x) = 1\r\n// P01(x) = x\r\n// Pll(x) = (-1^l)(2l - 1)!!(1-x*x)^(1/2)\r\n//          ((2l - 1)x[Pl-1/m]-(l + m - 1)[Pl-2/m])\r\n// Plm(x) = ---------------------------------------\r\n//                         l - m\r\n// Leaving the trigonometric terms aside we can precompute the constants to :\r\nconst SH3ylmBasisConstants = [\r\n    Math.sqrt(1 / (4 * Math.PI)), // l00\r\n\r\n    -Math.sqrt(3 / (4 * Math.PI)), // l1_1\r\n    Math.sqrt(3 / (4 * Math.PI)), // l10\r\n    -Math.sqrt(3 / (4 * Math.PI)), // l11\r\n\r\n    Math.sqrt(15 / (4 * Math.PI)), // l2_2\r\n    -Math.sqrt(15 / (4 * Math.PI)), // l2_1\r\n    Math.sqrt(5 / (16 * Math.PI)), // l20\r\n    -Math.sqrt(15 / (4 * Math.PI)), // l21\r\n    Math.sqrt(15 / (16 * Math.PI)), // l22\r\n];\r\n\r\n// cm = cos(m * phi)\r\n// sm = sin(m * phi)\r\n// {x,y,z} = {cos(phi)sin(theta), sin(phi)sin(theta), cos(theta)}\r\n// By recursion on using trigo identities:\r\nconst SH3ylmBasisTrigonometricTerms = [\r\n    () => 1, // l00\r\n\r\n    (direction: Vector3) => direction.y, // l1_1\r\n    (direction: Vector3) => direction.z, // l10\r\n    (direction: Vector3) => direction.x, // l11\r\n\r\n    (direction: Vector3) => direction.x * direction.y, // l2_2\r\n    (direction: Vector3) => direction.y * direction.z, // l2_1\r\n    (direction: Vector3) => 3 * direction.z * direction.z - 1, // l20\r\n    (direction: Vector3) => direction.x * direction.z, // l21\r\n    (direction: Vector3) => direction.x * direction.x - direction.y * direction.y, // l22\r\n];\r\n\r\n// Wrap the full compute\r\nconst applySH3 = (lm: number, direction: Vector3) => {\r\n    return SH3ylmBasisConstants[lm] * SH3ylmBasisTrigonometricTerms[lm](direction);\r\n};\r\n\r\n// Derived from the integration of the a kernel convolution to SH.\r\n// Great explanation here: https://patapom.com/blog/SHPortal/#about-distant-radiance-and-irradiance-environments\r\nconst SHCosKernelConvolution = [Math.PI, (2 * Math.PI) / 3, (2 * Math.PI) / 3, (2 * Math.PI) / 3, Math.PI / 4, Math.PI / 4, Math.PI / 4, Math.PI / 4, Math.PI / 4];\r\n\r\n/**\r\n * Class representing spherical harmonics coefficients to the 3rd degree\r\n */\r\nexport class SphericalHarmonics {\r\n    /**\r\n     * Defines whether or not the harmonics have been prescaled for rendering.\r\n     */\r\n    public preScaled = false;\r\n\r\n    /**\r\n     * The l0,0 coefficients of the spherical harmonics\r\n     */\r\n    public l00: Vector3 = Vector3.Zero();\r\n\r\n    /**\r\n     * The l1,-1 coefficients of the spherical harmonics\r\n     */\r\n    public l1_1: Vector3 = Vector3.Zero();\r\n\r\n    /**\r\n     * The l1,0 coefficients of the spherical harmonics\r\n     */\r\n    public l10: Vector3 = Vector3.Zero();\r\n\r\n    /**\r\n     * The l1,1 coefficients of the spherical harmonics\r\n     */\r\n    public l11: Vector3 = Vector3.Zero();\r\n\r\n    /**\r\n     * The l2,-2 coefficients of the spherical harmonics\r\n     */\r\n    public l2_2: Vector3 = Vector3.Zero();\r\n\r\n    /**\r\n     * The l2,-1 coefficients of the spherical harmonics\r\n     */\r\n    public l2_1: Vector3 = Vector3.Zero();\r\n\r\n    /**\r\n     * The l2,0 coefficients of the spherical harmonics\r\n     */\r\n    public l20: Vector3 = Vector3.Zero();\r\n\r\n    /**\r\n     * The l2,1 coefficients of the spherical harmonics\r\n     */\r\n    public l21: Vector3 = Vector3.Zero();\r\n\r\n    /**\r\n     * The l2,2 coefficients of the spherical harmonics\r\n     */\r\n    public l22: Vector3 = Vector3.Zero();\r\n\r\n    /**\r\n     * Adds a light to the spherical harmonics\r\n     * @param direction the direction of the light\r\n     * @param color the color of the light\r\n     * @param deltaSolidAngle the delta solid angle of the light\r\n     */\r\n    public addLight(direction: Vector3, color: Color3, deltaSolidAngle: number): void {\r\n        TmpVectors.Vector3[0].set(color.r, color.g, color.b);\r\n        const colorVector = TmpVectors.Vector3[0];\r\n        const c = TmpVectors.Vector3[1];\r\n        colorVector.scaleToRef(deltaSolidAngle, c);\r\n\r\n        c.scaleToRef(applySH3(0, direction), TmpVectors.Vector3[2]);\r\n        this.l00.addInPlace(TmpVectors.Vector3[2]);\r\n\r\n        c.scaleToRef(applySH3(1, direction), TmpVectors.Vector3[2]);\r\n        this.l1_1.addInPlace(TmpVectors.Vector3[2]);\r\n        c.scaleToRef(applySH3(2, direction), TmpVectors.Vector3[2]);\r\n        this.l10.addInPlace(TmpVectors.Vector3[2]);\r\n        c.scaleToRef(applySH3(3, direction), TmpVectors.Vector3[2]);\r\n        this.l11.addInPlace(TmpVectors.Vector3[2]);\r\n\r\n        c.scaleToRef(applySH3(4, direction), TmpVectors.Vector3[2]);\r\n        this.l2_2.addInPlace(TmpVectors.Vector3[2]);\r\n        c.scaleToRef(applySH3(5, direction), TmpVectors.Vector3[2]);\r\n        this.l2_1.addInPlace(TmpVectors.Vector3[2]);\r\n        c.scaleToRef(applySH3(6, direction), TmpVectors.Vector3[2]);\r\n        this.l20.addInPlace(TmpVectors.Vector3[2]);\r\n        c.scaleToRef(applySH3(7, direction), TmpVectors.Vector3[2]);\r\n        this.l21.addInPlace(TmpVectors.Vector3[2]);\r\n        c.scaleToRef(applySH3(8, direction), TmpVectors.Vector3[2]);\r\n        this.l22.addInPlace(TmpVectors.Vector3[2]);\r\n    }\r\n\r\n    /**\r\n     * Scales the spherical harmonics by the given amount\r\n     * @param scale the amount to scale\r\n     */\r\n    public scaleInPlace(scale: number): void {\r\n        this.l00.scaleInPlace(scale);\r\n        this.l1_1.scaleInPlace(scale);\r\n        this.l10.scaleInPlace(scale);\r\n        this.l11.scaleInPlace(scale);\r\n        this.l2_2.scaleInPlace(scale);\r\n        this.l2_1.scaleInPlace(scale);\r\n        this.l20.scaleInPlace(scale);\r\n        this.l21.scaleInPlace(scale);\r\n        this.l22.scaleInPlace(scale);\r\n    }\r\n\r\n    /**\r\n     * Convert from incident radiance (Li) to irradiance (E) by applying convolution with the cosine-weighted hemisphere.\r\n     *\r\n     * ```\r\n     * E_lm = A_l * L_lm\r\n     * ```\r\n     *\r\n     * In spherical harmonics this convolution amounts to scaling factors for each frequency band.\r\n     * This corresponds to equation 5 in \"An Efficient Representation for Irradiance Environment Maps\", where\r\n     * the scaling factors are given in equation 9.\r\n     */\r\n    public convertIncidentRadianceToIrradiance(): void {\r\n        // Constant (Band 0)\r\n        this.l00.scaleInPlace(SHCosKernelConvolution[0]);\r\n\r\n        // Linear (Band 1)\r\n        this.l1_1.scaleInPlace(SHCosKernelConvolution[1]);\r\n        this.l10.scaleInPlace(SHCosKernelConvolution[2]);\r\n        this.l11.scaleInPlace(SHCosKernelConvolution[3]);\r\n\r\n        // Quadratic (Band 2)\r\n        this.l2_2.scaleInPlace(SHCosKernelConvolution[4]);\r\n        this.l2_1.scaleInPlace(SHCosKernelConvolution[5]);\r\n        this.l20.scaleInPlace(SHCosKernelConvolution[6]);\r\n        this.l21.scaleInPlace(SHCosKernelConvolution[7]);\r\n        this.l22.scaleInPlace(SHCosKernelConvolution[8]);\r\n    }\r\n\r\n    /**\r\n     * Convert from irradiance to outgoing radiance for Lambertian BDRF, suitable for efficient shader evaluation.\r\n     *\r\n     * ```\r\n     * L = (1/pi) * E * rho\r\n     * ```\r\n     *\r\n     * This is done by an additional scale by 1/pi, so is a fairly trivial operation but important conceptually.\r\n     */\r\n    public convertIrradianceToLambertianRadiance(): void {\r\n        this.scaleInPlace(1.0 / Math.PI);\r\n\r\n        // The resultant SH now represents outgoing radiance, so includes the Lambert 1/pi normalisation factor but without albedo (rho) applied\r\n        // (The pixel shader must apply albedo after texture fetches, etc).\r\n    }\r\n\r\n    /**\r\n     * Integrates the reconstruction coefficients directly in to the SH preventing further\r\n     * required operations at run time.\r\n     *\r\n     * This is simply done by scaling back the SH with Ylm constants parameter.\r\n     * The trigonometric part being applied by the shader at run time.\r\n     */\r\n    public preScaleForRendering(): void {\r\n        this.preScaled = true;\r\n\r\n        this.l00.scaleInPlace(SH3ylmBasisConstants[0]);\r\n\r\n        this.l1_1.scaleInPlace(SH3ylmBasisConstants[1]);\r\n        this.l10.scaleInPlace(SH3ylmBasisConstants[2]);\r\n        this.l11.scaleInPlace(SH3ylmBasisConstants[3]);\r\n\r\n        this.l2_2.scaleInPlace(SH3ylmBasisConstants[4]);\r\n        this.l2_1.scaleInPlace(SH3ylmBasisConstants[5]);\r\n        this.l20.scaleInPlace(SH3ylmBasisConstants[6]);\r\n        this.l21.scaleInPlace(SH3ylmBasisConstants[7]);\r\n        this.l22.scaleInPlace(SH3ylmBasisConstants[8]);\r\n    }\r\n\r\n    /**\r\n     * update the spherical harmonics coefficients from the given array\r\n     * @param data defines the 9x3 coefficients (l00, l1-1, l10, l11, l2-2, l2-1, l20, l21, l22)\r\n     * @returns the spherical harmonics (this)\r\n     */\r\n    public updateFromArray(data: ArrayLike<ArrayLike<number>>): SphericalHarmonics {\r\n        Vector3.FromArrayToRef(data[0], 0, this.l00);\r\n        Vector3.FromArrayToRef(data[1], 0, this.l1_1);\r\n        Vector3.FromArrayToRef(data[2], 0, this.l10);\r\n        Vector3.FromArrayToRef(data[3], 0, this.l11);\r\n        Vector3.FromArrayToRef(data[4], 0, this.l2_2);\r\n        Vector3.FromArrayToRef(data[5], 0, this.l2_1);\r\n        Vector3.FromArrayToRef(data[6], 0, this.l20);\r\n        Vector3.FromArrayToRef(data[7], 0, this.l21);\r\n        Vector3.FromArrayToRef(data[8], 0, this.l22);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * update the spherical harmonics coefficients from the given floats array\r\n     * @param data defines the 9x3 coefficients (l00, l1-1, l10, l11, l2-2, l2-1, l20, l21, l22)\r\n     * @returns the spherical harmonics (this)\r\n     */\r\n    public updateFromFloatsArray(data: ArrayLike<number>): SphericalHarmonics {\r\n        Vector3.FromFloatsToRef(data[0], data[1], data[2], this.l00);\r\n        Vector3.FromFloatsToRef(data[3], data[4], data[5], this.l1_1);\r\n        Vector3.FromFloatsToRef(data[6], data[7], data[8], this.l10);\r\n        Vector3.FromFloatsToRef(data[9], data[10], data[11], this.l11);\r\n        Vector3.FromFloatsToRef(data[12], data[13], data[14], this.l2_2);\r\n        Vector3.FromFloatsToRef(data[15], data[16], data[17], this.l2_1);\r\n        Vector3.FromFloatsToRef(data[18], data[19], data[20], this.l20);\r\n        Vector3.FromFloatsToRef(data[21], data[22], data[23], this.l21);\r\n        Vector3.FromFloatsToRef(data[24], data[25], data[26], this.l22);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Constructs a spherical harmonics from an array.\r\n     * @param data defines the 9x3 coefficients (l00, l1-1, l10, l11, l2-2, l2-1, l20, l21, l22)\r\n     * @returns the spherical harmonics\r\n     */\r\n    public static FromArray(data: ArrayLike<ArrayLike<number>>): SphericalHarmonics {\r\n        const sh = new SphericalHarmonics();\r\n        return sh.updateFromArray(data);\r\n    }\r\n\r\n    // Keep for references.\r\n    /**\r\n     * Gets the spherical harmonics from polynomial\r\n     * @param polynomial the spherical polynomial\r\n     * @returns the spherical harmonics\r\n     */\r\n    public static FromPolynomial(polynomial: SphericalPolynomial): SphericalHarmonics {\r\n        const result = new SphericalHarmonics();\r\n\r\n        result.l00 = polynomial.xx.scale(0.376127).add(polynomial.yy.scale(0.376127)).add(polynomial.zz.scale(0.376126));\r\n        result.l1_1 = polynomial.y.scale(0.977204);\r\n        result.l10 = polynomial.z.scale(0.977204);\r\n        result.l11 = polynomial.x.scale(0.977204);\r\n        result.l2_2 = polynomial.xy.scale(1.16538);\r\n        result.l2_1 = polynomial.yz.scale(1.16538);\r\n        result.l20 = polynomial.zz.scale(1.34567).subtract(polynomial.xx.scale(0.672834)).subtract(polynomial.yy.scale(0.672834));\r\n        result.l21 = polynomial.zx.scale(1.16538);\r\n        result.l22 = polynomial.xx.scale(1.16538).subtract(polynomial.yy.scale(1.16538));\r\n\r\n        result.l1_1.scaleInPlace(-1);\r\n        result.l11.scaleInPlace(-1);\r\n        result.l2_1.scaleInPlace(-1);\r\n        result.l21.scaleInPlace(-1);\r\n\r\n        result.scaleInPlace(Math.PI);\r\n\r\n        return result;\r\n    }\r\n}\r\n\r\n/**\r\n * Class representing spherical polynomial coefficients to the 3rd degree\r\n */\r\nexport class SphericalPolynomial {\r\n    private _harmonics: Nullable<SphericalHarmonics>;\r\n\r\n    /**\r\n     * The spherical harmonics used to create the polynomials.\r\n     */\r\n    public get preScaledHarmonics(): SphericalHarmonics {\r\n        if (!this._harmonics) {\r\n            this._harmonics = SphericalHarmonics.FromPolynomial(this);\r\n        }\r\n        if (!this._harmonics.preScaled) {\r\n            this._harmonics.preScaleForRendering();\r\n        }\r\n        return this._harmonics;\r\n    }\r\n\r\n    /**\r\n     * The x coefficients of the spherical polynomial\r\n     */\r\n    public x: Vector3 = Vector3.Zero();\r\n\r\n    /**\r\n     * The y coefficients of the spherical polynomial\r\n     */\r\n    public y: Vector3 = Vector3.Zero();\r\n\r\n    /**\r\n     * The z coefficients of the spherical polynomial\r\n     */\r\n    public z: Vector3 = Vector3.Zero();\r\n\r\n    /**\r\n     * The xx coefficients of the spherical polynomial\r\n     */\r\n    public xx: Vector3 = Vector3.Zero();\r\n\r\n    /**\r\n     * The yy coefficients of the spherical polynomial\r\n     */\r\n    public yy: Vector3 = Vector3.Zero();\r\n\r\n    /**\r\n     * The zz coefficients of the spherical polynomial\r\n     */\r\n    public zz: Vector3 = Vector3.Zero();\r\n\r\n    /**\r\n     * The xy coefficients of the spherical polynomial\r\n     */\r\n    public xy: Vector3 = Vector3.Zero();\r\n\r\n    /**\r\n     * The yz coefficients of the spherical polynomial\r\n     */\r\n    public yz: Vector3 = Vector3.Zero();\r\n\r\n    /**\r\n     * The zx coefficients of the spherical polynomial\r\n     */\r\n    public zx: Vector3 = Vector3.Zero();\r\n\r\n    /**\r\n     * Adds an ambient color to the spherical polynomial\r\n     * @param color the color to add\r\n     */\r\n    public addAmbient(color: Color3): void {\r\n        TmpVectors.Vector3[0].copyFromFloats(color.r, color.g, color.b);\r\n        const colorVector = TmpVectors.Vector3[0];\r\n        this.xx.addInPlace(colorVector);\r\n        this.yy.addInPlace(colorVector);\r\n        this.zz.addInPlace(colorVector);\r\n    }\r\n\r\n    /**\r\n     * Scales the spherical polynomial by the given amount\r\n     * @param scale the amount to scale\r\n     */\r\n    public scaleInPlace(scale: number) {\r\n        this.x.scaleInPlace(scale);\r\n        this.y.scaleInPlace(scale);\r\n        this.z.scaleInPlace(scale);\r\n        this.xx.scaleInPlace(scale);\r\n        this.yy.scaleInPlace(scale);\r\n        this.zz.scaleInPlace(scale);\r\n        this.yz.scaleInPlace(scale);\r\n        this.zx.scaleInPlace(scale);\r\n        this.xy.scaleInPlace(scale);\r\n    }\r\n\r\n    /**\r\n     * Updates the spherical polynomial from harmonics\r\n     * @param harmonics the spherical harmonics\r\n     * @returns the spherical polynomial\r\n     */\r\n    public updateFromHarmonics(harmonics: SphericalHarmonics): SphericalPolynomial {\r\n        this._harmonics = harmonics;\r\n\r\n        this.x.copyFrom(harmonics.l11);\r\n        this.x.scaleInPlace(1.02333).scaleInPlace(-1);\r\n        this.y.copyFrom(harmonics.l1_1);\r\n        this.y.scaleInPlace(1.02333).scaleInPlace(-1);\r\n        this.z.copyFrom(harmonics.l10);\r\n        this.z.scaleInPlace(1.02333);\r\n\r\n        this.xx.copyFrom(harmonics.l00);\r\n        TmpVectors.Vector3[0].copyFrom(harmonics.l20).scaleInPlace(0.247708);\r\n        TmpVectors.Vector3[1].copyFrom(harmonics.l22).scaleInPlace(0.429043);\r\n        this.xx.scaleInPlace(0.886277).subtractInPlace(TmpVectors.Vector3[0]).addInPlace(TmpVectors.Vector3[1]);\r\n        this.yy.copyFrom(harmonics.l00);\r\n        this.yy.scaleInPlace(0.886277).subtractInPlace(TmpVectors.Vector3[0]).subtractInPlace(TmpVectors.Vector3[1]);\r\n        this.zz.copyFrom(harmonics.l00);\r\n        TmpVectors.Vector3[0].copyFrom(harmonics.l20).scaleInPlace(0.495417);\r\n        this.zz.scaleInPlace(0.886277).addInPlace(TmpVectors.Vector3[0]);\r\n\r\n        this.yz.copyFrom(harmonics.l2_1);\r\n        this.yz.scaleInPlace(0.858086).scaleInPlace(-1);\r\n        this.zx.copyFrom(harmonics.l21);\r\n        this.zx.scaleInPlace(0.858086).scaleInPlace(-1);\r\n        this.xy.copyFrom(harmonics.l2_2);\r\n        this.xy.scaleInPlace(0.858086);\r\n\r\n        this.scaleInPlace(1.0 / Math.PI);\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Gets the spherical polynomial from harmonics\r\n     * @param harmonics the spherical harmonics\r\n     * @returns the spherical polynomial\r\n     */\r\n    public static FromHarmonics(harmonics: SphericalHarmonics): SphericalPolynomial {\r\n        const result = new SphericalPolynomial();\r\n        return result.updateFromHarmonics(harmonics);\r\n    }\r\n\r\n    /**\r\n     * Constructs a spherical polynomial from an array.\r\n     * @param data defines the 9x3 coefficients (x, y, z, xx, yy, zz, yz, zx, xy)\r\n     * @returns the spherical polynomial\r\n     */\r\n    public static FromArray(data: ArrayLike<ArrayLike<number>>): SphericalPolynomial {\r\n        const sp = new SphericalPolynomial();\r\n        Vector3.FromArrayToRef(data[0], 0, sp.x);\r\n        Vector3.FromArrayToRef(data[1], 0, sp.y);\r\n        Vector3.FromArrayToRef(data[2], 0, sp.z);\r\n        Vector3.FromArrayToRef(data[3], 0, sp.xx);\r\n        Vector3.FromArrayToRef(data[4], 0, sp.yy);\r\n        Vector3.FromArrayToRef(data[5], 0, sp.zz);\r\n        Vector3.FromArrayToRef(data[6], 0, sp.yz);\r\n        Vector3.FromArrayToRef(data[7], 0, sp.zx);\r\n        Vector3.FromArrayToRef(data[8], 0, sp.xy);\r\n        return sp;\r\n    }\r\n}\r\n", "/* eslint-disable @typescript-eslint/naming-convention */\r\nimport type { BaseTexture } from \"core/Materials/Textures/baseTexture\";\r\nimport type { InternalTexture } from \"../Materials/Textures/internalTexture\";\r\nimport { Texture } from \"../Materials/Textures/texture\";\r\nimport { RenderTargetTexture } from \"../Materials/Textures/renderTargetTexture\";\r\nimport { PassPostProcess } from \"../PostProcesses/passPostProcess\";\r\nimport { Constants } from \"../Engines/constants\";\r\nimport type { Scene } from \"../scene\";\r\nimport { PostProcess } from \"../PostProcesses/postProcess\";\r\nimport type { Engine } from \"../Engines/engine\";\r\n\r\n/**\r\n * Uses the GPU to create a copy texture rescaled at a given size\r\n * @param texture Texture to copy from\r\n * @param width defines the desired width\r\n * @param height defines the desired height\r\n * @param useBilinearMode defines if bilinear mode has to be used\r\n * @returns the generated texture\r\n */\r\nexport function CreateResizedCopy(texture: Texture, width: number, height: number, useBilinearMode: boolean = true): Texture {\r\n    const scene = <Scene>texture.getScene();\r\n    const engine = scene.getEngine();\r\n\r\n    const rtt = new RenderTargetTexture(\r\n        \"resized\" + texture.name,\r\n        { width: width, height: height },\r\n        scene,\r\n        !texture.noMipmap,\r\n        true,\r\n        (<InternalTexture>texture._texture).type,\r\n        false,\r\n        texture.samplingMode,\r\n        false\r\n    );\r\n\r\n    rtt.wrapU = texture.wrapU;\r\n    rtt.wrapV = texture.wrapV;\r\n    rtt.uOffset = texture.uOffset;\r\n    rtt.vOffset = texture.vOffset;\r\n    rtt.uScale = texture.uScale;\r\n    rtt.vScale = texture.vScale;\r\n    rtt.uAng = texture.uAng;\r\n    rtt.vAng = texture.vAng;\r\n    rtt.wAng = texture.wAng;\r\n    rtt.coordinatesIndex = texture.coordinatesIndex;\r\n    rtt.level = texture.level;\r\n    rtt.anisotropicFilteringLevel = texture.anisotropicFilteringLevel;\r\n    (<InternalTexture>rtt._texture).isReady = false;\r\n\r\n    texture.wrapU = Texture.CLAMP_ADDRESSMODE;\r\n    texture.wrapV = Texture.CLAMP_ADDRESSMODE;\r\n\r\n    const passPostProcess = new PassPostProcess(\r\n        \"pass\",\r\n        1,\r\n        null,\r\n        useBilinearMode ? Texture.BILINEAR_SAMPLINGMODE : Texture.NEAREST_SAMPLINGMODE,\r\n        engine,\r\n        false,\r\n        Constants.TEXTURETYPE_UNSIGNED_INT\r\n    );\r\n    passPostProcess.externalTextureSamplerBinding = true;\r\n    passPostProcess.getEffect().executeWhenCompiled(() => {\r\n        passPostProcess.onApply = function (effect) {\r\n            effect.setTexture(\"textureSampler\", texture);\r\n        };\r\n\r\n        const internalTexture = rtt.renderTarget;\r\n\r\n        if (internalTexture) {\r\n            scene.postProcessManager.directRender([passPostProcess], internalTexture);\r\n\r\n            engine.unBindFramebuffer(internalTexture);\r\n            rtt.disposeFramebufferObjects();\r\n            passPostProcess.dispose();\r\n\r\n            rtt.getInternalTexture()!.isReady = true;\r\n        }\r\n    });\r\n\r\n    return rtt;\r\n}\r\n\r\n/**\r\n * Apply a post process to a texture\r\n * @param postProcessName name of the fragment post process\r\n * @param internalTexture the texture to encode\r\n * @param scene the scene hosting the texture\r\n * @param type type of the output texture. If not provided, use the one from internalTexture\r\n * @param samplingMode sampling mode to use to sample the source texture. If not provided, use the one from internalTexture\r\n * @param format format of the output texture. If not provided, use the one from internalTexture\r\n * @param width width of the output texture. If not provided, use the one from internalTexture\r\n * @param height height of the output texture. If not provided, use the one from internalTexture\r\n * @returns a promise with the internalTexture having its texture replaced by the result of the processing\r\n */\r\nexport function ApplyPostProcess(\r\n    postProcessName: string,\r\n    internalTexture: InternalTexture,\r\n    scene: Scene,\r\n    type?: number,\r\n    samplingMode?: number,\r\n    format?: number,\r\n    width?: number,\r\n    height?: number\r\n): Promise<InternalTexture> {\r\n    // Gets everything ready.\r\n    const engine = internalTexture.getEngine() as Engine;\r\n\r\n    internalTexture.isReady = false;\r\n\r\n    samplingMode = samplingMode ?? internalTexture.samplingMode;\r\n    type = type ?? internalTexture.type;\r\n    format = format ?? internalTexture.format;\r\n    width = width ?? internalTexture.width;\r\n    height = height ?? internalTexture.height;\r\n\r\n    if (type === -1) {\r\n        type = Constants.TEXTURETYPE_UNSIGNED_BYTE;\r\n    }\r\n\r\n    return new Promise((resolve) => {\r\n        // Create the post process\r\n        const postProcess = new PostProcess(\"postprocess\", postProcessName, null, null, 1, null, samplingMode, engine, false, undefined, type, undefined, null, false, format);\r\n        postProcess.externalTextureSamplerBinding = true;\r\n\r\n        // Hold the output of the decoding.\r\n        const encodedTexture = engine.createRenderTargetTexture(\r\n            { width: width as number, height: height as number },\r\n            {\r\n                generateDepthBuffer: false,\r\n                generateMipMaps: false,\r\n                generateStencilBuffer: false,\r\n                samplingMode,\r\n                type,\r\n                format,\r\n            }\r\n        );\r\n\r\n        postProcess.getEffect().executeWhenCompiled(() => {\r\n            // PP Render Pass\r\n            postProcess.onApply = (effect) => {\r\n                effect._bindTexture(\"textureSampler\", internalTexture);\r\n                effect.setFloat2(\"scale\", 1, 1);\r\n            };\r\n            scene.postProcessManager.directRender([postProcess!], encodedTexture, true);\r\n\r\n            // Cleanup\r\n            engine.restoreDefaultFramebuffer();\r\n            engine._releaseTexture(internalTexture);\r\n            if (postProcess) {\r\n                postProcess.dispose();\r\n            }\r\n\r\n            // Internal Swap\r\n            encodedTexture._swapAndDie(internalTexture);\r\n\r\n            // Ready to get rolling again.\r\n            internalTexture.type = type!;\r\n            internalTexture.format = Constants.TEXTUREFORMAT_RGBA;\r\n            internalTexture.isReady = true;\r\n\r\n            resolve(internalTexture);\r\n        });\r\n    });\r\n}\r\n\r\n// ref: http://stackoverflow.com/questions/32633585/how-do-you-convert-to-half-floats-in-javascript\r\nlet floatView: Float32Array;\r\nlet int32View: Int32Array;\r\n/**\r\n * Converts a number to half float\r\n * @param value number to convert\r\n * @returns converted number\r\n */\r\nexport function ToHalfFloat(value: number): number {\r\n    if (!floatView) {\r\n        floatView = new Float32Array(1);\r\n        int32View = new Int32Array(floatView.buffer);\r\n    }\r\n\r\n    floatView[0] = value;\r\n    const x = int32View[0];\r\n\r\n    let bits = (x >> 16) & 0x8000; /* Get the sign */\r\n    let m = (x >> 12) & 0x07ff; /* Keep one extra bit for rounding */\r\n    const e = (x >> 23) & 0xff; /* Using int is faster here */\r\n\r\n    /* If zero, or denormal, or exponent underflows too much for a denormal\r\n     * half, return signed zero. */\r\n    if (e < 103) {\r\n        return bits;\r\n    }\r\n\r\n    /* If NaN, return NaN. If Inf or exponent overflow, return Inf. */\r\n    if (e > 142) {\r\n        bits |= 0x7c00;\r\n        /* If exponent was 0xff and one mantissa bit was set, it means NaN,\r\n         * not Inf, so make sure we set one mantissa bit too. */\r\n        bits |= (e == 255 ? 0 : 1) && x & 0x007fffff;\r\n        return bits;\r\n    }\r\n\r\n    /* If exponent underflows but not too much, return a denormal */\r\n    if (e < 113) {\r\n        m |= 0x0800;\r\n        /* Extra rounding may overflow and set mantissa to 0 and exponent\r\n         * to 1, which is OK. */\r\n        bits |= (m >> (114 - e)) + ((m >> (113 - e)) & 1);\r\n        return bits;\r\n    }\r\n\r\n    bits |= ((e - 112) << 10) | (m >> 1);\r\n    bits += m & 1;\r\n    return bits;\r\n}\r\n\r\n/**\r\n * Converts a half float to a number\r\n * @param value half float to convert\r\n * @returns converted half float\r\n */\r\nexport function FromHalfFloat(value: number): number {\r\n    const s = (value & 0x8000) >> 15;\r\n    const e = (value & 0x7c00) >> 10;\r\n    const f = value & 0x03ff;\r\n\r\n    if (e === 0) {\r\n        return (s ? -1 : 1) * Math.pow(2, -14) * (f / Math.pow(2, 10));\r\n    } else if (e == 0x1f) {\r\n        return f ? NaN : (s ? -1 : 1) * Infinity;\r\n    }\r\n\r\n    return (s ? -1 : 1) * Math.pow(2, e - 15) * (1 + f / Math.pow(2, 10));\r\n}\r\n\r\nconst ProcessAsync = async (texture: BaseTexture, width: number, height: number, face: number, lod: number): Promise<Uint8Array> => {\r\n    const scene = texture.getScene()!;\r\n    const engine = scene.getEngine();\r\n\r\n    let lodPostProcess: PostProcess;\r\n\r\n    if (!texture.isCube) {\r\n        lodPostProcess = new PostProcess(\"lod\", \"lod\", [\"lod\", \"gamma\"], null, 1.0, null, Texture.NEAREST_NEAREST_MIPNEAREST, engine);\r\n    } else {\r\n        const faceDefines = [\"#define POSITIVEX\", \"#define NEGATIVEX\", \"#define POSITIVEY\", \"#define NEGATIVEY\", \"#define POSITIVEZ\", \"#define NEGATIVEZ\"];\r\n        lodPostProcess = new PostProcess(\"lodCube\", \"lodCube\", [\"lod\", \"gamma\"], null, 1.0, null, Texture.NEAREST_NEAREST_MIPNEAREST, engine, false, faceDefines[face]);\r\n    }\r\n\r\n    await new Promise((resolve) => {\r\n        lodPostProcess.getEffect().executeWhenCompiled(() => {\r\n            resolve(0);\r\n        });\r\n    });\r\n\r\n    const rtt = new RenderTargetTexture(\"temp\", { width: width, height: height }, scene, false);\r\n\r\n    lodPostProcess.onApply = function (effect) {\r\n        effect.setTexture(\"textureSampler\", texture);\r\n        effect.setFloat(\"lod\", lod);\r\n        effect.setBool(\"gamma\", texture.gammaSpace);\r\n    };\r\n\r\n    const internalTexture = texture.getInternalTexture();\r\n\r\n    try {\r\n        if (rtt.renderTarget && internalTexture) {\r\n            const samplingMode = internalTexture.samplingMode;\r\n            if (lod !== 0) {\r\n                texture.updateSamplingMode(Texture.NEAREST_NEAREST_MIPNEAREST);\r\n            } else {\r\n                texture.updateSamplingMode(Texture.NEAREST_NEAREST);\r\n            }\r\n\r\n            scene.postProcessManager.directRender([lodPostProcess], rtt.renderTarget, true);\r\n            texture.updateSamplingMode(samplingMode);\r\n\r\n            //Reading datas from WebGL\r\n            const bufferView = await engine.readPixels(0, 0, width, height);\r\n            const data = new Uint8Array(bufferView.buffer, 0, bufferView.byteLength);\r\n\r\n            // Unbind\r\n            engine.unBindFramebuffer(rtt.renderTarget);\r\n\r\n            return data;\r\n        } else {\r\n            throw Error(\"Render to texture failed.\");\r\n        }\r\n    } finally {\r\n        rtt.dispose();\r\n        lodPostProcess.dispose();\r\n    }\r\n};\r\n\r\n/**\r\n * Gets the data of the specified texture by rendering it to an intermediate RGBA texture and retrieving the bytes from it.\r\n * This is convienent to get 8-bit RGBA values for a texture in a GPU compressed format.\r\n * @param texture the source texture\r\n * @param width the width of the result, which does not have to match the source texture width\r\n * @param height the height of the result, which does not have to match the source texture height\r\n * @param face if the texture has multiple faces, the face index to use for the source\r\n * @param lod if the texture has multiple LODs, the lod index to use for the source\r\n * @returns the 8-bit texture data\r\n */\r\nexport async function GetTextureDataAsync(texture: BaseTexture, width: number, height: number, face: number = 0, lod: number = 0): Promise<Uint8Array> {\r\n    if (!texture.isReady() && texture._texture) {\r\n        await new Promise((resolve, reject) => {\r\n            if (texture._texture === null) {\r\n                reject(0);\r\n                return;\r\n            }\r\n            texture._texture.onLoadedObservable.addOnce(() => {\r\n                resolve(0);\r\n            });\r\n        });\r\n    }\r\n    return await ProcessAsync(texture, width, height, face, lod);\r\n}\r\n\r\n/**\r\n * Class used to host texture specific utilities\r\n */\r\nexport const TextureTools = {\r\n    /**\r\n     * Uses the GPU to create a copy texture rescaled at a given size\r\n     * @param texture Texture to copy from\r\n     * @param width defines the desired width\r\n     * @param height defines the desired height\r\n     * @param useBilinearMode defines if bilinear mode has to be used\r\n     * @returns the generated texture\r\n     */\r\n    CreateResizedCopy,\r\n\r\n    /**\r\n     * Apply a post process to a texture\r\n     * @param postProcessName name of the fragment post process\r\n     * @param internalTexture the texture to encode\r\n     * @param scene the scene hosting the texture\r\n     * @param type type of the output texture. If not provided, use the one from internalTexture\r\n     * @param samplingMode sampling mode to use to sample the source texture. If not provided, use the one from internalTexture\r\n     * @param format format of the output texture. If not provided, use the one from internalTexture\r\n     * @returns a promise with the internalTexture having its texture replaced by the result of the processing\r\n     */\r\n    ApplyPostProcess,\r\n    /**\r\n     * Converts a number to half float\r\n     * @param value number to convert\r\n     * @returns converted number\r\n     */\r\n    ToHalfFloat,\r\n\r\n    /**\r\n     * Converts a half float to a number\r\n     * @param value half float to convert\r\n     * @returns converted half float\r\n     */\r\n    FromHalfFloat,\r\n\r\n    /**\r\n     * Gets the data of the specified texture by rendering it to an intermediate RGBA texture and retrieving the bytes from it.\r\n     * This is convienent to get 8-bit RGBA values for a texture in a GPU compressed format.\r\n     * @param texture the source texture\r\n     * @param width the width of the result, which does not have to match the source texture width\r\n     * @param height the height of the result, which does not have to match the source texture height\r\n     * @param face if the texture has multiple faces, the face index to use for the source\r\n     * @param channels a filter for which of the RGBA channels to return in the result\r\n     * @param lod if the texture has multiple LODs, the lod index to use for the source\r\n     * @returns the 8-bit texture data\r\n     */\r\n    GetTextureDataAsync,\r\n};\r\n", "// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore\";\nimport \"./ShadersInclude/helperFunctions\";\n\nconst name = \"rgbdDecodePixelShader\";\nconst shader = `varying vec2 vUV;uniform sampler2D textureSampler;\n#include<helperFunctions>\n#define CUSTOM_FRAGMENT_DEFINITIONS\nvoid main(void) \n{gl_FragColor=vec4(fromRGBD(texture2D(textureSampler,vUV)),1.0);}`;\n// Sideeffect\nShaderStore.ShadersStore[name] = shader;\n/** @internal */\nexport const rgbdDecodePixelShader = { name, shader };\n", "import { Constants } from \"../Engines/constants\";\r\nimport { PostProcess } from \"../PostProcesses/postProcess\";\r\nimport \"../Shaders/rgbdDecode.fragment\";\r\nimport type { Engine } from \"../Engines/engine\";\r\n\r\nimport \"../Engines/Extensions/engine.renderTarget\";\r\nimport { ApplyPostProcess } from \"./textureTools\";\r\n\r\nimport type { Texture } from \"../Materials/Textures/texture\";\r\nimport type { InternalTexture } from \"../Materials/Textures/internalTexture\";\r\nimport type { Scene } from \"../scene\";\r\n\r\n/**\r\n * Class used to host RGBD texture specific utilities\r\n */\r\nexport class RGBDTextureTools {\r\n    /**\r\n     * Expand the RGBD Texture from RGBD to Half Float if possible.\r\n     * @param texture the texture to expand.\r\n     */\r\n    public static ExpandRGBDTexture(texture: Texture) {\r\n        const internalTexture = texture._texture;\r\n        if (!internalTexture || !texture.isRGBD) {\r\n            return;\r\n        }\r\n\r\n        // Gets everything ready.\r\n        const engine = internalTexture.getEngine() as Engine;\r\n        const caps = engine.getCaps();\r\n        const isReady = internalTexture.isReady;\r\n        let expandTexture = false;\r\n\r\n        // If half float available we can uncompress the texture\r\n        if (caps.textureHalfFloatRender && caps.textureHalfFloatLinearFiltering) {\r\n            expandTexture = true;\r\n            internalTexture.type = Constants.TEXTURETYPE_HALF_FLOAT;\r\n        }\r\n        // If full float available we can uncompress the texture\r\n        else if (caps.textureFloatRender && caps.textureFloatLinearFiltering) {\r\n            expandTexture = true;\r\n            internalTexture.type = Constants.TEXTURETYPE_FLOAT;\r\n        }\r\n\r\n        if (expandTexture) {\r\n            // Do not use during decode.\r\n            internalTexture.isReady = false;\r\n            internalTexture._isRGBD = false;\r\n            internalTexture.invertY = false;\r\n        }\r\n\r\n        const expandRGBDTexture = () => {\r\n            // Expand the texture if possible\r\n            // Simply run through the decode PP.\r\n            const rgbdPostProcess = new PostProcess(\r\n                \"rgbdDecode\",\r\n                \"rgbdDecode\",\r\n                null,\r\n                null,\r\n                1,\r\n                null,\r\n                Constants.TEXTURE_TRILINEAR_SAMPLINGMODE,\r\n                engine,\r\n                false,\r\n                undefined,\r\n                internalTexture.type,\r\n                undefined,\r\n                null,\r\n                false\r\n            );\r\n            rgbdPostProcess.externalTextureSamplerBinding = true;\r\n\r\n            // Hold the output of the decoding.\r\n            const expandedTexture = engine.createRenderTargetTexture(internalTexture.width, {\r\n                generateDepthBuffer: false,\r\n                generateMipMaps: false,\r\n                generateStencilBuffer: false,\r\n                samplingMode: internalTexture.samplingMode,\r\n                type: internalTexture.type,\r\n                format: Constants.TEXTUREFORMAT_RGBA,\r\n            });\r\n\r\n            rgbdPostProcess.getEffect().executeWhenCompiled(() => {\r\n                // PP Render Pass\r\n                rgbdPostProcess.onApply = (effect) => {\r\n                    effect._bindTexture(\"textureSampler\", internalTexture);\r\n                    effect.setFloat2(\"scale\", 1, 1);\r\n                };\r\n                texture.getScene()!.postProcessManager.directRender([rgbdPostProcess!], expandedTexture, true);\r\n\r\n                // Cleanup\r\n                engine.restoreDefaultFramebuffer();\r\n                engine._releaseTexture(internalTexture);\r\n                if (rgbdPostProcess) {\r\n                    rgbdPostProcess.dispose();\r\n                }\r\n\r\n                // Internal Swap\r\n                expandedTexture._swapAndDie(internalTexture);\r\n\r\n                // Ready to get rolling again.\r\n                internalTexture.isReady = true;\r\n            });\r\n        };\r\n\r\n        if (expandTexture) {\r\n            if (isReady) {\r\n                expandRGBDTexture();\r\n            } else {\r\n                texture.onLoadObservable.addOnce(expandRGBDTexture);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Encode the texture to RGBD if possible.\r\n     * @param internalTexture the texture to encode\r\n     * @param scene the scene hosting the texture\r\n     * @param outputTextureType type of the texture in which the encoding is performed\r\n     * @returns a promise with the internalTexture having its texture replaced by the result of the processing\r\n     */\r\n    public static EncodeTextureToRGBD(internalTexture: InternalTexture, scene: Scene, outputTextureType = Constants.TEXTURETYPE_UNSIGNED_BYTE): Promise<InternalTexture> {\r\n        return ApplyPostProcess(\"rgbdEncode\", internalTexture, scene, outputTextureType, Constants.TEXTURE_NEAREST_SAMPLINGMODE, Constants.TEXTUREFORMAT_RGBA);\r\n    }\r\n}\r\n", "import { Vector3 } from \"../../Maths/math.vector\";\r\nimport { Scalar } from \"../../Maths/math.scalar\";\r\nimport { SphericalPolynomial, SphericalHarmonics } from \"../../Maths/sphericalPolynomial\";\r\nimport type { BaseTexture } from \"../../Materials/Textures/baseTexture\";\r\nimport type { Nullable } from \"../../types\";\r\nimport { Constants } from \"../../Engines/constants\";\r\nimport type { CubeMapInfo } from \"./panoramaToCubemap\";\r\nimport { ToLinearSpace } from \"../../Maths/math.constants\";\r\nimport { Color3 } from \"../../Maths/math.color\";\r\n\r\nclass FileFaceOrientation {\r\n    public name: string;\r\n    public worldAxisForNormal: Vector3; // the world axis corresponding to the normal to the face\r\n    public worldAxisForFileX: Vector3; // the world axis corresponding to texture right x-axis in file\r\n    public worldAxisForFileY: Vector3; // the world axis corresponding to texture down y-axis in file\r\n\r\n    public constructor(name: string, worldAxisForNormal: Vector3, worldAxisForFileX: Vector3, worldAxisForFileY: Vector3) {\r\n        this.name = name;\r\n        this.worldAxisForNormal = worldAxisForNormal;\r\n        this.worldAxisForFileX = worldAxisForFileX;\r\n        this.worldAxisForFileY = worldAxisForFileY;\r\n    }\r\n}\r\n\r\n/**\r\n * Helper class dealing with the extraction of spherical polynomial dataArray\r\n * from a cube map.\r\n */\r\nexport class CubeMapToSphericalPolynomialTools {\r\n    private static _FileFaces: FileFaceOrientation[] = [\r\n        new FileFaceOrientation(\"right\", new Vector3(1, 0, 0), new Vector3(0, 0, -1), new Vector3(0, -1, 0)), // +X east\r\n        new FileFaceOrientation(\"left\", new Vector3(-1, 0, 0), new Vector3(0, 0, 1), new Vector3(0, -1, 0)), // -X west\r\n        new FileFaceOrientation(\"up\", new Vector3(0, 1, 0), new Vector3(1, 0, 0), new Vector3(0, 0, 1)), // +Y north\r\n        new FileFaceOrientation(\"down\", new Vector3(0, -1, 0), new Vector3(1, 0, 0), new Vector3(0, 0, -1)), // -Y south\r\n        new FileFaceOrientation(\"front\", new Vector3(0, 0, 1), new Vector3(1, 0, 0), new Vector3(0, -1, 0)), // +Z top\r\n        new FileFaceOrientation(\"back\", new Vector3(0, 0, -1), new Vector3(-1, 0, 0), new Vector3(0, -1, 0)), // -Z bottom\r\n    ];\r\n\r\n    /** @internal */\r\n    public static MAX_HDRI_VALUE = 4096;\r\n    /** @internal */\r\n    public static PRESERVE_CLAMPED_COLORS = false;\r\n\r\n    /**\r\n     * Converts a texture to the according Spherical Polynomial data.\r\n     * This extracts the first 3 orders only as they are the only one used in the lighting.\r\n     *\r\n     * @param texture The texture to extract the information from.\r\n     * @returns The Spherical Polynomial data.\r\n     */\r\n    public static ConvertCubeMapTextureToSphericalPolynomial(texture: BaseTexture): Nullable<Promise<SphericalPolynomial>> {\r\n        if (!texture.isCube) {\r\n            // Only supports cube Textures currently.\r\n            return null;\r\n        }\r\n\r\n        texture.getScene()?.getEngine().flushFramebuffer();\r\n\r\n        const size = texture.getSize().width;\r\n        const rightPromise = texture.readPixels(0, undefined, undefined, false);\r\n        const leftPromise = texture.readPixels(1, undefined, undefined, false);\r\n\r\n        let upPromise: Nullable<Promise<ArrayBufferView>>;\r\n        let downPromise: Nullable<Promise<ArrayBufferView>>;\r\n        if (texture.isRenderTarget) {\r\n            upPromise = texture.readPixels(3, undefined, undefined, false);\r\n            downPromise = texture.readPixels(2, undefined, undefined, false);\r\n        } else {\r\n            upPromise = texture.readPixels(2, undefined, undefined, false);\r\n            downPromise = texture.readPixels(3, undefined, undefined, false);\r\n        }\r\n\r\n        const frontPromise = texture.readPixels(4, undefined, undefined, false);\r\n        const backPromise = texture.readPixels(5, undefined, undefined, false);\r\n\r\n        const gammaSpace = texture.gammaSpace;\r\n        // Always read as RGBA.\r\n        const format = Constants.TEXTUREFORMAT_RGBA;\r\n        let type = Constants.TEXTURETYPE_UNSIGNED_INT;\r\n        if (texture.textureType == Constants.TEXTURETYPE_FLOAT || texture.textureType == Constants.TEXTURETYPE_HALF_FLOAT) {\r\n            type = Constants.TEXTURETYPE_FLOAT;\r\n        }\r\n\r\n        return new Promise((resolve) => {\r\n            Promise.all([leftPromise, rightPromise, upPromise, downPromise, frontPromise, backPromise]).then(([left, right, up, down, front, back]) => {\r\n                const cubeInfo: CubeMapInfo = {\r\n                    size,\r\n                    right,\r\n                    left,\r\n                    up,\r\n                    down,\r\n                    front,\r\n                    back,\r\n                    format,\r\n                    type,\r\n                    gammaSpace,\r\n                };\r\n\r\n                resolve(this.ConvertCubeMapToSphericalPolynomial(cubeInfo));\r\n            });\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Compute the area on the unit sphere of the rectangle defined by (x,y) and the origin\r\n     * See https://www.rorydriscoll.com/2012/01/15/cubemap-texel-solid-angle/\r\n     * @param x\r\n     * @param y\r\n     * @returns the area\r\n     */\r\n    private static _AreaElement(x: number, y: number): number {\r\n        return Math.atan2(x * y, Math.sqrt(x * x + y * y + 1));\r\n    }\r\n\r\n    /**\r\n     * Converts a cubemap to the according Spherical Polynomial data.\r\n     * This extracts the first 3 orders only as they are the only one used in the lighting.\r\n     *\r\n     * @param cubeInfo The Cube map to extract the information from.\r\n     * @returns The Spherical Polynomial data.\r\n     */\r\n    public static ConvertCubeMapToSphericalPolynomial(cubeInfo: CubeMapInfo): SphericalPolynomial {\r\n        const sphericalHarmonics = new SphericalHarmonics();\r\n        let totalSolidAngle = 0.0;\r\n\r\n        // The (u,v) range is [-1,+1], so the distance between each texel is 2/Size.\r\n        const du = 2.0 / cubeInfo.size;\r\n        const dv = du;\r\n\r\n        const halfTexel = 0.5 * du;\r\n\r\n        // The (u,v) of the first texel is half a texel from the corner (-1,-1).\r\n        const minUV = halfTexel - 1.0;\r\n\r\n        for (let faceIndex = 0; faceIndex < 6; faceIndex++) {\r\n            const fileFace = this._FileFaces[faceIndex];\r\n            const dataArray = (<any>cubeInfo)[fileFace.name];\r\n            let v = minUV;\r\n\r\n            // TODO: we could perform the summation directly into a SphericalPolynomial (SP), which is more efficient than SphericalHarmonic (SH).\r\n            // This is possible because during the summation we do not need the SH-specific properties, e.g. orthogonality.\r\n            // Because SP is still linear, so summation is fine in that basis.\r\n            const stride = cubeInfo.format === Constants.TEXTUREFORMAT_RGBA ? 4 : 3;\r\n            for (let y = 0; y < cubeInfo.size; y++) {\r\n                let u = minUV;\r\n\r\n                for (let x = 0; x < cubeInfo.size; x++) {\r\n                    // World direction (not normalised)\r\n                    const worldDirection = fileFace.worldAxisForFileX.scale(u).add(fileFace.worldAxisForFileY.scale(v)).add(fileFace.worldAxisForNormal);\r\n                    worldDirection.normalize();\r\n\r\n                    const deltaSolidAngle =\r\n                        this._AreaElement(u - halfTexel, v - halfTexel) -\r\n                        this._AreaElement(u - halfTexel, v + halfTexel) -\r\n                        this._AreaElement(u + halfTexel, v - halfTexel) +\r\n                        this._AreaElement(u + halfTexel, v + halfTexel);\r\n\r\n                    let r = dataArray[y * cubeInfo.size * stride + x * stride + 0];\r\n                    let g = dataArray[y * cubeInfo.size * stride + x * stride + 1];\r\n                    let b = dataArray[y * cubeInfo.size * stride + x * stride + 2];\r\n\r\n                    // Prevent NaN harmonics with extreme HDRI data.\r\n                    if (isNaN(r)) {\r\n                        r = 0;\r\n                    }\r\n                    if (isNaN(g)) {\r\n                        g = 0;\r\n                    }\r\n                    if (isNaN(b)) {\r\n                        b = 0;\r\n                    }\r\n\r\n                    // Handle Integer types.\r\n                    if (cubeInfo.type === Constants.TEXTURETYPE_UNSIGNED_INT) {\r\n                        r /= 255;\r\n                        g /= 255;\r\n                        b /= 255;\r\n                    }\r\n\r\n                    // Handle Gamma space textures.\r\n                    if (cubeInfo.gammaSpace) {\r\n                        r = Math.pow(Scalar.Clamp(r), ToLinearSpace);\r\n                        g = Math.pow(Scalar.Clamp(g), ToLinearSpace);\r\n                        b = Math.pow(Scalar.Clamp(b), ToLinearSpace);\r\n                    }\r\n\r\n                    // Prevent to explode in case of really high dynamic ranges.\r\n                    // sh 3 would not be enough to accurately represent it.\r\n                    const max = this.MAX_HDRI_VALUE;\r\n                    if (this.PRESERVE_CLAMPED_COLORS) {\r\n                        const currentMax = Math.max(r, g, b);\r\n                        if (currentMax > max) {\r\n                            const factor = max / currentMax;\r\n                            r *= factor;\r\n                            g *= factor;\r\n                            b *= factor;\r\n                        }\r\n                    } else {\r\n                        r = Scalar.Clamp(r, 0, max);\r\n                        g = Scalar.Clamp(g, 0, max);\r\n                        b = Scalar.Clamp(b, 0, max);\r\n                    }\r\n\r\n                    const color = new Color3(r, g, b);\r\n\r\n                    sphericalHarmonics.addLight(worldDirection, color, deltaSolidAngle);\r\n\r\n                    totalSolidAngle += deltaSolidAngle;\r\n\r\n                    u += du;\r\n                }\r\n\r\n                v += dv;\r\n            }\r\n        }\r\n\r\n        // Solid angle for entire sphere is 4*pi\r\n        const sphereSolidAngle = 4.0 * Math.PI;\r\n\r\n        // Adjust the solid angle to allow for how many faces we processed.\r\n        const facesProcessed = 6.0;\r\n        const expectedSolidAngle = (sphereSolidAngle * facesProcessed) / 6.0;\r\n\r\n        // Adjust the harmonics so that the accumulated solid angle matches the expected solid angle.\r\n        // This is needed because the numerical integration over the cube uses a\r\n        // small angle approximation of solid angle for each texel (see deltaSolidAngle),\r\n        // and also to compensate for accumulative error due to float precision in the summation.\r\n        const correctionFactor = expectedSolidAngle / totalSolidAngle;\r\n        sphericalHarmonics.scaleInPlace(correctionFactor);\r\n\r\n        sphericalHarmonics.convertIncidentRadianceToIrradiance();\r\n        sphericalHarmonics.convertIrradianceToLambertianRadiance();\r\n\r\n        return SphericalPolynomial.FromHarmonics(sphericalHarmonics);\r\n    }\r\n}\r\n", "import type { Nullable } from \"../../types\";\r\nimport { CubeMapToSphericalPolynomialTools } from \"../../Misc/HighDynamicRange/cubemapToSphericalPolynomial\";\r\nimport type { SphericalPolynomial } from \"../../Maths/sphericalPolynomial\";\r\nimport { BaseTexture } from \"./baseTexture\";\r\n\r\ndeclare module \"./baseTexture\" {\r\n    export interface BaseTexture {\r\n        /**\r\n         * Get the polynomial representation of the texture data.\r\n         * This is mainly use as a fast way to recover IBL Diffuse irradiance data.\r\n         * @see https://learnopengl.com/PBR/IBL/Diffuse-irradiance\r\n         */\r\n        sphericalPolynomial: Nullable<SphericalPolynomial>;\r\n\r\n        /**\r\n         * Force recomputation of spherical polynomials.\r\n         * Can be useful if you generate a cubemap multiple times (from a probe for eg) and you need the proper polynomials each time\r\n         */\r\n        forceSphericalPolynomialsRecompute(): void;\r\n    }\r\n}\r\n\r\nBaseTexture.prototype.forceSphericalPolynomialsRecompute = function (): void {\r\n    if (this._texture) {\r\n        this._texture._sphericalPolynomial = null;\r\n        this._texture._sphericalPolynomialPromise = null;\r\n        this._texture._sphericalPolynomialComputed = false;\r\n    }\r\n};\r\n\r\nObject.defineProperty(BaseTexture.prototype, \"sphericalPolynomial\", {\r\n    get: function (this: BaseTexture) {\r\n        if (this._texture) {\r\n            if (this._texture._sphericalPolynomial || this._texture._sphericalPolynomialComputed) {\r\n                return this._texture._sphericalPolynomial;\r\n            }\r\n\r\n            if (this._texture.isReady) {\r\n                if (!this._texture._sphericalPolynomialPromise) {\r\n                    this._texture._sphericalPolynomialPromise = CubeMapToSphericalPolynomialTools.ConvertCubeMapTextureToSphericalPolynomial(this);\r\n                    if (this._texture._sphericalPolynomialPromise === null) {\r\n                        this._texture._sphericalPolynomialComputed = true;\r\n                    } else {\r\n                        this._texture._sphericalPolynomialPromise.then((sphericalPolynomial) => {\r\n                            this._texture!._sphericalPolynomial = sphericalPolynomial;\r\n                            this._texture!._sphericalPolynomialComputed = true;\r\n                        });\r\n                    }\r\n                }\r\n\r\n                return null;\r\n            }\r\n        }\r\n\r\n        return null;\r\n    },\r\n    set: function (this: BaseTexture, value: Nullable<SphericalPolynomial>) {\r\n        if (this._texture) {\r\n            this._texture._sphericalPolynomial = value;\r\n        }\r\n    },\r\n    enumerable: true,\r\n    configurable: true,\r\n});\r\n", "// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore\";\nimport \"./ShadersInclude/helperFunctions\";\n\nconst name = \"rgbdEncodePixelShader\";\nconst shader = `varying vec2 vUV;uniform sampler2D textureSampler;\n#include<helperFunctions>\n#define CUSTOM_FRAGMENT_DEFINITIONS\nvoid main(void) \n{gl_FragColor=toRGBD(texture2D(textureSampler,vUV).rgb);}`;\n// Sideeffect\nShaderStore.ShadersStore[name] = shader;\n/** @internal */\nexport const rgbdEncodePixelShader = { name, shader };\n", "/* eslint-disable @typescript-eslint/naming-convention */\r\nimport type { Nullable } from \"../types\";\r\nimport { Tools } from \"./tools\";\r\nimport { Vector3 } from \"../Maths/math.vector\";\r\nimport { Scalar } from \"../Maths/math.scalar\";\r\nimport { SphericalPolynomial } from \"../Maths/sphericalPolynomial\";\r\nimport { InternalTexture, InternalTextureSource } from \"../Materials/Textures/internalTexture\";\r\nimport { BaseTexture } from \"../Materials/Textures/baseTexture\";\r\nimport { Constants } from \"../Engines/constants\";\r\nimport { Scene } from \"../scene\";\r\nimport { PostProcess } from \"../PostProcesses/postProcess\";\r\nimport { Logger } from \"../Misc/logger\";\r\nimport type { Engine } from \"../Engines/engine\";\r\nimport { RGBDTextureTools } from \"./rgbdTextureTools\";\r\nimport type { RenderTargetWrapper } from \"../Engines/renderTargetWrapper\";\r\n\r\nimport \"../Engines/Extensions/engine.renderTargetCube\";\r\nimport \"../Engines/Extensions/engine.readTexture\";\r\nimport \"../Materials/Textures/baseTexture.polynomial\";\r\n\r\nimport \"../Shaders/rgbdEncode.fragment\";\r\nimport \"../Shaders/rgbdDecode.fragment\";\r\nimport { DumpTools } from \"../Misc/dumpTools\";\r\n\r\nconst DefaultEnvironmentTextureImageType = \"image/png\";\r\nconst CurrentVersion = 2;\r\n\r\n/**\r\n * Raw texture data and descriptor sufficient for WebGL texture upload\r\n */\r\nexport type EnvironmentTextureInfo = EnvironmentTextureInfoV1 | EnvironmentTextureInfoV2;\r\n\r\n/**\r\n * v1 of EnvironmentTextureInfo\r\n */\r\ninterface EnvironmentTextureInfoV1 {\r\n    /**\r\n     * Version of the environment map\r\n     */\r\n    version: 1;\r\n\r\n    /**\r\n     * Width of image\r\n     */\r\n    width: number;\r\n\r\n    /**\r\n     * Irradiance information stored in the file.\r\n     */\r\n    irradiance: any;\r\n\r\n    /**\r\n     * Specular information stored in the file.\r\n     */\r\n    specular: any;\r\n}\r\n\r\n/**\r\n * v2 of EnvironmentTextureInfo\r\n */\r\ninterface EnvironmentTextureInfoV2 {\r\n    /**\r\n     * Version of the environment map\r\n     */\r\n    version: 2;\r\n\r\n    /**\r\n     * Width of image\r\n     */\r\n    width: number;\r\n\r\n    /**\r\n     * Irradiance information stored in the file.\r\n     */\r\n    irradiance: any;\r\n\r\n    /**\r\n     * Specular information stored in the file.\r\n     */\r\n    specular: any;\r\n\r\n    /**\r\n     * The mime type used to encode the image data.\r\n     */\r\n    imageType: string;\r\n}\r\n\r\n/**\r\n * Defines One Image in the file. It requires only the position in the file\r\n * as well as the length.\r\n */\r\ninterface BufferImageData {\r\n    /**\r\n     * Length of the image data.\r\n     */\r\n    length: number;\r\n    /**\r\n     * Position of the data from the null terminator delimiting the end of the JSON.\r\n     */\r\n    position: number;\r\n}\r\n\r\n/**\r\n * Defines the specular data enclosed in the file.\r\n * This corresponds to the version 1 of the data.\r\n */\r\nexport interface EnvironmentTextureSpecularInfoV1 {\r\n    /**\r\n     * Defines where the specular Payload is located. It is a runtime value only not stored in the file.\r\n     */\r\n    specularDataPosition?: number;\r\n    /**\r\n     * This contains all the images data needed to reconstruct the cubemap.\r\n     */\r\n    mipmaps: Array<BufferImageData>;\r\n    /**\r\n     * Defines the scale applied to environment texture. This manages the range of LOD level used for IBL according to the roughness.\r\n     */\r\n    lodGenerationScale: number;\r\n}\r\n\r\n/**\r\n * Defines the required storage to save the environment irradiance information.\r\n */\r\ninterface EnvironmentTextureIrradianceInfoV1 {\r\n    x: Array<number>;\r\n    y: Array<number>;\r\n    z: Array<number>;\r\n\r\n    xx: Array<number>;\r\n    yy: Array<number>;\r\n    zz: Array<number>;\r\n\r\n    yz: Array<number>;\r\n    zx: Array<number>;\r\n    xy: Array<number>;\r\n}\r\n\r\n/**\r\n * Options for creating environment textures\r\n */\r\nexport interface CreateEnvTextureOptions {\r\n    /**\r\n     * The mime type of encoded images.\r\n     */\r\n    imageType?: string;\r\n\r\n    /**\r\n     * the image quality of encoded WebP images.\r\n     */\r\n    imageQuality?: number;\r\n}\r\n\r\n/**\r\n * Magic number identifying the env file.\r\n */\r\nconst MagicBytes = [0x86, 0x16, 0x87, 0x96, 0xf6, 0xd6, 0x96, 0x36];\r\n\r\n/**\r\n * Gets the environment info from an env file.\r\n * @param data The array buffer containing the .env bytes.\r\n * @returns the environment file info (the json header) if successfully parsed, normalized to the latest supported version.\r\n */\r\nexport function GetEnvInfo(data: ArrayBufferView): Nullable<EnvironmentTextureInfoV2> {\r\n    const dataView = new DataView(data.buffer, data.byteOffset, data.byteLength);\r\n    let pos = 0;\r\n\r\n    for (let i = 0; i < MagicBytes.length; i++) {\r\n        if (dataView.getUint8(pos++) !== MagicBytes[i]) {\r\n            Logger.Error(\"Not a babylon environment map\");\r\n            return null;\r\n        }\r\n    }\r\n\r\n    // Read json manifest - collect characters up to null terminator\r\n    let manifestString = \"\";\r\n    let charCode = 0x00;\r\n    while ((charCode = dataView.getUint8(pos++))) {\r\n        manifestString += String.fromCharCode(charCode);\r\n    }\r\n\r\n    let manifest: EnvironmentTextureInfo = JSON.parse(manifestString);\r\n    manifest = normalizeEnvInfo(manifest);\r\n    if (manifest.specular) {\r\n        // Extend the header with the position of the payload.\r\n        manifest.specular.specularDataPosition = pos;\r\n        // Fallback to 0.8 exactly if lodGenerationScale is not defined for backward compatibility.\r\n        manifest.specular.lodGenerationScale = manifest.specular.lodGenerationScale || 0.8;\r\n    }\r\n\r\n    return manifest;\r\n}\r\n\r\n/**\r\n * Normalizes any supported version of the environment file info to the latest version\r\n * @param info environment file info on any supported version\r\n * @returns environment file info in the latest supported version\r\n * @private\r\n */\r\nexport function normalizeEnvInfo(info: EnvironmentTextureInfo): EnvironmentTextureInfoV2 {\r\n    if (info.version > CurrentVersion) {\r\n        throw new Error(`Unsupported babylon environment map version \"${info.version}\". Latest supported version is \"${CurrentVersion}\".`);\r\n    }\r\n\r\n    if (info.version === 2) {\r\n        return info;\r\n    }\r\n\r\n    // Migrate a v1 info to v2\r\n    info = { ...info, version: 2, imageType: DefaultEnvironmentTextureImageType };\r\n\r\n    return info;\r\n}\r\n\r\n/**\r\n * Creates an environment texture from a loaded cube texture.\r\n * @param texture defines the cube texture to convert in env file\r\n * @param options options for the conversion process\r\n * @param options.imageType the mime type for the encoded images, with support for \"image/png\" (default) and \"image/webp\"\r\n * @param options.imageQuality the image quality of encoded WebP images.\r\n * @returns a promise containing the environment data if successful.\r\n */\r\nexport async function CreateEnvTextureAsync(texture: BaseTexture, options: CreateEnvTextureOptions = {}): Promise<ArrayBuffer> {\r\n    const internalTexture = texture.getInternalTexture();\r\n    if (!internalTexture) {\r\n        return Promise.reject(\"The cube texture is invalid.\");\r\n    }\r\n\r\n    const imageType = options.imageType ?? DefaultEnvironmentTextureImageType;\r\n\r\n    const engine = internalTexture.getEngine() as Engine;\r\n\r\n    if (\r\n        texture.textureType !== Constants.TEXTURETYPE_HALF_FLOAT &&\r\n        texture.textureType !== Constants.TEXTURETYPE_FLOAT &&\r\n        texture.textureType !== Constants.TEXTURETYPE_UNSIGNED_BYTE &&\r\n        texture.textureType !== Constants.TEXTURETYPE_UNSIGNED_INT &&\r\n        texture.textureType !== Constants.TEXTURETYPE_UNSIGNED_INTEGER &&\r\n        texture.textureType !== -1\r\n    ) {\r\n        return Promise.reject(\"The cube texture should allow HDR (Full Float or Half Float).\");\r\n    }\r\n\r\n    let textureType = Constants.TEXTURETYPE_FLOAT;\r\n    if (!engine.getCaps().textureFloatRender) {\r\n        textureType = Constants.TEXTURETYPE_HALF_FLOAT;\r\n        if (!engine.getCaps().textureHalfFloatRender) {\r\n            return Promise.reject(\"Env texture can only be created when the browser supports half float or full float rendering.\");\r\n        }\r\n    }\r\n\r\n    // sphericalPolynomial is lazy loaded so simply accessing it should trigger the computation.\r\n    texture.sphericalPolynomial;\r\n\r\n    // Lets keep track of the polynomial promise so we can wait for it to be ready before generating the pixels.\r\n    const sphericalPolynomialPromise = texture.getInternalTexture()?._sphericalPolynomialPromise;\r\n\r\n    const cubeWidth = internalTexture.width;\r\n    const hostingScene = new Scene(engine);\r\n    const specularTextures: { [key: number]: ArrayBuffer } = {};\r\n\r\n    // As we are going to readPixels the faces of the cube, make sure the drawing/update commands for the cube texture are fully sent to the GPU in case it is drawn for the first time in this very frame!\r\n    engine.flushFramebuffer();\r\n\r\n    // Read and collect all mipmaps data from the cube.\r\n    const mipmapsCount = Scalar.ILog2(internalTexture.width);\r\n    for (let i = 0; i <= mipmapsCount; i++) {\r\n        const faceWidth = Math.pow(2, mipmapsCount - i);\r\n\r\n        // All faces of the cube.\r\n        for (let face = 0; face < 6; face++) {\r\n            let faceData = await texture.readPixels(face, i, undefined, false);\r\n            if (faceData && faceData.byteLength === (faceData as Uint8Array).length) {\r\n                const faceDataFloat = new Float32Array(faceData!.byteLength * 4);\r\n                for (let i = 0; i < faceData.byteLength; i++) {\r\n                    faceDataFloat[i] = (faceData as Uint8Array)[i] / 255;\r\n                    // Gamma to linear\r\n                    faceDataFloat[i] = Math.pow(faceDataFloat[i], 2.2);\r\n                }\r\n                faceData = faceDataFloat;\r\n            } else if (faceData && texture.gammaSpace) {\r\n                const floatData = faceData as Float32Array;\r\n                for (let i = 0; i < floatData.length; i++) {\r\n                    // Gamma to linear\r\n                    floatData[i] = Math.pow(floatData[i], 2.2);\r\n                }\r\n            }\r\n\r\n            const tempTexture = engine.createRawTexture(\r\n                faceData,\r\n                faceWidth,\r\n                faceWidth,\r\n                Constants.TEXTUREFORMAT_RGBA,\r\n                false,\r\n                true,\r\n                Constants.TEXTURE_NEAREST_SAMPLINGMODE,\r\n                null,\r\n                textureType\r\n            );\r\n\r\n            await RGBDTextureTools.EncodeTextureToRGBD(tempTexture, hostingScene, textureType);\r\n\r\n            const rgbdEncodedData = await engine._readTexturePixels(tempTexture, faceWidth, faceWidth);\r\n\r\n            const imageEncodedData = await DumpTools.DumpDataAsync(faceWidth, faceWidth, rgbdEncodedData, imageType, undefined, false, true, options.imageQuality);\r\n\r\n            specularTextures[i * 6 + face] = imageEncodedData as ArrayBuffer;\r\n\r\n            tempTexture.dispose();\r\n        }\r\n    }\r\n\r\n    // We can delete the hosting scene keeping track of all the creation objects\r\n    hostingScene.dispose();\r\n\r\n    // Ensure completion of the polynomial creation promise.\r\n    if (sphericalPolynomialPromise) {\r\n        await sphericalPolynomialPromise;\r\n    }\r\n\r\n    // Creates the json header for the env texture\r\n    const info: EnvironmentTextureInfo = {\r\n        version: CurrentVersion,\r\n        width: cubeWidth,\r\n        imageType,\r\n        irradiance: _CreateEnvTextureIrradiance(texture),\r\n        specular: {\r\n            mipmaps: [],\r\n            lodGenerationScale: texture.lodGenerationScale,\r\n        },\r\n    };\r\n\r\n    // Sets the specular image data information\r\n    let position = 0;\r\n    for (let i = 0; i <= mipmapsCount; i++) {\r\n        for (let face = 0; face < 6; face++) {\r\n            const byteLength = specularTextures[i * 6 + face].byteLength;\r\n            info.specular.mipmaps.push({\r\n                length: byteLength,\r\n                position: position,\r\n            });\r\n            position += byteLength;\r\n        }\r\n    }\r\n\r\n    // Encode the JSON as an array buffer\r\n    const infoString = JSON.stringify(info);\r\n    const infoBuffer = new ArrayBuffer(infoString.length + 1);\r\n    const infoView = new Uint8Array(infoBuffer); // Limited to ascii subset matching unicode.\r\n    for (let i = 0, strLen = infoString.length; i < strLen; i++) {\r\n        infoView[i] = infoString.charCodeAt(i);\r\n    }\r\n    // Ends up with a null terminator for easier parsing\r\n    infoView[infoString.length] = 0x00;\r\n\r\n    // Computes the final required size and creates the storage\r\n    const totalSize = MagicBytes.length + position + infoBuffer.byteLength;\r\n    const finalBuffer = new ArrayBuffer(totalSize);\r\n    const finalBufferView = new Uint8Array(finalBuffer);\r\n    const dataView = new DataView(finalBuffer);\r\n\r\n    // Copy the magic bytes identifying the file in\r\n    let pos = 0;\r\n    for (let i = 0; i < MagicBytes.length; i++) {\r\n        dataView.setUint8(pos++, MagicBytes[i]);\r\n    }\r\n\r\n    // Add the json info\r\n    finalBufferView.set(new Uint8Array(infoBuffer), pos);\r\n    pos += infoBuffer.byteLength;\r\n\r\n    // Finally inserts the texture data\r\n    for (let i = 0; i <= mipmapsCount; i++) {\r\n        for (let face = 0; face < 6; face++) {\r\n            const dataBuffer = specularTextures[i * 6 + face];\r\n            finalBufferView.set(new Uint8Array(dataBuffer), pos);\r\n            pos += dataBuffer.byteLength;\r\n        }\r\n    }\r\n\r\n    // Voila\r\n    return finalBuffer;\r\n}\r\n\r\n/**\r\n * Creates a JSON representation of the spherical data.\r\n * @param texture defines the texture containing the polynomials\r\n * @returns the JSON representation of the spherical info\r\n */\r\nfunction _CreateEnvTextureIrradiance(texture: BaseTexture): Nullable<EnvironmentTextureIrradianceInfoV1> {\r\n    const polynmials = texture.sphericalPolynomial;\r\n    if (polynmials == null) {\r\n        return null;\r\n    }\r\n\r\n    return {\r\n        x: [polynmials.x.x, polynmials.x.y, polynmials.x.z],\r\n        y: [polynmials.y.x, polynmials.y.y, polynmials.y.z],\r\n        z: [polynmials.z.x, polynmials.z.y, polynmials.z.z],\r\n\r\n        xx: [polynmials.xx.x, polynmials.xx.y, polynmials.xx.z],\r\n        yy: [polynmials.yy.x, polynmials.yy.y, polynmials.yy.z],\r\n        zz: [polynmials.zz.x, polynmials.zz.y, polynmials.zz.z],\r\n\r\n        yz: [polynmials.yz.x, polynmials.yz.y, polynmials.yz.z],\r\n        zx: [polynmials.zx.x, polynmials.zx.y, polynmials.zx.z],\r\n        xy: [polynmials.xy.x, polynmials.xy.y, polynmials.xy.z],\r\n    } as any;\r\n}\r\n\r\n/**\r\n * Creates the ArrayBufferViews used for initializing environment texture image data.\r\n * @param data the image data\r\n * @param info parameters that determine what views will be created for accessing the underlying buffer\r\n * @returns the views described by info providing access to the underlying buffer\r\n */\r\nexport function CreateImageDataArrayBufferViews(data: ArrayBufferView, info: EnvironmentTextureInfo): Array<Array<ArrayBufferView>> {\r\n    info = normalizeEnvInfo(info);\r\n\r\n    const specularInfo = info.specular as EnvironmentTextureSpecularInfoV1;\r\n\r\n    // Double checks the enclosed info\r\n    let mipmapsCount = Scalar.Log2(info.width);\r\n    mipmapsCount = Math.round(mipmapsCount) + 1;\r\n    if (specularInfo.mipmaps.length !== 6 * mipmapsCount) {\r\n        throw new Error(`Unsupported specular mipmaps number \"${specularInfo.mipmaps.length}\"`);\r\n    }\r\n\r\n    const imageData = new Array<Array<ArrayBufferView>>(mipmapsCount);\r\n    for (let i = 0; i < mipmapsCount; i++) {\r\n        imageData[i] = new Array<ArrayBufferView>(6);\r\n        for (let face = 0; face < 6; face++) {\r\n            const imageInfo = specularInfo.mipmaps[i * 6 + face];\r\n            imageData[i][face] = new Uint8Array(data.buffer, data.byteOffset + specularInfo.specularDataPosition! + imageInfo.position, imageInfo.length);\r\n        }\r\n    }\r\n\r\n    return imageData;\r\n}\r\n\r\n/**\r\n * Uploads the texture info contained in the env file to the GPU.\r\n * @param texture defines the internal texture to upload to\r\n * @param data defines the data to load\r\n * @param info defines the texture info retrieved through the GetEnvInfo method\r\n * @returns a promise\r\n */\r\nexport function UploadEnvLevelsAsync(texture: InternalTexture, data: ArrayBufferView, info: EnvironmentTextureInfo): Promise<void> {\r\n    info = normalizeEnvInfo(info);\r\n\r\n    const specularInfo = info.specular as EnvironmentTextureSpecularInfoV1;\r\n    if (!specularInfo) {\r\n        // Nothing else parsed so far\r\n        return Promise.resolve();\r\n    }\r\n\r\n    texture._lodGenerationScale = specularInfo.lodGenerationScale;\r\n\r\n    const imageData = CreateImageDataArrayBufferViews(data, info);\r\n\r\n    return UploadLevelsAsync(texture, imageData, info.imageType);\r\n}\r\n\r\nfunction _OnImageReadyAsync(\r\n    image: HTMLImageElement | ImageBitmap,\r\n    engine: Engine,\r\n    expandTexture: boolean,\r\n    rgbdPostProcess: Nullable<PostProcess>,\r\n    url: string,\r\n    face: number,\r\n    i: number,\r\n    generateNonLODTextures: boolean,\r\n    lodTextures: Nullable<{ [lod: number]: BaseTexture }>,\r\n    cubeRtt: Nullable<RenderTargetWrapper>,\r\n    texture: InternalTexture\r\n): Promise<void> {\r\n    return new Promise((resolve, reject) => {\r\n        if (expandTexture) {\r\n            const tempTexture = engine.createTexture(\r\n                null,\r\n                true,\r\n                true,\r\n                null,\r\n                Constants.TEXTURE_NEAREST_SAMPLINGMODE,\r\n                null,\r\n                (message) => {\r\n                    reject(message);\r\n                },\r\n                image\r\n            );\r\n\r\n            rgbdPostProcess!.getEffect().executeWhenCompiled(() => {\r\n                // Uncompress the data to a RTT\r\n                rgbdPostProcess!.externalTextureSamplerBinding = true;\r\n                rgbdPostProcess!.onApply = (effect) => {\r\n                    effect._bindTexture(\"textureSampler\", tempTexture);\r\n                    effect.setFloat2(\"scale\", 1, engine._features.needsInvertingBitmap && image instanceof ImageBitmap ? -1 : 1);\r\n                };\r\n\r\n                if (!engine.scenes.length) {\r\n                    return;\r\n                }\r\n\r\n                engine.scenes[0].postProcessManager.directRender([rgbdPostProcess!], cubeRtt, true, face, i);\r\n\r\n                // Cleanup\r\n                engine.restoreDefaultFramebuffer();\r\n                tempTexture.dispose();\r\n                URL.revokeObjectURL(url);\r\n                resolve();\r\n            });\r\n        } else {\r\n            engine._uploadImageToTexture(texture, image, face, i);\r\n\r\n            // Upload the face to the non lod texture support\r\n            if (generateNonLODTextures) {\r\n                const lodTexture = lodTextures![i];\r\n                if (lodTexture) {\r\n                    engine._uploadImageToTexture(lodTexture._texture!, image, face, 0);\r\n                }\r\n            }\r\n            resolve();\r\n        }\r\n    });\r\n}\r\n\r\n/**\r\n * Uploads the levels of image data to the GPU.\r\n * @param texture defines the internal texture to upload to\r\n * @param imageData defines the array buffer views of image data [mipmap][face]\r\n * @param imageType the mime type of the image data\r\n * @returns a promise\r\n */\r\nexport function UploadLevelsAsync(texture: InternalTexture, imageData: ArrayBufferView[][], imageType: string = DefaultEnvironmentTextureImageType): Promise<void> {\r\n    if (!Tools.IsExponentOfTwo(texture.width)) {\r\n        throw new Error(\"Texture size must be a power of two\");\r\n    }\r\n\r\n    const mipmapsCount = Scalar.ILog2(texture.width) + 1;\r\n\r\n    // Gets everything ready.\r\n    const engine = texture.getEngine() as Engine;\r\n    let expandTexture = false;\r\n    let generateNonLODTextures = false;\r\n    let rgbdPostProcess: Nullable<PostProcess> = null;\r\n    let cubeRtt: Nullable<RenderTargetWrapper> = null;\r\n    let lodTextures: Nullable<{ [lod: number]: BaseTexture }> = null;\r\n    const caps = engine.getCaps();\r\n\r\n    texture.format = Constants.TEXTUREFORMAT_RGBA;\r\n    texture.type = Constants.TEXTURETYPE_UNSIGNED_INT;\r\n    texture.generateMipMaps = true;\r\n    texture._cachedAnisotropicFilteringLevel = null;\r\n    engine.updateTextureSamplingMode(Constants.TEXTURE_TRILINEAR_SAMPLINGMODE, texture);\r\n\r\n    // Add extra process if texture lod is not supported\r\n    if (!caps.textureLOD) {\r\n        expandTexture = false;\r\n        generateNonLODTextures = true;\r\n        lodTextures = {};\r\n    }\r\n    // in webgl 1 there are no ways to either render or copy lod level information for float textures.\r\n    else if (!engine._features.supportRenderAndCopyToLodForFloatTextures) {\r\n        expandTexture = false;\r\n    }\r\n    // If half float available we can uncompress the texture\r\n    else if (caps.textureHalfFloatRender && caps.textureHalfFloatLinearFiltering) {\r\n        expandTexture = true;\r\n        texture.type = Constants.TEXTURETYPE_HALF_FLOAT;\r\n    }\r\n    // If full float available we can uncompress the texture\r\n    else if (caps.textureFloatRender && caps.textureFloatLinearFiltering) {\r\n        expandTexture = true;\r\n        texture.type = Constants.TEXTURETYPE_FLOAT;\r\n    }\r\n\r\n    // Expand the texture if possible\r\n    if (expandTexture) {\r\n        // Simply run through the decode PP\r\n        rgbdPostProcess = new PostProcess(\r\n            \"rgbdDecode\",\r\n            \"rgbdDecode\",\r\n            null,\r\n            null,\r\n            1,\r\n            null,\r\n            Constants.TEXTURE_TRILINEAR_SAMPLINGMODE,\r\n            engine,\r\n            false,\r\n            undefined,\r\n            texture.type,\r\n            undefined,\r\n            null,\r\n            false\r\n        );\r\n\r\n        texture._isRGBD = false;\r\n        texture.invertY = false;\r\n        cubeRtt = engine.createRenderTargetCubeTexture(texture.width, {\r\n            generateDepthBuffer: false,\r\n            generateMipMaps: true,\r\n            generateStencilBuffer: false,\r\n            samplingMode: Constants.TEXTURE_TRILINEAR_SAMPLINGMODE,\r\n            type: texture.type,\r\n            format: Constants.TEXTUREFORMAT_RGBA,\r\n        });\r\n    } else {\r\n        texture._isRGBD = true;\r\n        texture.invertY = true;\r\n\r\n        // In case of missing support, applies the same patch than DDS files.\r\n        if (generateNonLODTextures) {\r\n            const mipSlices = 3;\r\n            const scale = texture._lodGenerationScale;\r\n            const offset = texture._lodGenerationOffset;\r\n\r\n            for (let i = 0; i < mipSlices; i++) {\r\n                //compute LOD from even spacing in smoothness (matching shader calculation)\r\n                const smoothness = i / (mipSlices - 1);\r\n                const roughness = 1 - smoothness;\r\n\r\n                const minLODIndex = offset; // roughness = 0\r\n                const maxLODIndex = (mipmapsCount - 1) * scale + offset; // roughness = 1 (mipmaps start from 0)\r\n\r\n                const lodIndex = minLODIndex + (maxLODIndex - minLODIndex) * roughness;\r\n                const mipmapIndex = Math.round(Math.min(Math.max(lodIndex, 0), maxLODIndex));\r\n\r\n                const glTextureFromLod = new InternalTexture(engine, InternalTextureSource.Temp);\r\n                glTextureFromLod.isCube = true;\r\n                glTextureFromLod.invertY = true;\r\n                glTextureFromLod.generateMipMaps = false;\r\n                engine.updateTextureSamplingMode(Constants.TEXTURE_LINEAR_LINEAR, glTextureFromLod);\r\n\r\n                // Wrap in a base texture for easy binding.\r\n                const lodTexture = new BaseTexture(null);\r\n                lodTexture._isCube = true;\r\n                lodTexture._texture = glTextureFromLod;\r\n                lodTextures![mipmapIndex] = lodTexture;\r\n\r\n                switch (i) {\r\n                    case 0:\r\n                        texture._lodTextureLow = lodTexture;\r\n                        break;\r\n                    case 1:\r\n                        texture._lodTextureMid = lodTexture;\r\n                        break;\r\n                    case 2:\r\n                        texture._lodTextureHigh = lodTexture;\r\n                        break;\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    const promises: Promise<void>[] = [];\r\n    // All mipmaps up to provided number of images\r\n    for (let i = 0; i < imageData.length; i++) {\r\n        // All faces\r\n        for (let face = 0; face < 6; face++) {\r\n            // Constructs an image element from image data\r\n            const bytes = imageData[i][face];\r\n            const blob = new Blob([bytes], { type: imageType });\r\n            const url = URL.createObjectURL(blob);\r\n            let promise: Promise<void>;\r\n\r\n            if (engine._features.forceBitmapOverHTMLImageElement) {\r\n                promise = engine.createImageBitmap(blob, { premultiplyAlpha: \"none\" }).then((img) => {\r\n                    return _OnImageReadyAsync(img, engine, expandTexture, rgbdPostProcess, url, face, i, generateNonLODTextures, lodTextures, cubeRtt, texture);\r\n                });\r\n            } else {\r\n                const image = new Image();\r\n                image.src = url;\r\n\r\n                // Enqueue promise to upload to the texture.\r\n                promise = new Promise<void>((resolve, reject) => {\r\n                    image.onload = () => {\r\n                        _OnImageReadyAsync(image, engine, expandTexture, rgbdPostProcess, url, face, i, generateNonLODTextures, lodTextures, cubeRtt, texture)\r\n                            .then(() => resolve())\r\n                            .catch((reason) => {\r\n                                reject(reason);\r\n                            });\r\n                    };\r\n                    image.onerror = (error) => {\r\n                        reject(error);\r\n                    };\r\n                });\r\n            }\r\n            promises.push(promise);\r\n        }\r\n    }\r\n\r\n    // Fill remaining mipmaps with black textures.\r\n    if (imageData.length < mipmapsCount) {\r\n        let data: ArrayBufferView;\r\n        const size = Math.pow(2, mipmapsCount - 1 - imageData.length);\r\n        const dataLength = size * size * 4;\r\n        switch (texture.type) {\r\n            case Constants.TEXTURETYPE_UNSIGNED_INT: {\r\n                data = new Uint8Array(dataLength);\r\n                break;\r\n            }\r\n            case Constants.TEXTURETYPE_HALF_FLOAT: {\r\n                data = new Uint16Array(dataLength);\r\n                break;\r\n            }\r\n            case Constants.TEXTURETYPE_FLOAT: {\r\n                data = new Float32Array(dataLength);\r\n                break;\r\n            }\r\n        }\r\n        for (let i = imageData.length; i < mipmapsCount; i++) {\r\n            for (let face = 0; face < 6; face++) {\r\n                engine._uploadArrayBufferViewToTexture(texture, data!, face, i);\r\n            }\r\n        }\r\n    }\r\n\r\n    // Once all done, finishes the cleanup and return\r\n    return Promise.all(promises).then(() => {\r\n        // Release temp RTT.\r\n        if (cubeRtt) {\r\n            engine._releaseTexture(texture);\r\n            cubeRtt._swapAndDie(texture);\r\n        }\r\n        // Release temp Post Process.\r\n        if (rgbdPostProcess) {\r\n            rgbdPostProcess.dispose();\r\n        }\r\n        // Flag internal texture as ready in case they are in use.\r\n        if (generateNonLODTextures) {\r\n            if (texture._lodTextureHigh && texture._lodTextureHigh._texture) {\r\n                texture._lodTextureHigh._texture.isReady = true;\r\n            }\r\n            if (texture._lodTextureMid && texture._lodTextureMid._texture) {\r\n                texture._lodTextureMid._texture.isReady = true;\r\n            }\r\n            if (texture._lodTextureLow && texture._lodTextureLow._texture) {\r\n                texture._lodTextureLow._texture.isReady = true;\r\n            }\r\n        }\r\n    });\r\n}\r\n\r\n/**\r\n * Uploads spherical polynomials information to the texture.\r\n * @param texture defines the texture we are trying to upload the information to\r\n * @param info defines the environment texture info retrieved through the GetEnvInfo method\r\n */\r\nexport function UploadEnvSpherical(texture: InternalTexture, info: EnvironmentTextureInfo): void {\r\n    info = normalizeEnvInfo(info);\r\n\r\n    const irradianceInfo = info.irradiance as EnvironmentTextureIrradianceInfoV1;\r\n    if (!irradianceInfo) {\r\n        return;\r\n    }\r\n\r\n    const sp = new SphericalPolynomial();\r\n    Vector3.FromArrayToRef(irradianceInfo.x, 0, sp.x);\r\n    Vector3.FromArrayToRef(irradianceInfo.y, 0, sp.y);\r\n    Vector3.FromArrayToRef(irradianceInfo.z, 0, sp.z);\r\n    Vector3.FromArrayToRef(irradianceInfo.xx, 0, sp.xx);\r\n    Vector3.FromArrayToRef(irradianceInfo.yy, 0, sp.yy);\r\n    Vector3.FromArrayToRef(irradianceInfo.zz, 0, sp.zz);\r\n    Vector3.FromArrayToRef(irradianceInfo.yz, 0, sp.yz);\r\n    Vector3.FromArrayToRef(irradianceInfo.zx, 0, sp.zx);\r\n    Vector3.FromArrayToRef(irradianceInfo.xy, 0, sp.xy);\r\n    texture._sphericalPolynomial = sp;\r\n}\r\n\r\n/**\r\n * @internal\r\n */\r\nexport function _UpdateRGBDAsync(\r\n    internalTexture: InternalTexture,\r\n    data: ArrayBufferView[][],\r\n    sphericalPolynomial: Nullable<SphericalPolynomial>,\r\n    lodScale: number,\r\n    lodOffset: number\r\n): Promise<InternalTexture> {\r\n    const proxy = internalTexture\r\n        .getEngine()\r\n        .createRawCubeTexture(\r\n            null,\r\n            internalTexture.width,\r\n            internalTexture.format,\r\n            internalTexture.type,\r\n            internalTexture.generateMipMaps,\r\n            internalTexture.invertY,\r\n            internalTexture.samplingMode,\r\n            internalTexture._compression\r\n        );\r\n    const proxyPromise = UploadLevelsAsync(proxy, data).then(() => internalTexture);\r\n    internalTexture.onRebuildCallback = (_internalTexture) => {\r\n        return {\r\n            proxy: proxyPromise,\r\n            isReady: true,\r\n            isAsync: true,\r\n        };\r\n    };\r\n    internalTexture._source = InternalTextureSource.CubeRawRGBD;\r\n    internalTexture._bufferViewArrayArray = data;\r\n    internalTexture._lodGenerationScale = lodScale;\r\n    internalTexture._lodGenerationOffset = lodOffset;\r\n    internalTexture._sphericalPolynomial = sphericalPolynomial;\r\n\r\n    return UploadLevelsAsync(internalTexture, data).then(() => {\r\n        internalTexture.isReady = true;\r\n        return internalTexture;\r\n    });\r\n}\r\n\r\n/**\r\n * Sets of helpers addressing the serialization and deserialization of environment texture\r\n * stored in a BabylonJS env file.\r\n * Those files are usually stored as .env files.\r\n */\r\nexport const EnvironmentTextureTools = {\r\n    /**\r\n     * Gets the environment info from an env file.\r\n     * @param data The array buffer containing the .env bytes.\r\n     * @returns the environment file info (the json header) if successfully parsed, normalized to the latest supported version.\r\n     */\r\n    GetEnvInfo,\r\n\r\n    /**\r\n     * Creates an environment texture from a loaded cube texture.\r\n     * @param texture defines the cube texture to convert in env file\r\n     * @param options options for the conversion process\r\n     * @param options.imageType the mime type for the encoded images, with support for \"image/png\" (default) and \"image/webp\"\r\n     * @param options.imageQuality the image quality of encoded WebP images.\r\n     * @returns a promise containing the environment data if successful.\r\n     */\r\n    CreateEnvTextureAsync,\r\n\r\n    /**\r\n     * Creates the ArrayBufferViews used for initializing environment texture image data.\r\n     * @param data the image data\r\n     * @param info parameters that determine what views will be created for accessing the underlying buffer\r\n     * @returns the views described by info providing access to the underlying buffer\r\n     */\r\n    CreateImageDataArrayBufferViews,\r\n\r\n    /**\r\n     * Uploads the texture info contained in the env file to the GPU.\r\n     * @param texture defines the internal texture to upload to\r\n     * @param data defines the data to load\r\n     * @param info defines the texture info retrieved through the GetEnvInfo method\r\n     * @returns a promise\r\n     */\r\n    UploadEnvLevelsAsync,\r\n\r\n    /**\r\n     * Uploads the levels of image data to the GPU.\r\n     * @param texture defines the internal texture to upload to\r\n     * @param imageData defines the array buffer views of image data [mipmap][face]\r\n     * @param imageType the mime type of the image data\r\n     * @returns a promise\r\n     */\r\n    UploadLevelsAsync,\r\n\r\n    /**\r\n     * Uploads spherical polynomials information to the texture.\r\n     * @param texture defines the texture we are trying to upload the information to\r\n     * @param info defines the environment texture info retrieved through the GetEnvInfo method\r\n     */\r\n    UploadEnvSpherical,\r\n};\r\n", "import type { IDisposable } from \"../scene\";\r\n\r\n/** @ignore */\r\ninterface WorkerInfo {\r\n    workerPromise: Promise<Worker>;\r\n    idle: boolean;\r\n    timeoutId?: ReturnType<typeof setTimeout>;\r\n}\r\n\r\n/**\r\n * Helper class to push actions to a pool of workers.\r\n */\r\nexport class WorkerPool implements IDisposable {\r\n    protected _workerInfos: Array<WorkerInfo>;\r\n    protected _pendingActions = new Array<(worker: Worker, onComplete: () => void) => void>();\r\n\r\n    /**\r\n     * Constructor\r\n     * @param workers Array of workers to use for actions\r\n     */\r\n    constructor(workers: Array<Worker>) {\r\n        this._workerInfos = workers.map((worker) => ({\r\n            workerPromise: Promise.resolve(worker),\r\n            idle: true,\r\n        }));\r\n    }\r\n\r\n    /**\r\n     * Terminates all workers and clears any pending actions.\r\n     */\r\n    public dispose(): void {\r\n        for (const workerInfo of this._workerInfos) {\r\n            workerInfo.workerPromise.then((worker) => {\r\n                worker.terminate();\r\n            });\r\n        }\r\n\r\n        this._workerInfos.length = 0;\r\n        this._pendingActions.length = 0;\r\n    }\r\n\r\n    /**\r\n     * Pushes an action to the worker pool. If all the workers are active, the action will be\r\n     * pended until a worker has completed its action.\r\n     * @param action The action to perform. Call onComplete when the action is complete.\r\n     */\r\n    public push(action: (worker: Worker, onComplete: () => void) => void): void {\r\n        if (!this._executeOnIdleWorker(action)) {\r\n            this._pendingActions.push(action);\r\n        }\r\n    }\r\n\r\n    protected _executeOnIdleWorker(action: (worker: Worker, onComplete: () => void) => void): boolean {\r\n        for (const workerInfo of this._workerInfos) {\r\n            if (workerInfo.idle) {\r\n                this._execute(workerInfo, action);\r\n                return true;\r\n            }\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    protected _execute(workerInfo: WorkerInfo, action: (worker: Worker, onComplete: () => void) => void): void {\r\n        workerInfo.idle = false;\r\n        workerInfo.workerPromise.then((worker) => {\r\n            action(worker, () => {\r\n                const nextAction = this._pendingActions.shift();\r\n                if (nextAction) {\r\n                    this._execute(workerInfo, nextAction);\r\n                } else {\r\n                    workerInfo.idle = true;\r\n                }\r\n            });\r\n        });\r\n    }\r\n}\r\n\r\n/**\r\n * Options for AutoReleaseWorkerPool\r\n */\r\nexport interface AutoReleaseWorkerPoolOptions {\r\n    /**\r\n     * Idle time elapsed before workers are terminated.\r\n     */\r\n    idleTimeElapsedBeforeRelease: number;\r\n}\r\n\r\n/**\r\n * Similar to the WorkerPool class except it creates and destroys workers automatically with a maximum of `maxWorkers` workers.\r\n * Workers are terminated when it is idle for at least `idleTimeElapsedBeforeRelease` milliseconds.\r\n */\r\nexport class AutoReleaseWorkerPool extends WorkerPool {\r\n    /**\r\n     * Default options for the constructor.\r\n     * Override to change the defaults.\r\n     */\r\n    public static DefaultOptions: AutoReleaseWorkerPoolOptions = {\r\n        idleTimeElapsedBeforeRelease: 1000,\r\n    };\r\n\r\n    private readonly _maxWorkers: number;\r\n    private readonly _createWorkerAsync: () => Promise<Worker>;\r\n    private readonly _options: AutoReleaseWorkerPoolOptions;\r\n\r\n    constructor(maxWorkers: number, createWorkerAsync: () => Promise<Worker>, options = AutoReleaseWorkerPool.DefaultOptions) {\r\n        super([]);\r\n\r\n        this._maxWorkers = maxWorkers;\r\n        this._createWorkerAsync = createWorkerAsync;\r\n        this._options = options;\r\n    }\r\n\r\n    public push(action: (worker: Worker, onComplete: () => void) => void): void {\r\n        if (!this._executeOnIdleWorker(action)) {\r\n            if (this._workerInfos.length < this._maxWorkers) {\r\n                const workerInfo: WorkerInfo = {\r\n                    workerPromise: this._createWorkerAsync(),\r\n                    idle: false,\r\n                };\r\n                this._workerInfos.push(workerInfo);\r\n                this._execute(workerInfo, action);\r\n            } else {\r\n                this._pendingActions.push(action);\r\n            }\r\n        }\r\n    }\r\n\r\n    protected _execute(workerInfo: WorkerInfo, action: (worker: Worker, onComplete: () => void) => void): void {\r\n        // Reset the idle timeout.\r\n        if (workerInfo.timeoutId) {\r\n            clearTimeout(workerInfo.timeoutId);\r\n            delete workerInfo.timeoutId;\r\n        }\r\n\r\n        super._execute(workerInfo, (worker, onComplete) => {\r\n            action(worker, () => {\r\n                onComplete();\r\n\r\n                if (workerInfo.idle) {\r\n                    // Schedule the worker to be terminated after the elapsed time.\r\n                    workerInfo.timeoutId = setTimeout(() => {\r\n                        workerInfo.workerPromise.then((worker) => {\r\n                            worker.terminate();\r\n                        });\r\n\r\n                        const indexOf = this._workerInfos.indexOf(workerInfo);\r\n                        if (indexOf !== -1) {\r\n                            this._workerInfos.splice(indexOf, 1);\r\n                        }\r\n                    }, this._options.idleTimeElapsedBeforeRelease);\r\n                }\r\n            });\r\n        });\r\n    }\r\n}\r\n", "import { ThinEngine } from \"../../Engines/thinEngine\";\r\nimport { InternalTexture, InternalTextureSource } from \"../../Materials/Textures/internalTexture\";\r\nimport { Logger } from \"../../Misc/logger\";\r\nimport type { Nullable } from \"../../types\";\r\nimport type { Scene } from \"../../scene\";\r\nimport type { IInternalTextureLoader } from \"../../Materials/Textures/internalTextureLoader\";\r\nimport { LoadImage } from \"../../Misc/fileTools\";\r\nimport { RandomGUID } from \"../../Misc/guid\";\r\nimport type { IWebRequest } from \"../../Misc/interfaces/iWebRequest\";\r\nimport { Constants } from \"../constants\";\r\nimport type { DepthTextureCreationOptions } from \"../../Materials/Textures/textureCreationOptions\";\r\n\r\ndeclare module \"../../Engines/thinEngine\" {\r\n    export interface ThinEngine {\r\n        /**\r\n         * Creates a depth stencil cube texture.\r\n         * This is only available in WebGL 2.\r\n         * @param size The size of face edge in the cube texture.\r\n         * @param options The options defining the cube texture.\r\n         * @returns The cube texture\r\n         */\r\n        _createDepthStencilCubeTexture(size: number, options: DepthTextureCreationOptions): InternalTexture;\r\n\r\n        /**\r\n         * Creates a cube texture\r\n         * @param rootUrl defines the url where the files to load is located\r\n         * @param scene defines the current scene\r\n         * @param files defines the list of files to load (1 per face)\r\n         * @param noMipmap defines a boolean indicating that no mipmaps shall be generated (false by default)\r\n         * @param onLoad defines an optional callback raised when the texture is loaded\r\n         * @param onError defines an optional callback raised if there is an issue to load the texture\r\n         * @param format defines the format of the data\r\n         * @param forcedExtension defines the extension to use to pick the right loader\r\n         * @param createPolynomials if a polynomial sphere should be created for the cube texture\r\n         * @param lodScale defines the scale applied to environment texture. This manages the range of LOD level used for IBL according to the roughness\r\n         * @param lodOffset defines the offset applied to environment texture. This manages first LOD level used for IBL according to the roughness\r\n         * @param fallback defines texture to use while falling back when (compressed) texture file not found.\r\n         * @param loaderOptions options to be passed to the loader\r\n         * @param useSRGBBuffer defines if the texture must be loaded in a sRGB GPU buffer (if supported by the GPU).\r\n         * @returns the cube texture as an InternalTexture\r\n         */\r\n        createCubeTexture(\r\n            rootUrl: string,\r\n            scene: Nullable<Scene>,\r\n            files: Nullable<string[]>,\r\n            noMipmap: boolean | undefined,\r\n            onLoad: Nullable<(data?: any) => void>,\r\n            onError: Nullable<(message?: string, exception?: any) => void>,\r\n            format: number | undefined,\r\n            forcedExtension: any,\r\n            createPolynomials: boolean,\r\n            lodScale: number,\r\n            lodOffset: number,\r\n            fallback: Nullable<InternalTexture>,\r\n            loaderOptions: any,\r\n            useSRGBBuffer: boolean\r\n        ): InternalTexture;\r\n\r\n        /**\r\n         * Creates a cube texture\r\n         * @param rootUrl defines the url where the files to load is located\r\n         * @param scene defines the current scene\r\n         * @param files defines the list of files to load (1 per face)\r\n         * @param noMipmap defines a boolean indicating that no mipmaps shall be generated (false by default)\r\n         * @param onLoad defines an optional callback raised when the texture is loaded\r\n         * @param onError defines an optional callback raised if there is an issue to load the texture\r\n         * @param format defines the format of the data\r\n         * @param forcedExtension defines the extension to use to pick the right loader\r\n         * @returns the cube texture as an InternalTexture\r\n         */\r\n        createCubeTexture(\r\n            rootUrl: string,\r\n            scene: Nullable<Scene>,\r\n            files: Nullable<string[]>,\r\n            noMipmap: boolean,\r\n            onLoad: Nullable<(data?: any) => void>,\r\n            onError: Nullable<(message?: string, exception?: any) => void>,\r\n            format: number | undefined,\r\n            forcedExtension: any\r\n        ): InternalTexture;\r\n\r\n        /**\r\n         * Creates a cube texture\r\n         * @param rootUrl defines the url where the files to load is located\r\n         * @param scene defines the current scene\r\n         * @param files defines the list of files to load (1 per face)\r\n         * @param noMipmap defines a boolean indicating that no mipmaps shall be generated (false by default)\r\n         * @param onLoad defines an optional callback raised when the texture is loaded\r\n         * @param onError defines an optional callback raised if there is an issue to load the texture\r\n         * @param format defines the format of the data\r\n         * @param forcedExtension defines the extension to use to pick the right loader\r\n         * @param createPolynomials if a polynomial sphere should be created for the cube texture\r\n         * @param lodScale defines the scale applied to environment texture. This manages the range of LOD level used for IBL according to the roughness\r\n         * @param lodOffset defines the offset applied to environment texture. This manages first LOD level used for IBL according to the roughness\r\n         * @returns the cube texture as an InternalTexture\r\n         */\r\n        createCubeTexture(\r\n            rootUrl: string,\r\n            scene: Nullable<Scene>,\r\n            files: Nullable<string[]>,\r\n            noMipmap: boolean,\r\n            onLoad: Nullable<(data?: any) => void>,\r\n            onError: Nullable<(message?: string, exception?: any) => void>,\r\n            format: number | undefined,\r\n            forcedExtension: any,\r\n            createPolynomials: boolean,\r\n            lodScale: number,\r\n            lodOffset: number\r\n        ): InternalTexture;\r\n\r\n        /** @internal */\r\n        createCubeTextureBase(\r\n            rootUrl: string,\r\n            scene: Nullable<Scene>,\r\n            files: Nullable<string[]>,\r\n            noMipmap: boolean,\r\n            onLoad: Nullable<(data?: any) => void>,\r\n            onError: Nullable<(message?: string, exception?: any) => void>,\r\n            format: number | undefined,\r\n            forcedExtension: any,\r\n            createPolynomials: boolean,\r\n            lodScale: number,\r\n            lodOffset: number,\r\n            fallback: Nullable<InternalTexture>,\r\n            beforeLoadCubeDataCallback: Nullable<(texture: InternalTexture, data: ArrayBufferView | ArrayBufferView[]) => void>,\r\n            imageHandler: Nullable<(texture: InternalTexture, imgs: HTMLImageElement[] | ImageBitmap[]) => void>,\r\n            useSRGBBuffer: boolean\r\n        ): InternalTexture;\r\n\r\n        /** @internal */\r\n        _partialLoadFile(\r\n            url: string,\r\n            index: number,\r\n            loadedFiles: ArrayBuffer[],\r\n            onfinish: (files: ArrayBuffer[]) => void,\r\n            onErrorCallBack: Nullable<(message?: string, exception?: any) => void>\r\n        ): void;\r\n\r\n        /** @internal */\r\n        _cascadeLoadFiles(scene: Nullable<Scene>, onfinish: (images: ArrayBuffer[]) => void, files: string[], onError: Nullable<(message?: string, exception?: any) => void>): void;\r\n\r\n        /** @internal */\r\n        _cascadeLoadImgs(\r\n            scene: Nullable<Scene>,\r\n            texture: InternalTexture,\r\n            onfinish: Nullable<(texture: InternalTexture, images: HTMLImageElement[] | ImageBitmap[]) => void>,\r\n            files: string[],\r\n            onError: Nullable<(message?: string, exception?: any) => void>,\r\n            mimeType?: string\r\n        ): void;\r\n\r\n        /** @internal */\r\n        _partialLoadImg(\r\n            url: string,\r\n            index: number,\r\n            loadedImages: HTMLImageElement[] | ImageBitmap[],\r\n            scene: Nullable<Scene>,\r\n            texture: InternalTexture,\r\n            onfinish: Nullable<(texture: InternalTexture, images: HTMLImageElement[] | ImageBitmap[]) => void>,\r\n            onErrorCallBack: Nullable<(message?: string, exception?: any) => void>,\r\n            mimeType?: string\r\n        ): void;\r\n\r\n        /**\r\n         * @internal\r\n         */\r\n        _setCubeMapTextureParams(texture: InternalTexture, loadMipmap: boolean, maxLevel?: number): void;\r\n    }\r\n}\r\n\r\nThinEngine.prototype._createDepthStencilCubeTexture = function (size: number, options: DepthTextureCreationOptions): InternalTexture {\r\n    const internalTexture = new InternalTexture(this, InternalTextureSource.DepthStencil);\r\n    internalTexture.isCube = true;\r\n\r\n    if (this.webGLVersion === 1) {\r\n        Logger.Error(\"Depth cube texture is not supported by WebGL 1.\");\r\n        return internalTexture;\r\n    }\r\n\r\n    const internalOptions = {\r\n        bilinearFiltering: false,\r\n        comparisonFunction: 0,\r\n        generateStencil: false,\r\n        ...options,\r\n    };\r\n\r\n    const gl = this._gl;\r\n    this._bindTextureDirectly(gl.TEXTURE_CUBE_MAP, internalTexture, true);\r\n\r\n    this._setupDepthStencilTexture(internalTexture, size, internalOptions.generateStencil, internalOptions.bilinearFiltering, internalOptions.comparisonFunction);\r\n\r\n    // Create the depth/stencil buffer\r\n    for (let face = 0; face < 6; face++) {\r\n        if (internalOptions.generateStencil) {\r\n            gl.texImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + face, 0, gl.DEPTH24_STENCIL8, size, size, 0, gl.DEPTH_STENCIL, gl.UNSIGNED_INT_24_8, null);\r\n        } else {\r\n            gl.texImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + face, 0, gl.DEPTH_COMPONENT24, size, size, 0, gl.DEPTH_COMPONENT, gl.UNSIGNED_INT, null);\r\n        }\r\n    }\r\n\r\n    this._bindTextureDirectly(gl.TEXTURE_CUBE_MAP, null);\r\n\r\n    this._internalTexturesCache.push(internalTexture);\r\n\r\n    return internalTexture;\r\n};\r\n\r\nThinEngine.prototype._partialLoadFile = function (\r\n    url: string,\r\n    index: number,\r\n    loadedFiles: ArrayBuffer[],\r\n    onfinish: (files: ArrayBuffer[]) => void,\r\n    onErrorCallBack: Nullable<(message?: string, exception?: any) => void> = null\r\n): void {\r\n    const onload = (data: ArrayBuffer) => {\r\n        loadedFiles[index] = data;\r\n        (<any>loadedFiles)._internalCount++;\r\n\r\n        if ((<any>loadedFiles)._internalCount === 6) {\r\n            onfinish(loadedFiles);\r\n        }\r\n    };\r\n\r\n    const onerror = (request?: IWebRequest, exception?: any) => {\r\n        if (onErrorCallBack && request) {\r\n            onErrorCallBack(request.status + \" \" + request.statusText, exception);\r\n        }\r\n    };\r\n\r\n    this._loadFile(url, onload as (data: string | ArrayBuffer) => void, undefined, undefined, true, onerror);\r\n};\r\n\r\nThinEngine.prototype._cascadeLoadFiles = function (\r\n    scene: Nullable<Scene>,\r\n    onfinish: (images: ArrayBuffer[]) => void,\r\n    files: string[],\r\n    onError: Nullable<(message?: string, exception?: any) => void> = null\r\n): void {\r\n    const loadedFiles: ArrayBuffer[] = [];\r\n    (<any>loadedFiles)._internalCount = 0;\r\n\r\n    for (let index = 0; index < 6; index++) {\r\n        this._partialLoadFile(files[index], index, loadedFiles, onfinish, onError);\r\n    }\r\n};\r\n\r\nThinEngine.prototype._cascadeLoadImgs = function (\r\n    scene: Nullable<Scene>,\r\n    texture: InternalTexture,\r\n    onfinish: Nullable<(texture: InternalTexture, images: HTMLImageElement[] | ImageBitmap[]) => void>,\r\n    files: string[],\r\n    onError: Nullable<(message?: string, exception?: any) => void> = null,\r\n    mimeType?: string\r\n) {\r\n    const loadedImages: HTMLImageElement[] | ImageBitmap[] = [];\r\n    (<any>loadedImages)._internalCount = 0;\r\n\r\n    for (let index = 0; index < 6; index++) {\r\n        this._partialLoadImg(files[index], index, loadedImages, scene, texture, onfinish, onError, mimeType);\r\n    }\r\n};\r\n\r\nThinEngine.prototype._partialLoadImg = function (\r\n    url: string,\r\n    index: number,\r\n    loadedImages: HTMLImageElement[] | ImageBitmap[],\r\n    scene: Nullable<Scene>,\r\n    texture: InternalTexture,\r\n    onfinish: Nullable<(texture: InternalTexture, images: HTMLImageElement[] | ImageBitmap[]) => void>,\r\n    onErrorCallBack: Nullable<(message?: string, exception?: any) => void> = null,\r\n    mimeType?: string\r\n) {\r\n    const tokenPendingData = RandomGUID();\r\n\r\n    const onload = (img: HTMLImageElement | ImageBitmap) => {\r\n        loadedImages[index] = img;\r\n        (<any>loadedImages)._internalCount++;\r\n\r\n        if (scene) {\r\n            scene.removePendingData(tokenPendingData);\r\n        }\r\n\r\n        if ((<any>loadedImages)._internalCount === 6 && onfinish) {\r\n            onfinish(texture, loadedImages);\r\n        }\r\n    };\r\n\r\n    const onerror = (message?: string, exception?: any) => {\r\n        if (scene) {\r\n            scene.removePendingData(tokenPendingData);\r\n        }\r\n\r\n        if (onErrorCallBack) {\r\n            onErrorCallBack(message, exception);\r\n        }\r\n    };\r\n\r\n    LoadImage(url, onload, onerror, scene ? scene.offlineProvider : null, mimeType);\r\n    if (scene) {\r\n        scene.addPendingData(tokenPendingData);\r\n    }\r\n};\r\n\r\nThinEngine.prototype._setCubeMapTextureParams = function (texture: InternalTexture, loadMipmap: boolean, maxLevel?: number): void {\r\n    const gl = this._gl;\r\n    gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MAG_FILTER, gl.LINEAR);\r\n    gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MIN_FILTER, loadMipmap ? gl.LINEAR_MIPMAP_LINEAR : gl.LINEAR);\r\n    gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\r\n    gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\r\n    texture.samplingMode = loadMipmap ? Constants.TEXTURE_TRILINEAR_SAMPLINGMODE : Constants.TEXTURE_LINEAR_LINEAR;\r\n\r\n    if (loadMipmap && this.getCaps().textureMaxLevel && maxLevel !== undefined && maxLevel > 0) {\r\n        gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MAX_LEVEL, maxLevel);\r\n        texture._maxLodLevel = maxLevel;\r\n    }\r\n\r\n    this._bindTextureDirectly(gl.TEXTURE_CUBE_MAP, null);\r\n};\r\n\r\nThinEngine.prototype.createCubeTextureBase = function (\r\n    rootUrl: string,\r\n    scene: Nullable<Scene>,\r\n    files: Nullable<string[]>,\r\n    noMipmap?: boolean,\r\n    onLoad: Nullable<(data?: any) => void> = null,\r\n    onError: Nullable<(message?: string, exception?: any) => void> = null,\r\n    format?: number,\r\n    forcedExtension: any = null,\r\n    createPolynomials: boolean = false,\r\n    lodScale: number = 0,\r\n    lodOffset: number = 0,\r\n    fallback: Nullable<InternalTexture> = null,\r\n    beforeLoadCubeDataCallback: Nullable<(texture: InternalTexture, data: ArrayBufferView | ArrayBufferView[]) => void> = null,\r\n    imageHandler: Nullable<(texture: InternalTexture, imgs: HTMLImageElement[] | ImageBitmap[]) => void> = null,\r\n    useSRGBBuffer = false\r\n): InternalTexture {\r\n    const texture = fallback ? fallback : new InternalTexture(this, InternalTextureSource.Cube);\r\n    texture.isCube = true;\r\n    texture.url = rootUrl;\r\n    texture.generateMipMaps = !noMipmap;\r\n    texture._lodGenerationScale = lodScale;\r\n    texture._lodGenerationOffset = lodOffset;\r\n    texture._useSRGBBuffer = !!useSRGBBuffer && this._caps.supportSRGBBuffers && (this.webGLVersion > 1 || this.isWebGPU || !!noMipmap);\r\n    if (texture !== fallback) {\r\n        texture.label = rootUrl.substring(0, 60); // default label, can be overriden by the caller\r\n    }\r\n\r\n    if (!this._doNotHandleContextLost) {\r\n        texture._extension = forcedExtension;\r\n        texture._files = files;\r\n    }\r\n\r\n    const originalRootUrl = rootUrl;\r\n    if (this._transformTextureUrl && !fallback) {\r\n        rootUrl = this._transformTextureUrl(rootUrl);\r\n    }\r\n\r\n    const rootUrlWithoutUriParams = rootUrl.split(\"?\")[0];\r\n    const lastDot = rootUrlWithoutUriParams.lastIndexOf(\".\");\r\n    const extension = forcedExtension ? forcedExtension : lastDot > -1 ? rootUrlWithoutUriParams.substring(lastDot).toLowerCase() : \"\";\r\n\r\n    let loader: Nullable<IInternalTextureLoader> = null;\r\n    for (const availableLoader of ThinEngine._TextureLoaders) {\r\n        if (availableLoader.canLoad(extension)) {\r\n            loader = availableLoader;\r\n            break;\r\n        }\r\n    }\r\n\r\n    const onInternalError = (request?: IWebRequest, exception?: any) => {\r\n        if (rootUrl === originalRootUrl) {\r\n            if (onError && request) {\r\n                onError(request.status + \" \" + request.statusText, exception);\r\n            }\r\n        } else {\r\n            // fall back to the original url if the transformed url fails to load\r\n            Logger.Warn(`Failed to load ${rootUrl}, falling back to the ${originalRootUrl}`);\r\n            this.createCubeTextureBase(\r\n                originalRootUrl,\r\n                scene,\r\n                files,\r\n                !!noMipmap,\r\n                onLoad,\r\n                onError,\r\n                format,\r\n                forcedExtension,\r\n                createPolynomials,\r\n                lodScale,\r\n                lodOffset,\r\n                texture,\r\n                beforeLoadCubeDataCallback,\r\n                imageHandler,\r\n                useSRGBBuffer\r\n            );\r\n        }\r\n    };\r\n\r\n    if (loader) {\r\n        const onloaddata = (data: ArrayBufferView | ArrayBufferView[]) => {\r\n            if (beforeLoadCubeDataCallback) {\r\n                beforeLoadCubeDataCallback(texture, data);\r\n            }\r\n            loader!.loadCubeData(data, texture, createPolynomials, onLoad, onError);\r\n        };\r\n        if (files && files.length === 6) {\r\n            if (loader.supportCascades) {\r\n                this._cascadeLoadFiles(scene, (images) => onloaddata(images.map((image) => new Uint8Array(image))), files, onError);\r\n            } else {\r\n                if (onError) {\r\n                    onError(\"Textures type does not support cascades.\");\r\n                } else {\r\n                    Logger.Warn(\"Texture loader does not support cascades.\");\r\n                }\r\n            }\r\n        } else {\r\n            this._loadFile(rootUrl, (data) => onloaddata(new Uint8Array(data as ArrayBuffer)), undefined, undefined, true, onInternalError);\r\n        }\r\n    } else {\r\n        if (!files || files.length === 0) {\r\n            throw new Error(\"Cannot load cubemap because files were not defined, or the correct loader was not found.\");\r\n        }\r\n\r\n        this._cascadeLoadImgs(\r\n            scene,\r\n            texture,\r\n            (texture: InternalTexture, imgs: HTMLImageElement[] | ImageBitmap[]) => {\r\n                if (imageHandler) {\r\n                    imageHandler(texture, imgs);\r\n                }\r\n            },\r\n            files,\r\n            onError\r\n        );\r\n    }\r\n\r\n    this._internalTexturesCache.push(texture);\r\n\r\n    return texture;\r\n};\r\n\r\nThinEngine.prototype.createCubeTexture = function (\r\n    rootUrl: string,\r\n    scene: Nullable<Scene>,\r\n    files: Nullable<string[]>,\r\n    noMipmap?: boolean,\r\n    onLoad: Nullable<(data?: any) => void> = null,\r\n    onError: Nullable<(message?: string, exception?: any) => void> = null,\r\n    format?: number,\r\n    forcedExtension: any = null,\r\n    createPolynomials: boolean = false,\r\n    lodScale: number = 0,\r\n    lodOffset: number = 0,\r\n    fallback: Nullable<InternalTexture> = null,\r\n    loaderOptions?: any,\r\n    useSRGBBuffer = false\r\n): InternalTexture {\r\n    const gl = this._gl;\r\n\r\n    return this.createCubeTextureBase(\r\n        rootUrl,\r\n        scene,\r\n        files,\r\n        !!noMipmap,\r\n        onLoad,\r\n        onError,\r\n        format,\r\n        forcedExtension,\r\n        createPolynomials,\r\n        lodScale,\r\n        lodOffset,\r\n        fallback,\r\n        (texture: InternalTexture) => this._bindTextureDirectly(gl.TEXTURE_CUBE_MAP, texture, true),\r\n        (texture: InternalTexture, imgs: HTMLImageElement[] | ImageBitmap[]) => {\r\n            const width = this.needPOTTextures ? ThinEngine.GetExponentOfTwo(imgs[0].width, this._caps.maxCubemapTextureSize) : imgs[0].width;\r\n            const height = width;\r\n\r\n            const faces = [\r\n                gl.TEXTURE_CUBE_MAP_POSITIVE_X,\r\n                gl.TEXTURE_CUBE_MAP_POSITIVE_Y,\r\n                gl.TEXTURE_CUBE_MAP_POSITIVE_Z,\r\n                gl.TEXTURE_CUBE_MAP_NEGATIVE_X,\r\n                gl.TEXTURE_CUBE_MAP_NEGATIVE_Y,\r\n                gl.TEXTURE_CUBE_MAP_NEGATIVE_Z,\r\n            ];\r\n\r\n            this._bindTextureDirectly(gl.TEXTURE_CUBE_MAP, texture, true);\r\n            this._unpackFlipY(false);\r\n\r\n            const internalFormat = format ? this._getInternalFormat(format, texture._useSRGBBuffer) : texture._useSRGBBuffer ? this._glSRGBExtensionValues.SRGB8_ALPHA8 : gl.RGBA;\r\n            let texelFormat = format ? this._getInternalFormat(format) : gl.RGBA;\r\n\r\n            if (texture._useSRGBBuffer && this.webGLVersion === 1) {\r\n                texelFormat = internalFormat;\r\n            }\r\n\r\n            for (let index = 0; index < faces.length; index++) {\r\n                if (imgs[index].width !== width || imgs[index].height !== height) {\r\n                    this._prepareWorkingCanvas();\r\n\r\n                    if (!this._workingCanvas || !this._workingContext) {\r\n                        Logger.Warn(\"Cannot create canvas to resize texture.\");\r\n                        return;\r\n                    }\r\n                    this._workingCanvas.width = width;\r\n                    this._workingCanvas.height = height;\r\n\r\n                    this._workingContext.drawImage(imgs[index], 0, 0, imgs[index].width, imgs[index].height, 0, 0, width, height);\r\n                    gl.texImage2D(faces[index], 0, internalFormat, texelFormat, gl.UNSIGNED_BYTE, this._workingCanvas as TexImageSource);\r\n                } else {\r\n                    gl.texImage2D(faces[index], 0, internalFormat, texelFormat, gl.UNSIGNED_BYTE, imgs[index]);\r\n                }\r\n            }\r\n\r\n            if (!noMipmap) {\r\n                gl.generateMipmap(gl.TEXTURE_CUBE_MAP);\r\n            }\r\n\r\n            this._setCubeMapTextureParams(texture, !noMipmap);\r\n\r\n            texture.width = width;\r\n            texture.height = height;\r\n            texture.isReady = true;\r\n            if (format) {\r\n                texture.format = format;\r\n            }\r\n\r\n            texture.onLoadedObservable.notifyObservers(texture);\r\n            texture.onLoadedObservable.clear();\r\n\r\n            if (onLoad) {\r\n                onLoad();\r\n            }\r\n        },\r\n        !!useSRGBBuffer\r\n    );\r\n};\r\n"],
  "mappings": "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",
  "names": ["name", "name", "shader", "name", "name", "shader", "i", "worker", "texture"]
}
